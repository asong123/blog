---
title: 37、Redis精讲
urlname: hq3ob2
date: '2021-07-09 20:48:10 +0800'
tags: []
categories: []
---

# NoSQL 概述

## 为什么用 NoSQL

1、单机 MySQL 的美好年代
在 90 年代，一个网站的访问量一般不大，用单个数据库完全可以轻松应付！ 在那个时候，更多的都是静态网页，动态交互类型的网站不多。
上述架构下，我们来看看数据存储的瓶颈是什么？

1. 数据量的总大小，一个机器放不下时
1. 数据的索引（B+ Tree）一个机器的内存放不下时
1. 访问量（读写混合）一个实例不能承受

如果满足了上述 1 or 3 个，进化....
DAL：数据库访问层
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834893847-d99750c5-8a39-423d-a07f-082f59bb26b2.png#)
2、Memcached（缓存）+ MySQL + 垂直拆分

后来，随着访问量的上升，几乎大部分使用 MySQL 架构的网站在数据库上都开始出现了性能问题，web 程序不再仅仅专注在功能上，同时也在追求性能。程序猿们开始大量使用缓存技术来缓解数据库的压 力，优化数据库的结构和索引，开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续 增大的时候，多台 web 机器通过文件缓存不能共享，大量的小文件缓存也带了比较高的 IO 压力，在这个 时候，Memcached 就自然的成为一个非常时尚的技术产品。
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834894217-d307f4f1-166a-461f-8bc4-587d7a268ee7.png#)

3、MySQL 主从读写分离
由于数据库的写入压力增加，Memcached 只能缓解数据库的读取压力，读写集中在一个数据库上让数 据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展 性，MySQL 的 master-slave 模式成为这个时候的网站标配了。

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834894490-3c78d76f-8dbe-4118-8b6b-6c1056f8d47f.jpeg#)

4、分表分库 + 水平拆分 + Mysql 集群
在 Memcached 的高速缓存，MySQL 的主从复制，读写分离的基础之上，这时 MySQL 主库的写压力开始出现瓶颈，而数据量的持续猛增，由于 MyISAM 使用表锁，在高并发下会出现严重的锁问题，大量的高 并发 MySQL 应用开始使用 InnoDB 引擎代替 MyISAM。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834894888-9afa5bfc-7d7d-4bee-b6f0-44f664b2e447.jpeg#)同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题，这个时候，分表分库成了一个热门 技术，是面试的热门问题，也是业界讨论的热门技术问题。也就是在这个时候，MySQL 推出了还不太稳 定的表分区，这也给技术实力一般的公司带来了希望。虽然 MySQL 推出了 MySQL Cluster 集群，但性能也不能很好满足互联网的需求，只是在高可靠性上提供了非常大的保证。
5、MySQL 的扩展性瓶颈

MySQL 数据库也经常存储一些大文本的字段，导致数据库表非常的大，在做数据库恢复的时候就导致非 常的慢，不容易快速恢复数据库，比如 1000 万 4KB 大小的文本就接近 40GB 的大小，如果能把这些数据从 MySQL 省去，MySQL 将变的非常的小，关系数据库很强大，但是它并不能很好的应付所有的应用场景，MySQL 的扩展性差（需要复杂的技术来实现），大数据下 IO 压力大，表结构更改困难，正是当前使 用 MySQL 的开发人员面临的问题。

6、今天是什么样子？？

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834895204-768161e9-b377-4f52-8174-fc0bc9b655bc.png#)

7、为什么用 NoSQL？
今天我们可以通过第三方平台（如：Google，FaceBook 等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加、我们如果要对这些用 户数据进行挖掘，那 SQL 数据库已经不适合这些应用了，而 NoSQL 数据库的发展却能很好的处理这些大 的数据！

## 什么是 NoSQL

NoSQL
NoSQL = Not Only SQL，意思：不仅仅是 SQL；
泛指非关系型的数据库，随着互联网 Web2.0 网站的兴起，传统的关系数据库在应付 web2.0 网站，特别是超大规模和高并发的社交网络服务类型的 Web2.0 纯动态网站已经显得力不从心，暴露了很多难以克服 的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展，NoSQL 数据库的产生就是为 了解决大规模数据集合多种数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。
（例如谷歌或 Facebook 每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模 式，无需多余操作就可以横向扩展。

NoSQL 的特点

### 1、易扩展

NoSQL 数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。
数据之间无关系，这样就非常容易扩展，也无形之间，在架构的层面上带来了可扩展的能力。

### 2、大数据量高性能

NoSQL 数据库都具有非常高的读写性能，尤其是在大数据量下，同样表现优秀。这得益于它的非关系 性，数据库的结构简单。
一般 MySQL 使用 Query Cache，每次表的更新 Cache 就失效，是一种大力度的 Cache，在针对 Web2.0 的交互频繁应用，Cache 性能不高，而 NoSQL 的 Cache 是记录级的，是一种细粒度的 Cache，所以 NoSQL 在这个层面上来说就要性能高很多了。
官方记录：Redis 一秒可以写 8 万次，读 11 万次！

### 3、多样灵活的数据模型

NoSQL 无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式，而在关系数据库里，增删 字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是噩梦。

### 4、传统的 RDBMS VS NoSQL

| 1   | 传统的关系型数据库 RDBMS                   |
| --- | ------------------------------------------ |
| 2   | - 高度组织化结构化数据                     |
| 3   | - 结构化查询语言（SQL）                    |
| 4   | - 数据和关系都存储在单独的表中             |
| 5   | - 数据操纵语言，数据定义语言               |
| 6   | - 严格的一致性                             |
| 7   | - 基础事务                                 |
| 8   |                                            |
| 9   | NoSQL                                      |
| 10  | - 代表着不仅仅是 SQL                       |
| 11  | - 没有声明性查询语言                       |
| 12  | - 没有预定义的模式                         |
| 13  | - 键值对存储，列存储，文档存储，图形数据库 |
| 14  | - 最终一致性，而非 ACID 属性               |
| 15  | - 非结构化和不可预知的数据                 |
| 16  | - CAP 定理                                 |
| 17  | - 高性能，高可用性 和 可伸缩性             |

拓展：3V+3 高
大数据时代的 3V ： 主要是对问题的描述海量 Volume
多样 Variety
实时 Velocity
互联网需求的 3 高 ： 主要是对程序的要求高并发
高可用
高性能
当下的应用是 SQL 和 NoSQL 一起使用，技术没有高低之分，就看你怎么用，对吧！

## 经典应用分析

### 聊聊阿里巴巴中文网站的商品信息如何存放，以女装、包包为例：

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834895587-b213d10e-d468-40b0-b79c-284ec34fee7b.jpeg#)

聊聊架构发展历程：推荐书籍《淘宝技术这十年》
1、演变过程：以下图片资料来源：阿里巴巴中文站架构设计实践
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834895949-b7b53697-12ba-45d7-a49b-e2de7e2a5c6f.jpeg#)
2、第五代

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834896378-e38df979-6c3b-417f-b714-756670649a71.jpeg#)

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834896636-5299a9fc-228f-419f-b513-ee8f84cb4154.jpeg#)3、第 5 代架构使命

和我们相关的，多数据源多数据类型的存储问题

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834896993-6c051bb6-f431-438a-ad2d-80a518160df5.jpeg#)
1、商品的基本信息

| 1   | 名称、价格、出厂日期、生产厂商等                                                                   |
| --- | -------------------------------------------------------------------------------------------------- |
| 2   | 关系型数据库：mysql、oracle 目前淘宝在去 O 化（也即，拿掉 Oracle）                                 |
| 3   | 注意，淘宝内部用的 MySQL 是里面的大牛自己改造过的。                                                |
| 4   |                                                                                                    |
| 5   | 为什么去 IOE：                                                                                     |
| 6   | 2008 年,王坚博士加入阿里巴巴，成为首席架构师。把云计算植入阿里 IT 基因。                           |
| 7   | 2013 年 5 月 17 日，阿里集团最后一台 IBM 小机在支付宝下线。这是自 2009 年“去 IOE”战略透露以来，“去 |
|     | IOE”非常重要的一个节点。“去 IOE”指的是摆脱掉 IT 部署中原有的 IBM 小型机、Oracle 数据库以及 EMC     |
|     | 存储的过度依赖。告别最后一台小机，意味着整个阿里集团尽管还有一些 Oracle 数据库和 EMC 存储，但是    |
|     | IBM 小型机已全部被替换。2013 年 7 月 10 日，淘宝重中之重的广告系统使用的 Oracle 数据库下线，也是整 |
|     | 个淘宝最后一个 Oracle 数据库。这两件事合在一起是阿里巴巴技术发展过程中的一个重要里程碑。           |

2、商品描述、详情、评价信息（多文字类）

| 1   | 多文字信息描述类，IO 读写性能变差 |
| --- | --------------------------------- |
| 2   | 存在文档数据库 MongDB 中          |

3、商品的图片

| 1   | 商品图片展现类   |      |
| --- | ---------------- | ---- |
| 2   | 分布式文件系统中 |      |
| 3   | - 淘宝自己的     | TFS  |
| 4   | - Google 的      | GFS  |
| 5   | - Hadoop 的      | HDFS |

4、商品的关键字

| 1   | 搜索引擎，淘宝内用                                                              |
| --- | ------------------------------------------------------------------------------- |
| 2   | ISearch：多隆一高兴一个人开发的                                                 |
| 3   |                                                                                 |
| 4   | 所有牛逼的人在牛逼之前,肯定有一段苦逼的岁月,但只要像傻逼一样的坚持,一定终将牛逼 |

5、商品的波段性的热点高频信息

| 1   | 内存数据库               |
| --- | ------------------------ |
| 2   | Tair、Redis、Memcache 等 |

6、商品的交易，价格计算，积分累计！

| 1   | 外部系统，外部第三方支付接口 |
| --- | ---------------------------- |
| 2   | 支付宝                       |

**大型互联网应用（大数据，高并发，多样数据类型）的难点和解决方案**

### 难点：

数据类型的多样性
数据源多样性和变化重构
数据源改造而数据服务平台不需要大面积重构
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834897312-fa5987a9-d741-4da1-8ac2-f72078c637d7.jpeg#)**解决办法：**
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834897606-d59fd719-4015-409e-9a7a-884a087207ec.jpeg#)
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834898043-76d6da22-df29-4118-b83c-41dd3e3ee842.jpeg#)

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834898376-d1d75d0a-82e8-464d-9def-376c05528c48.jpeg#)
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834898695-782c736a-b816-44d9-91e1-4b4a0b06fb02.jpeg#)

## NoSQL 数据模型简介

案例设计

以一个电商客户，订单，订购，地址模型来对比下关系型数据库和非关系型数据库

### 传统的关系型数据库你如何设计？

ER 图（1:1/1:N/N:N,主外键等常见） 用户对应多个订单多个地址
每个订单对应每个商品、价格、地址
每个商品对应产品
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834899121-6aa01674-76f1-4d37-8631-12019869ad92.jpeg#)

闲聊：用户画像分析，女人心是琢磨不透的，看了男装，剃须刀，根据她的信息找到她男朋友的生日就 在最近，后台画像已经分析完毕，准备推送广告了，结果她买了一个零食就走了~
90 后的程序员真的在一点点的改变生活中的点点滴滴，假设你有幸进入了大厂，你会发现周围的小伙伴 都在努力，真的就是那种可以在海底捞吃着吃着饭，突然就掏出笔记本写代码的那种，别人都以为他们 是疯子，只有他们自己内心才懂。这才是对技术的痴迷。

NoSQL 你如何设计
可以尝试使用**BSON**。
BSON 是一种类 json 的一种二进制形式的存储格式，简称 Binary JSON，它和 JSON 一样，支持内嵌的文档对象和数组对象
用 BSon 画出构建的数据模型

{
"customer":{
"id":1000,
"name":"Z3", "billingAddress":[{"city":"beijing"}], "orders":[
{
"id":17,
1
2
3
4
5
6
7
8

"customerId":1000, "orderItems":[{"productId":27,"price":77.5,"productName":"thinking in
java"}],
"shippingAddress":[{"city":"beijing"}]
"orderPayment":[{"ccinfo":"111-222- 333","txnid":"asdfadcd334","billingAddress":{"city":"beijing"}}],
}
]
}
}
9
10

11
12

13
14
15
16

想想关系模型数据库你如何查？如果按照我们新设计的 BSon，是不是查询起来很简单。
高并发的操作是不太建议有关联查询的，互联网公司用冗余数据来避免关联查询 分布式事务是支持不了太多的并发的

## NoSQL 四大分类

### KV 键值：

新浪：BerkeleyDB+redis 美团：redis+tair
阿里、百度：memcache+redis

### 文档型数据库(bson 格式比较多)：

CouchDB MongoDB
MongoDB 是一个**基于分布式文件存储的数据库**。由 C++ 语言编写。旨在为 WEB 应用提供可
扩展的高性能数据存储解决方案。
MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。

### 列存储数据库：

Cassandra, HBase
分布式文件系统

### 图关系数据库

它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统社交网络，推荐系统等。专注于构建关系图谱
Neo4J, InfoGrid

四者对比

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834899450-905704c4-eb7d-4275-a60b-a35970777480.jpeg#)

## CAP + BASE

传统的 ACID 分别是什么？
关系型数据库遵循 ACID 规则，事务在英文中是 transaction，和现实世界中的交易很类似，它有如下四个特性：
A (Atomicity) 原子性

| 1   | 原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务 |
| --- | ---------------------------------------------------------------------------------------- |
|     | 里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。                       |
| 2   | 比如银行转账，从 A 账户转 100 元至 B 账户，分为两个步骤：                                |
| 3   | 1）从 A 账户取 100 元；                                                                  |
| 4   | 2）存入 100 元至 B 账户。                                                                |
| 5   | 这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了 100   |
|     | 元。                                                                                     |

C (Consistency) 一致性

事务前后数据的完整性必须保持一致。
1

I (Isolation) 隔离性

所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修 改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从 A 账户转 100 元至 B 账户，在这个交易还未完成的情况下，如果此时 B 查询自己的账户，是看不到新增加 的 100 元的
1

D (Durability) 持久性

持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。
1

CAP（三进二）

C : Consistency（强一致性） A : Availability（可用性）
P : Partition tolerance（分区容错性）

### CAP 理论就是说在分布式存储系统中，最多只能实现上面的两点。

而由于当前的网络硬件肯定会出现延迟丢包等问题，所以**分区容错性是我们必须需要实现**的。 所以我们只能在一致性和可用性之间进行权衡，没有 NoSQL 系统能同时保证这三点。
注意：分布式架构的时候必须做出取舍。
一致性和可用性之间取一个平衡。多余大多数 web 应用，其实并不需要强一致性。 因此牺牲 C 换取 P，这是目前分布式数据库产品的方向

### 一致性与可用性的决择

对于 web2.0 网站来说，关系数据库的很多主要特性却往往无用武之地

### 数据库事务一致性需求

很多 web 实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不高。允许实现最终一致性。

### 数据库的写实时性和读实时性需求

对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多 web 应 用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。

### 对复杂的 SQL 查询，特别是多表关联查询的需求

任何大数据量的 web 系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特 别是 SNS 类型的网站，从需求以及产品设计角度，就避免了这种情况的产生。往往更多的只是单表的主 键查询，以及单表的简单条件分页查询，SQL 的功能被极大的弱化了。
**CAP 理论的核心**是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求， 最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：
CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。
CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。
AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834899862-30278f2c-8958-4f74-9b97-103bc00785ec.jpeg#)

BASE 理论
BASE 理论是由 eBay 架构师提出的。BASE 是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于 CAP 定律逐步演化而来。其核心思想是即使无法做到强一致性，但 每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

### BASE 就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。

BASE 其实是下面三个术语的缩写：
基本可用(Basically Available)： 基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服 务层也可能只提供降级服务。这就是损失部分可用性的体现。
软状态(Soft State)： 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用
性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的 体现。MySQL Replication 的异步复制也是一种体现。
最终一致性(Eventual Consistency)： 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。
它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么 这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这 些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里 BASE 就是解决这个问题的办法！

### 解释：

1、分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过 Rpc 通信和调用，对外 提供服务和组内协作。
2、集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供 服务和访问。

# Redis 入门

## 概述

Redis 是什么
Redis：REmote DIctionary Server（远程字典服务器）
是完全开源免费的，用 C 语言编写的，遵守 BSD 协议，是一个高性能的（Key/Value）分布式内存数据 库，基于内存运行，并支持持久化的 NoSQL 数据库，是当前最热门的 NoSQL 数据库之一，也被人们称为数据结构服务器
Redis 与其他 key-value 缓存产品有以下三个特点
Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使 用。
Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list、set、zset、hash 等数据结构的存储。
Redis 支持数据的备份，即 master-slave 模式的数据备份。
Redis 能干嘛
内存存储和持久化：redis 支持异步将内存中的数据写到硬盘上，同时不影响继续服务 取最新 N 个数据的操作，如：可以将最新的 10 条评论的 ID 放在 Redis 的 List 集合里面 发布、订阅消息系统
地图信息分析定时器、计数器
......

特性
数据类型、基本操作和配置持久化和复制，RDB、AOF 事务的控制
.....

常用网站
[https://redis.io/ ](https://redis.io/)官网
[http://www.redis.cn ](http://www.redis.cn/)中文网

## Windows 安装

下载地址：[https://github.com/dmajkic/redis/downloads ](https://github.com/dmajkic/redis/downloads)( 素材提供 )
解压到自己电脑的环境目录即可

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834900162-b88b9dbb-5255-425e-8f9f-fc0048212749.png#)

双击 redis-server.exe 启动即可
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834900387-4eb83fb0-a2dd-4b4f-b3b4-cf5eb40f51a9.png#)
通过客户端去访问

| 1   | # 基本的 set 设值                 |
| --- | --------------------------------- |
| 2   | 127.0.0.1:6379> set key kuangshen |
| 3   | OK                                |
| 4   | # 取出存储的值                    |
| 5   | 127.0.0.1:6379> get key           |
| 6   | "kuangshen"                       |

**重要提示**
redis-cli
由于企业里面做 Redis 开发，99%都是 Linux 版的运用和安装，几乎不会涉及到 Windows 版，上一步的讲解只是为了知识的完整性，Windows 版不作为重点，大家可以自己玩，企业实战就认一个版：Linux 版
[http://www.redis.cn/topics/introduction](http://www.redis.cn/topics/introduction)
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834900703-c9a6592a-b3b8-4650-a36a-5e9d5754ffcd.jpeg#)

## Linux 安装

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834901211-f6f6a1a7-23c7-41ab-8ece-e7c206376059.jpeg#)下载地址 [http://download.redis.io/releases/redis-5.0.7.tar.gz](http://download.redis.io/releases/redis-5.0.7.tar.gz)

安装步骤

1、下载获得
redis-5.0.7.tar.gz
2、/opt 目录下，解压命令 ：
后将它放到我们 Linux 的目录下 /opt

3、解压完成后出现文件夹：redis-5.0.7 4、进入目录： cd redis-5.0.7
tar -zxvf redis-5.0.7.tar.gz
5、在 redis-5.0.7 目录下执行 make 命令

运行 make 命令时故意出现的错误解析：

1. 安装 gcc (gcc 是 linux 下的一个编译程序，是 c 程序的编译工具)

能上网: yum install gcc-c++
版本测试: gcc-v

1. 二次 make

1. Jemalloc/jemalloc.h: 没有那个文件或目录运行 make distclean 之后再 make

1. Redis Test（可以不用执行）

1
2
3
4
5
6
7
8
9
10
11

6、如果 make 完成后继续执行 make install 7、查看默认安装目录：usr/local/bin
/usr 这是一个非常重要的目录，类似于 windows 下的 Program Files,存放用户的程序
1

8、拷贝配置文件（备用）

| 1   | cd /usr/local/bin                                                      |
| --- | ---------------------------------------------------------------------- |
| 2   | ls -l                                                                  |
| 3   | # 在 redis 的解压目录下备份 redis.conf                                 |
| 4   | mkdir myredis                                                          |
| 5   | cp redis.conf myredis # 拷一个备份，养成良好的习惯，我们就修改这个文件 |
| 6   | # 修改配置保证可以后台应用                                             |
| 7   | vim redis.conf                                                         |

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834901590-aa7a1dbc-ebbb-4d9e-bcd6-2656706bb349.png#)
A、redis.conf 配置文件中 daemonize 守护线程，默认是 NO。
B、daemonize 是用来指定 redis 是否要用守护线程的方式启动。

### daemonize 设置 yes 或者 no 区别

daemonize:yes
redis 采用的是单进程多线程的模式。当 redis.conf 中选项 daemonize 设置成 yes 时，代表开启守护进程模式。在该模式下，redis 会在后台运行，并将进程 pid 号写入至 redis.conf 选项 pidﬁle 设置的文件中，此时 redis 将一直运行，除非手动 kill 该进程。
daemonize:no
当 daemonize 选项设置成 no 时，当前界面将进入 redis 的命令行界面，exit 强制退出或者关闭连接工具(putty,xshell 等)都会导致 redis 进程退出。
9、启动测试一下！
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

# 【shell】启动 redis 服务

[root@192 bin]# cd /usr/local/bin
[root@192 bin]# redis-server /opt/redis-5.0.7/redis.conf

# redis 客户端连接===> 观察地址的变化，如果连接 ok,是直接连上的，redis 默认端口号 6379

[root@192 bin]# redis-cli -p 6379 127.0.0.1:6379> ping
PONG
127.0.0.1:6379> set k1 helloworld OK
127.0.0.1:6379> get k1
"helloworld"

# 【shell】ps 显示系统当前进程信息

[root@192 myredis]# ps -ef|grep redis

| 16  | root           | 16005 | 1     | 0   | 04:45 | ?     | 00:00:00 | redis-server            |
| --- | -------------- | ----- | ----- | --- | ----- | ----- | -------- | ----------------------- |
|     | 127.0.0.1:6379 |       |       |     |       |       |          |                         |
| 17  | root           | 16031 | 15692 | 0   | 04:47 | pts/0 | 00:00:00 | redis-cli -p 6379       |
| 18  | root           | 16107 | 16076 | 0   | 04:51 | pts/2 | 00:00:00 | grep --color=auto redis |
| 19  |                |       |       |     |       |       |          |                         |

| 20
21
22
23 | # 【redis】关闭连接 127.0.0.1:6379> shutdown not connected> exit | | | | | | | |

| 24  | # 【shell】ps 显示系统当前进程信息 |       |          |      |              |       |
| --- | ---------------------------------- | ----- | -------- | ---- | ------------ | ----- | --- |
| 25  | [root@192 myredis]# ps -ef         | grep  | redis    |      |              |       |     |
| 26  | root 16140 16076 0 04:53           | pts/2 | 00:00:00 | grep | --color=auto | redis |
| 27  |                                    |       |          |      |              |       |

## 基础知识说明

准备工作：开启 redis 服务，客户端连接
**redis 压力测试工具 Redis-benchmark**
Redis-benchmark 是官方自带的 Redis 性能测试工具，可以有效的测试 Redis 服务的性能。
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834902000-596cdaee-010d-4b85-bcc3-dcac8b4a30ee.png#)
redis 性能测试工具可选参数如下所示：

| **序号** | **选项**  | **描述**                                   | **默认值** |
| -------- | --------- | ------------------------------------------ | ---------- |
| 1        | **-h**    | 指定服务器主机名                           | 127.0.0.1  |
| 2        | **-p**    | 指定服务器端口                             | 6379       |
| 3        | **-s**    | 指定服务器 socket                          |            |
| 4        | **-c**    | 指定并发连接数                             | 50         |
| 5        | **-n**    | 指定请求数                                 | 10000      |
| 6        | **-d**    | 以字节的形式指定 SET/GET 值的数据大小      | 2          |
| 7        | **-k**    | 1=keep alive 0=reconnect                   | 1          |
| 8        | **-r**    | SET/GET/INCR 使用随机 key, SADD 使用随机值 |            |
| 9        | **-P**    | 通过管道传输 请求                          | 1          |
| 10       | **-q**    | 强制退出 redis。仅显示 query/sec 值        |            |
| 11       | **--csv** | 以 CSV 格式输出                            |            |
| 12       | **-l**    | 生成循环，永久执行测试                     |            |
| 13       | **-t**    | 仅运行以逗号分隔的测试命令列表。           |            |
| 14       | **-I**    | Idle 模式。仅打开 N 个 idle 连接并等待。   |            |

| 1   | # 测试一：100 个并发连接，100000 个请求，检测 host 为 localhost 端口为 6379 的 redis 服务器性 |
| --- | --------------------------------------------------------------------------------------------- |
|     | 能                                                                                            |
| 2   | redis-benchmark -h localhost -p 6379 -c 100 -n 100000                                         |
| 3   | # 测试出来的所有命令只举例一个！                                                              |
| 4   | ====== SET ======                                                                             |
| 5   | 100000 requests completed in 1.88 seconds # 对集合写入测试                                    |
| 6   | 100 parallel clients # 每次请求有 100 个并发客户端                                            |
| 7   | 3 bytes payload # 每次写入 3 个字节的数据，有效载荷                                           |
| 8   | keep alive: 1 # 保持一个连接，一台服务器来处理这些请求                                        |
| 9   |                                                                                               |
| 10  | 17.05% <= 1 milliseconds                                                                      |
| 11  | 97.35% <= 2 milliseconds                                                                      |
| 12  | 99.97% <= 3 milliseconds                                                                      |
| 13  | 100.00% <= 3 milliseconds # 所有请求在 3 毫秒内完成                                           |
| 14  | 53248.14 requests per second # 每秒处理 53248.14 次请求                                       |

基本数据库常识
默认 16 个数据库，类似数组下标从零开始，初始默认使用零号库

| 1   | 查看 redis.conf ，里面有默认的配置                                          |
| --- | --------------------------------------------------------------------------- |
| 2   | databases 16                                                                |
| 3   |                                                                             |
| 4   | # Set the number of databases. The default database is DB 0, you can select |
| 5   | # a different one on a per-connection basis using SELECT <dbid> where       |
| 6   | # dbid is a number between 0 and 'databases'-1                              |
| 7   | databases 16                                                                |
| 8   |                                                                             |

Select 命令切换数据库

| 1   | 127.0.0.1:6379> select 7   |
| --- | -------------------------- |
| 2   | OK                         |
| 3   | 127.0.0.1:6379[7]>         |
| 4   |                            |
| 5   | # 不同的库可以存不同的数据 |

Dbsize 查看当前数据库的 key 的数量

| 1   | 127.0.0.1:6379> select 7                 |
| --- | ---------------------------------------- |
| 2   | OK                                       |
| 3   | 127.0.0.1:6379[7]> DBSIZE                |
| 4   | (integer) 0                              |
| 5   | 127.0.0.1:6379[7]> select 0              |
| 6   | OK                                       |
| 7   | 127.0.0.1:6379> DBSIZE                   |
| 8   | (integer) 5                              |
| 9   | 127.0.0.1:6379> keys \* # 查看具体的 key |
| 10  | 1) "counter: rand_int "                  |
| 11  | 2) "mylist"                              |
| 12  | 3) "k1"                                  |
| 13  | 4) "myset: rand_int "                    |
| 14  | 5) "key: rand_int "                      |

Flushdb：清空当前库 Flushall：清空全部的库

| 1   | 127.0.0.1:6379> DBSIZE  |
| --- | ----------------------- |
| 2   | (integer) 5             |
| 3   | 127.0.0.1:6379> FLUSHDB |
| 4   | OK                      |
| 5   | 127.0.0.1:6379> DBSIZE  |
| 6   | (integer) 0             |

为什么默认端口是 6379？粉丝效应！

为什么 redis 是单线程
我们首先要明白，Redis 很快！官方表示，因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就 顺理成章地采用单线程的方案了！
Redis 采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由 C 语言编写，官方提供的数据是可以达到 100000+的 QPS（每秒内查询次数）。这个数据不比采用单进程多线程的同样基于内存的 KV 数据库 Memcached 差！

### Redis 为什么这么快？

1. 以前一直有个误区，以为：高性能服务器 一定是多线程来实现的

原因很简单因为误区二导致的：多线程 一定比 单线程 效率高，其实不然！ 在说这个事前希望大家都能对 CPU 、 内存 、 硬盘的速度都有了解了！

1. redis 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个 CPU 绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个 CPU 上完成的，所以它是单线程处 理这个事。在内存的情况下，这个方案就是最佳方案。

因为一次 CPU 上下文的切换大概在 1500ns 左右。从内存中读取 1MB 的连续数据，耗时大约为 250us， 假设 1MB 的数据由多个线程读取了 1000 次，那么就有 1000 次时间上下文的切换，那么就有 1500ns \* 1000 = 1500us ，我单线程的读完 1MB 数据才 250us ,你光时间上下文的切换就用了 1500us 了，我还不算你每次读一点数据 的时间。

# 五大数据类型

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834902403-e39abcf9-ca3e-4780-8817-3102cfe78a2e.png#)
官方文档

全段翻译：
Redis 是一个开放源代码（BSD 许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数 据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超日志，带有半径查询和流 的地理空间索引。Redis 具有内置的复制，Lua 脚本，LRU 驱逐，事务和不同级别的磁盘持久性，并通过 Redis Sentinel 和 Redis Cluster 自动分区提供了高可用性。

String （字符串类型）
String 是 redis 最基本的类型，你可以理解成 Memcached 一模一样的类型，一个 key 对应一个 value。String 类型是二进制安全的，意思是 redis 的 string 可以包含任何数据，比如 jpg 图片或者序列化的对象。String 类型是 redis 最基本的数据类型，一个 redis 中字符串 value 最多可以是 512M。

Hash（哈希，类似 Java 里的 Map）
Redis hash 是一个键值对集合。
Redis hash 是一个 String 类型的 ﬁeld 和 value 的映射表，hash 特别适合用于存储对象。类似 Java 里面的 Map<String,Object>
List（列表）
Redis 列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾 部（右边）。
它的底层实际是个链表 !

Set（集合）
Redis 的 Set 是 String 类型的无序集合，它是通过 HashTable 实现的 !

Zset（sorted set：有序集合）
Redis zset 和 set 一样，也是 String 类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。
Redis 正是通过分数来为集合中的成员进行从小到大的排序，zset 的成员是唯一的，但是分数（Score） 却可以重复。

## Redis 键（key）

| 1   | # keys \* 查看所有的 key                                                               |
| --- | -------------------------------------------------------------------------------------- |
| 2   | 127.0.0.1:6379> keys \*                                                                |
| 3   | (empty list or set)                                                                    |
| 4   | 127.0.0.1:6379> set name qinjiang                                                      |
| 5   | OK                                                                                     |
| 6   | 127.0.0.1:6379> keys \*                                                                |
| 7   | 1) "name"                                                                              |
| 8   |                                                                                        |
| 9   | # exists key 的名字，判断某个 key 是否存在                                             |
| 10  | 127.0.0.1:6379> EXISTS name                                                            |
| 11  | (integer) 1                                                                            |
| 12  | 127.0.0.1:6379> EXISTS name1                                                           |
| 13  | (integer) 0                                                                            |
| 14  |                                                                                        |
| 15  | # move key db ---> 当前库就没有了，被移除了                                            |
| 16  | 127.0.0.1:6379> move name 1                                                            |
| 17  | (integer) 1                                                                            |
| 18  | 127.0.0.1:6379> keys \*                                                                |
| 19  | (empty list or set)                                                                    |
| 20  |                                                                                        |
| 21  | # expire key 秒钟：为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删 |
|     | 除。                                                                                   |
| 22  | # ttl key 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期                           |
| 23  | 127.0.0.1:6379> set name qinjiang                                                      |
| 24  | OK                                                                                     |

25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
127.0.0.1:6379> EXPIRE name 10
(integer) 1
127.0.0.1:6379> ttl name
(integer) 4
127.0.0.1:6379> ttl name
(integer) 3
127.0.0.1:6379> ttl name
(integer) 2
127.0.0.1:6379> ttl name
(integer) 1
127.0.0.1:6379> ttl name
(integer) -2
127.0.0.1:6379> keys \*
(empty list or set)

# type key 查看你的 key 是什么类型

127.0.0.1:6379> set name qinjiang OK
127.0.0.1:6379> get name "qinjiang" 127.0.0.1:6379> type name
string

**字符串 String**
**单值单 Value**
常用命令说明：

| 1   | # ===================================================                         |
| --- | ----------------------------------------------------------------------------- |
| 2   | # set、get、del、append、strlen                                               |
| 3   | # ===================================================                         |
| 4   | 127.0.0.1:6379> set key1 value1 # 设置值                                      |
| 5   | OK                                                                            |
| 6   | 127.0.0.1:6379> get key1 # 获得 key                                           |
| 7   | "value1"                                                                      |
| 8   | 127.0.0.1:6379> del key1 # 删除 key                                           |
| 9   | (integer) 1                                                                   |
| 10  | 127.0.0.1:6379> keys \* # 查看全部的 key                                      |
| 11  | (empty list or set)                                                           |
| 12  | 127.0.0.1:6379> exists key1 # 确保 key1 不存在                                |
| 13  | (integer) 0                                                                   |
| 14  | 127.0.0.1:6379> append key1 "hello" # 对不存在的 key 进行 APPEND ，等同于 SET |
|     | key1 "hello"                                                                  |
| 15  | (integer) 5 # 字符长度                                                        |
| 16  | 127.0.0.1:6379> APPEND key1 "-2333" # 对已存在的字符串进行 APPEND             |
| 17  | (integer) 10 # 长度从 5 个字符增加到 10 个字符                                |
| 18  | 127.0.0.1:6379> get key1                                                      |
| 19  | "hello-2333"                                                                  |
| 20  | 127.0.0.1:6379> STRLEN key1 # # 获取字符串的长度                              |
| 21  | (integer) 10                                                                  |
| 22  |                                                                               |
| 23  | # ===================================================                         |
| 24  | # incr、decr 一定要是数字才能进行加减，+1 和 -1。                             |
| 25  | # incrby、decrby 命令将 key 中储存的数字加上指定的增量值。                    |
| 26  | # ===================================================                         |

| 27  | 127.0.0.1:6379> set views 0 # 设置浏览量为 0                                     |
| --- | -------------------------------------------------------------------------------- |
| 28  | OK                                                                               |
| 29  | 127.0.0.1:6379> incr views # 浏览 + 1                                            |
| 30  | (integer) 1                                                                      |
| 31  | 127.0.0.1:6379> incr views # 浏览 + 1                                            |
| 32  | (integer) 2                                                                      |
| 33  | 127.0.0.1:6379> decr views # 浏览 - 1                                            |
| 34  | (integer) 1                                                                      |
| 35  | 127.0.0.1:6379> incrby views 10 # +10                                            |
| 36  | (integer) 11                                                                     |
| 37  | 127.0.0.1:6379> decrby views 10 # -10                                            |
| 38  | (integer) 1                                                                      |
| 39  |                                                                                  |
| 40  | # ===================================================                            |
| 41  | # range [范围]                                                                   |
| 42  | # getrange 获取指定区间范围内的值，类似 between...and 的关系，从零到负一表示全部 |
| 43  | # ===================================================                            |
| 44  | 127.0.0.1:6379> set key2 abcd123456 # 设置 key2 的值                             |
| 45  | OK                                                                               |
| 46  | 127.0.0.1:6379> getrange key2 0 -1 # 获得全部的值                                |
| 47  | "abcd123456"                                                                     |
| 48  | 127.0.0.1:6379> getrange key2 0 2 # 截取部分字符串                               |
| 49  | "abc"                                                                            |
| 50  |                                                                                  |
| 51  | # ===================================================                            |
| 52  | # setrange 设置指定区间范围内的值，格式是 setrange key 值 具体值                 |
| 53  | # ===================================================                            |
| 54  | 127.0.0.1:6379> get key2                                                         |
| 55  | "abcd123456"                                                                     |
| 56  | 127.0.0.1:6379> SETRANGE key2 1 xx # 替换值                                      |
| 57  | (integer) 10                                                                     |
| 58  | 127.0.0.1:6379> get key2                                                         |
| 59  | "axxd123456"                                                                     |
| 60  |                                                                                  |
| 61  | # ===================================================                            |
| 62  | # setex（set with expire）键秒值                                                 |
| 63  | # setnx（set if not exist）                                                      |
| 64  | # ===================================================                            |
| 65  | 127.0.0.1:6379> setex key3 60 expire # 设置过期时间                              |
| 66  | OK                                                                               |
| 67  | 127.0.0.1:6379> ttl key3 # 查看剩余的时间                                        |
| 68  | (integer) 55                                                                     |
| 69  | 127.0.0.1:6379> setnx mykey "redis" # 如果不存在就设置，成功返回 1               |
| 70  | (integer) 1                                                                      |
| 71  | 127.0.0.1:6379> setnx mykey "mongodb" # 如果存在就设置，失败返回 0               |
| 72  | (integer) 0                                                                      |
| 73  | 127.0.0.1:6379> get mykey                                                        |
| 74  | "redis"                                                                          |
| 75  |                                                                                  |
| 76  | # ===================================================                            |
| 77  | # mset Mset 命令用于同时设置一个或多个 key-value 对。                            |
| 78  | # mget Mget 命令返回所有(一个或多个)给定 key 的值。                              |
| 79  | # 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。         |
| 80  | # msetnx 当所有 key 都成功设置，返回 1 。                                        |
| 81  | # 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。原子操      |
|     | 作                                                                               |
| 82  | # ===================================================                            |
| 83  | 127.0.0.1:6379> mset k10 v10 k11 v11 k12 v12                                     |

| 84  | OK                                                     |
| --- | ------------------------------------------------------ |
| 85  | 127.0.0.1:6379> keys \*                                |
| 86  | 1) "k12"                                               |
| 87  | 2) "k11"                                               |
| 88  | 3) "k10"                                               |
| 89  | 127.0.0.1:6379> mget k10 k11 k12 k13                   |
| 90  | 1) "v10"                                               |
| 91  | 2) "v11"                                               |
| 92  | 3) "v12"                                               |
| 93  | 4) (nil)                                               |
| 94  | 127.0.0.1:6379> msetnx k10 v10 k15 v15 # 原子性操作！  |
| 95  | (integer) 0                                            |
| 96  | 127.0.0.1:6379> get key15                              |
| 97  | (nil)                                                  |
| 98  |                                                        |
| 99  | # 传统对象缓存                                         |
| 100 | set user:1 value(json 数据)                            |
| 101 |                                                        |
| 102 | # 可以用来缓存对象                                     |
| 103 | mset user:1:name zhangsan user:1:age 2                 |
| 104 | mget user:1:name user:1:age                            |
| 105 |                                                        |
| 106 | # ===================================================  |
| 107 | # getset（先 get 再 set）                              |
| 108 | # ===================================================  |
| 109 | 127.0.0.1:6379> getset db mongodb # 没有旧值，返回 nil |
| 110 | (nil)                                                  |
| 111 | 127.0.0.1:6379> get db                                 |
| 112 | "mongodb"                                              |
| 113 | 127.0.0.1:6379> getset db redis # 返回旧值 mongodb     |
| 114 | "mongodb"                                              |
| 115 | 127.0.0.1:6379> get db                                 |
| 116 | "redis"                                                |

String 数据结构是简单的 key-value 类型，value 其实不仅可以是 String，也可以是数字。常规 key-value 缓存应用：
常规计数：微博数，粉丝数等。

## 列表 List

**单值多 Value**

| 1   | # ===================================================                                    |
| --- | ---------------------------------------------------------------------------------------- |
| 2   | # Lpush：将一个或多个值插入到列表头部。（左）                                            |
| 3   | # rpush：将一个或多个值插入到列表尾部。（右）                                            |
| 4   | # lrange：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。                   |
| 5   | # 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。                       |
| 6   | # 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此 |
|     | 类推。                                                                                   |
| 7   | # ===================================================                                    |
| 8   | 127.0.0.1:6379> LPUSH list "one"                                                         |
| 9   | (integer) 1                                                                              |
| 10  | 127.0.0.1:6379> LPUSH list "two"                                                         |
| 11  | (integer) 2                                                                              |

| 12  | 127.0.0.1:6379> RPUSH list "right"                                                     |
| --- | -------------------------------------------------------------------------------------- |
| 13  | (integer) 3                                                                            |
| 14  | 127.0.0.1:6379> Lrange list 0 -1                                                       |
| 15  | 1) "two"                                                                               |
| 16  | 2) "one"                                                                               |
| 17  | 3) "right"                                                                             |
| 18  | 127.0.0.1:6379> Lrange list 0 1                                                        |
| 19  | 1) "two"                                                                               |
| 20  | 2) "one"                                                                               |
| 21  |                                                                                        |
| 22  | # ===================================================                                  |
| 23  | # lpop 命令用于移除并返回列表的第一个元素。当列表 key 不存在时，返回 nil 。            |
| 24  | # rpop 移除列表的最后一个元素，返回值为移除的元素。                                    |
| 25  | # ===================================================                                  |
| 26  | 127.0.0.1:6379> Lpop list                                                              |
| 27  | "two"                                                                                  |
| 28  | 127.0.0.1:6379> Rpop list                                                              |
| 29  | "right"                                                                                |
| 30  | 127.0.0.1:6379> Lrange list 0 -1                                                       |
| 31  | 1) "one"                                                                               |
| 32  |                                                                                        |
| 33  | # ===================================================                                  |
| 34  | # Lindex，按照索引下标获得元素（-1 代表最后一个，0 代表是第一个）                      |
| 35  | # ===================================================                                  |
| 36  | 127.0.0.1:6379> Lindex list 1                                                          |
| 37  | (nil)                                                                                  |
| 38  | 127.0.0.1:6379> Lindex list 0                                                          |
| 39  | "one"                                                                                  |
| 40  | 127.0.0.1:6379> Lindex list -1                                                         |
| 41  | "one"                                                                                  |
| 42  |                                                                                        |
| 43  | # ===================================================                                  |
| 44  | # llen 用于返回列表的长度。                                                            |
| 45  | # ===================================================                                  |
| 46  | 127.0.0.1:6379> flushdb                                                                |
| 47  | OK                                                                                     |
| 48  | 127.0.0.1:6379> Lpush list "one"                                                       |
| 49  | (integer) 1                                                                            |
| 50  | 127.0.0.1:6379> Lpush list "two"                                                       |
| 51  | (integer) 2                                                                            |
| 52  | 127.0.0.1:6379> Lpush list "three"                                                     |
| 53  | (integer) 3                                                                            |
| 54  | 127.0.0.1:6379> Llen list # 返回列表的长度                                             |
| 55  | (integer) 3                                                                            |
| 56  |                                                                                        |
| 57  | # ===================================================                                  |
| 58  | # lrem key 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。                    |
| 59  | # ===================================================                                  |
| 60  | 127.0.0.1:6379> lrem list 1 "two"                                                      |
| 61  | (integer) 1                                                                            |
| 62  | 127.0.0.1:6379> Lrange list 0 -1                                                       |
| 63  | 1) "three"                                                                             |
| 64  | 2) "one"                                                                               |
| 65  |                                                                                        |
| 66  | # ===================================================                                  |
| 67  | # Ltrim key 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区 |
|     | 间之内的元素都将被删除。                                                               |
| 68  | # ===================================================                                  |

| 69  | 127.0.0.1:6379> RPUSH mylist "hello"                                      |
| --- | ------------------------------------------------------------------------- |
| 70  | (integer) 1                                                               |
| 71  | 127.0.0.1:6379> RPUSH mylist "hello"                                      |
| 72  | (integer) 2                                                               |
| 73  | 127.0.0.1:6379> RPUSH mylist "hello2"                                     |
| 74  | (integer) 3                                                               |
| 75  | 127.0.0.1:6379> RPUSH mylist "hello3"                                     |
| 76  | (integer) 4                                                               |
| 77  | 127.0.0.1:6379> ltrim mylist 1 2                                          |
| 78  | OK                                                                        |
| 79  | 127.0.0.1:6379> lrange mylist 0 -1                                        |
| 80  | 1) "hello"                                                                |
| 81  | 2) "hello2"                                                               |
| 82  |                                                                           |
| 83  | # ===================================================                     |
| 84  | # rpoplpush 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。    |
| 85  | # ===================================================                     |
| 86  | 127.0.0.1:6379> rpush mylist "hello"                                      |
| 87  | (integer) 1                                                               |
| 88  | 127.0.0.1:6379> rpush mylist "foo"                                        |
| 89  | (integer) 2                                                               |
| 90  | 127.0.0.1:6379> rpush mylist "bar"                                        |
| 91  | (integer) 3                                                               |
| 92  | 127.0.0.1:6379> rpoplpush mylist myotherlist                              |
| 93  | "bar"                                                                     |
| 94  | 127.0.0.1:6379> lrange mylist 0 -1                                        |
| 95  | 1) "hello"                                                                |
| 96  | 2) "foo"                                                                  |
| 97  | 127.0.0.1:6379> lrange myotherlist 0 -1                                   |
| 98  | 1) "bar"                                                                  |
| 99  |                                                                           |
| 100 | # ===================================================                     |
| 101 | # lset key index value 将列表 key 下标为 index 的元素的值设置为 value 。  |
| 102 | # ===================================================                     |
| 103 | 127.0.0.1:6379> exists list # 对空列表(key 不存在)进行 LSET               |
| 104 | (integer) 0                                                               |
| 105 | 127.0.0.1:6379> lset list 0 item # 报错                                   |
| 106 | (error) ERR no such key                                                   |
| 107 |                                                                           |
| 108 | 127.0.0.1:6379> lpush list "value1" # 对非空列表进行 LSET                 |
| 109 | (integer) 1                                                               |
| 110 | 127.0.0.1:6379> lrange list 0 0                                           |
| 111 | 1) "value1"                                                               |
| 112 | 127.0.0.1:6379> lset list 0 "new" # 更新值                                |
| 113 | OK                                                                        |
| 114 | 127.0.0.1:6379> lrange list 0 0                                           |
| 115 | 1) "new"                                                                  |
| 116 | 127.0.0.1:6379> lset list 1 "new" # index 超出范围报错                    |
| 117 | (error) ERR index out of range                                            |
| 118 |                                                                           |
| 119 | # ===================================================                     |
| 120 | # linsert key before/after pivot value 用于在列表的元素前或者后插入元素。 |
| 121 | # 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。               |
| 122 | # ===================================================                     |
| 123 | redis> RPUSH mylist "Hello"                                               |
| 124 | (integer) 1                                                               |
| 125 | redis> RPUSH mylist "World"                                               |
| 126 | (integer) 2                                                               |

| 127 | redis> LINSERT mylist BEFORE "World" "There" |
| --- | -------------------------------------------- |
| 128 | (integer) 3                                  |
| 129 | redis> LRANGE mylist 0 -1                    |
| 130 | 1) "Hello"                                   |
| 131 | 2) "There"                                   |
| 132 | 3) "World"                                   |

性能总结
它是一个字符串链表，left，right 都可以插入添加如果键不存在，创建新的链表
如果键已存在，新增内容
如果值全移除，对应的键也就消失了
链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。
list 就是链表，略有数据结构知识的人都应该能理解其结构。使用 Lists 结构，我们可以轻松地实现最新消 息排行等功能。List 的另一个应用就是消息队列，可以利用 List 的 PUSH 操作，将任务存在 List 中，然后工作线程再用 POP 操作将任务取出进行执行。Redis 还提供了操作 List 中某一段的 api，你可以直接查询，删除 List 中某一段的元素。
Redis 的 list 是每个子元素都是 String 类型的双向链表，可以通过 push 和 pop 操作从列表的头部或者尾部添加或者删除元素，这样 List 即可以作为栈，也可以作为队列。

## 集合 Set

**单值多 value**

| 1   | # =================================================== |
| --- | ----------------------------------------------------- |
| 2   | # sadd 将一个或多个成员元素加入到集合中，不能重复     |
| 3   | # smembers 返回集合中的所有的成员。                   |
| 4   | # sismember 命令判断成员元素是否是集合的成员。        |
| 5   | # =================================================== |
| 6   | 127.0.0.1:6379> sadd myset "hello"                    |
| 7   | (integer) 1                                           |
| 8   | 127.0.0.1:6379> sadd myset "kuangshen"                |
| 9   | (integer) 1                                           |
| 10  | 127.0.0.1:6379> sadd myset "kuangshen"                |
| 11  | (integer) 0                                           |
| 12  | 127.0.0.1:6379> SMEMBERS myset                        |
| 13  | 1) "kuangshen"                                        |
| 14  | 2) "hello"                                            |
| 15  | 127.0.0.1:6379> SISMEMBER myset "hello"               |
| 16  | (integer) 1                                           |
| 17  | 127.0.0.1:6379> SISMEMBER myset "world"               |
| 18  | (integer) 0                                           |
| 19  |                                                       |
| 20  | # =================================================== |
| 21  | # scard，获取集合里面的元素个数                       |
| 22  | # =================================================== |
| 23  | 127.0.0.1:6379> scard myset                           |
| 24  | (integer) 2                                           |
| 25  |                                                       |
| 26  | # =================================================== |
| 27  | # srem key value 用于移除集合中的一个或多个成员元素   |
| 28  | # =================================================== |
| 29  | 127.0.0.1:6379> srem myset "kuangshen"                |
| 30  | (integer) 1                                           |

| 31  | 127.0.0.1:6379> SMEMBERS myset                                  |
| --- | --------------------------------------------------------------- |
| 32  | 1) "hello"                                                      |
| 33  |                                                                 |
| 34  | # ===================================================           |
| 35  | # srandmember key 命令用于返回集合中的一个随机元素。            |
| 36  | # ===================================================           |
| 37  | 127.0.0.1:6379> SMEMBERS myset                                  |
| 38  | 1) "kuangshen"                                                  |
| 39  | 2) "world"                                                      |
| 40  | 3) "hello"                                                      |
| 41  | 127.0.0.1:6379> SRANDMEMBER myset                               |
| 42  | "hello"                                                         |
| 43  | 127.0.0.1:6379> SRANDMEMBER myset 2                             |
| 44  | 1) "world"                                                      |
| 45  | 2) "kuangshen"                                                  |
| 46  | 127.0.0.1:6379> SRANDMEMBER myset 2                             |
| 47  | 1) "kuangshen"                                                  |
| 48  | 2) "hello"                                                      |
| 49  |                                                                 |
| 50  | # ===================================================           |
| 51  | # spop key 用于移除集合中的指定 key 的一个或多个随机元素        |
| 52  | # ===================================================           |
| 53  | 127.0.0.1:6379> SMEMBERS myset                                  |
| 54  | 1) "kuangshen"                                                  |
| 55  | 2) "world"                                                      |
| 56  | 3) "hello"                                                      |
| 57  | 127.0.0.1:6379> spop myset                                      |
| 58  | "world"                                                         |
| 59  | 127.0.0.1:6379> spop myset                                      |
| 60  | "kuangshen"                                                     |
| 61  | 127.0.0.1:6379> spop myset                                      |
| 62  | "hello"                                                         |
| 63  |                                                                 |
| 64  | # ===================================================           |
| 65  | # smove SOURCE DESTINATION MEMBER                               |
| 66  | # 将指定成员 member 元素从 source 集合移动到 destination 集合。 |
| 67  | # ===================================================           |
| 68  | 127.0.0.1:6379> sadd myset "hello"                              |
| 69  | (integer) 1                                                     |
| 70  | 127.0.0.1:6379> sadd myset "world"                              |
| 71  | (integer) 1                                                     |
| 72  | 127.0.0.1:6379> sadd myset "kuangshen"                          |
| 73  | (integer) 1                                                     |
| 74  | 127.0.0.1:6379> sadd myset2 "set2"                              |
| 75  | (integer) 1                                                     |
| 76  | 127.0.0.1:6379> smove myset myset2 "kuangshen"                  |
| 77  | (integer) 1                                                     |
| 78  | 127.0.0.1:6379> SMEMBERS myset                                  |
| 79  | 1) "world"                                                      |
| 80  | 2) "hello"                                                      |
| 81  | 127.0.0.1:6379> SMEMBERS myset2                                 |
| 82  | 1) "kuangshen"                                                  |
| 83  | 2) "set2"                                                       |
| 84  |                                                                 |
| 85  | # ===================================================           |
| 86  | - 数字集合类                                                    |
| 87  | - 差集： sdiff                                                  |
| 88  | - 交集： sinter                                                 |

| 89  | - 并集： sunion                                       |
| --- | ----------------------------------------------------- |
| 90  | # =================================================== |
| 91  | 127.0.0.1:6379> sadd key1 "a"                         |
| 92  | (integer) 1                                           |
| 93  | 127.0.0.1:6379> sadd key1 "b"                         |
| 94  | (integer) 1                                           |
| 95  | 127.0.0.1:6379> sadd key1 "c"                         |
| 96  | (integer) 1                                           |
| 97  | 127.0.0.1:6379> sadd key2 "c"                         |
| 98  | (integer) 1                                           |
| 99  | 127.0.0.1:6379> sadd key2 "d"                         |
| 100 | (integer) 1                                           |
| 101 | 127.0.0.1:6379> sadd key2 "e"                         |
| 102 | (integer) 1                                           |
| 103 | 127.0.0.1:6379> SDIFF key1 key2 # 差集                |
| 104 | 1) "a"                                                |
| 105 | 2) "b"                                                |
| 106 | 127.0.0.1:6379> SINTER key1 key2 # 交集               |
| 107 | 1) "c"                                                |
| 108 | 127.0.0.1:6379> SUNION key1 key2 # 并集               |
| 109 | 1) "a"                                                |
| 110 | 2) "b"                                                |
| 111 | 3) "c"                                                |
| 112 | 4) "e"                                                |
| 113 | 5) "d"                                                |

在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 还为 集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功
能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集 合中。

## 哈希 Hash

**kv 模式不变，但 V 是一个键值对**

| 1   | # ===================================================                                |
| --- | ------------------------------------------------------------------------------------ |
| 2   | # hset、hget 命令用于为哈希表中的字段赋值 。                                         |
| 3   | # hmset、hmget 同时将多个 field-value 对设置到哈希表中。会覆盖哈希表中已存在的字段。 |
| 4   | # hgetall 用于返回哈希表中，所有的字段和值。                                         |
| 5   | # hdel 用于删除哈希表 key 中的一个或多个指定字段                                     |
| 6   | # ===================================================                                |
| 7   | 127.0.0.1:6379> hset myhash field1 "kuangshen"                                       |
| 8   | (integer) 1                                                                          |
| 9   | 127.0.0.1:6379> hget myhash field1                                                   |
| 10  | "kuangshen"                                                                          |
| 11  | 127.0.0.1:6379> HMSET myhash field1 "Hello" field2 "World"                           |
| 12  | OK                                                                                   |
| 13  | 127.0.0.1:6379> HGET myhash field1                                                   |
| 14  | "Hello"                                                                              |
| 15  | 127.0.0.1:6379> HGET myhash field2                                                   |
| 16  | "World"                                                                              |
| 17  | 127.0.0.1:6379> hgetall myhash                                                       |
| 18  | 1) "field1"                                                                          |
| 19  | 2) "Hello"                                                                           |
| 20  | 3) "field2"                                                                          |

| 21  | 4) "World"                                                 |
| --- | ---------------------------------------------------------- |
| 22  | 127.0.0.1:6379> HDEL myhash field1                         |
| 23  | (integer) 1                                                |
| 24  | 127.0.0.1:6379> hgetall myhash                             |
| 25  | 1) "field2"                                                |
| 26  | 2) "World"                                                 |
| 27  |                                                            |
| 28  | # ===================================================      |
| 29  | # hlen 获取哈希表中字段的数量。                            |
| 30  | # ===================================================      |
| 31  | 127.0.0.1:6379> hlen myhash                                |
| 32  | (integer) 1                                                |
| 33  | 127.0.0.1:6379> HMSET myhash field1 "Hello" field2 "World" |
| 34  | OK                                                         |
| 35  | 127.0.0.1:6379> hlen myhash                                |
| 36  | (integer) 2                                                |
| 37  |                                                            |
| 38  | # ===================================================      |
| 39  | # hexists 查看哈希表的指定字段是否存在。                   |
| 40  | # ===================================================      |
| 41  | 127.0.0.1:6379> hexists myhash field1                      |
| 42  | (integer) 1                                                |
| 43  | 127.0.0.1:6379> hexists myhash field3                      |
| 44  | (integer) 0                                                |
| 45  |                                                            |
| 46  | # ===================================================      |
| 47  | # hkeys 获取哈希表中的所有域（field）。                    |
| 48  | # hvals 返回哈希表所有域(field)的值。                      |
| 49  | # ===================================================      |
| 50  | 127.0.0.1:6379> HKEYS myhash                               |
| 51  | 1) "field2"                                                |
| 52  | 2) "field1"                                                |
| 53  | 127.0.0.1:6379> HVALS myhash                               |
| 54  | 1) "World"                                                 |
| 55  | 2) "Hello"                                                 |
| 56  |                                                            |
| 57  | # ===================================================      |
| 58  | # hincrby 为哈希表中的字段值加上指定增量值。               |
| 59  | # ===================================================      |
| 60  | 127.0.0.1:6379> hset myhash field 5                        |
| 61  | (integer) 1                                                |
| 62  | 127.0.0.1:6379> HINCRBY myhash field 1                     |
| 63  | (integer) 6                                                |
| 64  | 127.0.0.1:6379> HINCRBY myhash field -1                    |
| 65  | (integer) 5                                                |
| 66  | 127.0.0.1:6379> HINCRBY myhash field -10                   |
| 67  | (integer) -5                                               |
| 68  |                                                            |
| 69  | # ===================================================      |
| 70  | # hsetnx 为哈希表中不存在的的字段赋值 。                   |
| 71  | # ===================================================      |
| 72  | 127.0.0.1:6379> HSETNX myhash field1 "hello"               |
| 73  | (integer) 1 # 设置成功，返回 1 。                          |
| 74  | 127.0.0.1:6379> HSETNX myhash field1 "world"               |
| 75  | (integer) 0 # 如果给定字段已经存在，返回 0 。              |
| 76  | 127.0.0.1:6379> HGET myhash field1                         |
| 77  | "hello"                                                    |

Redis hash 是一个 string 类型的 ﬁeld 和 value 的映射表，hash 特别适合用于存储对象。存储部分变更的数据，如用户信息等。

## 有序集合 Zset

在 set 基础上，加一个 score 值。之前 set 是 k1 v1 v2 v3，现在 zset 是 k1 score1 v1 score2 v2

| 1   | # ===================================================                                  |
| --- | -------------------------------------------------------------------------------------- |
| 2   | # zadd 将一个或多个成员元素及其分数值加入到有序集当中。                                |
| 3   | # zrange 返回有序集中，指定区间内的成员                                                |
| 4   | # ===================================================                                  |
| 5   | 127.0.0.1:6379> zadd myset 1 "one"                                                     |
| 6   | (integer) 1                                                                            |
| 7   | 127.0.0.1:6379> zadd myset 2 "two" 3 "three"                                           |
| 8   | (integer) 2                                                                            |
| 9   | 127.0.0.1:6379> ZRANGE myset 0 -1                                                      |
| 10  | 1) "one"                                                                               |
| 11  | 2) "two"                                                                               |
| 12  | 3) "three"                                                                             |
| 13  |                                                                                        |
| 14  | # ===================================================                                  |
| 15  | # zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大) |
|     | 次序排列。                                                                             |
| 16  | # ===================================================                                  |
| 17  | 127.0.0.1:6379> zadd salary 2500 xiaoming                                              |
| 18  | (integer) 1                                                                            |
| 19  | 127.0.0.1:6379> zadd salary 5000 xiaohong                                              |
| 20  | (integer) 1                                                                            |
| 21  | 127.0.0.1:6379> zadd salary 500 kuangshen                                              |
| 22  | (integer) 1                                                                            |
| 23  | # Inf 无穷大量+∞,同样地,-∞ 可以表示为-Inf。                                            |
| 24  | 127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf # 显示整个有序集                        |
| 25  | 1) "kuangshen"                                                                         |
| 26  | 2) "xiaoming"                                                                          |
| 27  | 3) "xiaohong"                                                                          |
| 28  | 127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf withscores # 递增排列                   |
| 29  | 1) "kuangshen"                                                                         |
| 30  | 2) "500"                                                                               |
| 31  | 3) "xiaoming"                                                                          |
| 32  | 4) "2500"                                                                              |
| 33  | 5) "xiaohong"                                                                          |
| 34  | 6) "5000"                                                                              |
| 35  | 127.0.0.1:6379> ZREVRANGE salary 0 -1 WITHSCORES # 递减排列                            |
| 36  | 1) "xiaohong"                                                                          |
| 37  | 2) "5000"                                                                              |
| 38  | 3) "xiaoming"                                                                          |
| 39  | 4) "2500"                                                                              |
| 40  | 5) "kuangshen"                                                                         |
| 41  | 6) "500"                                                                               |
| 42  | 127.0.0.1:6379> ZRANGEBYSCORE salary -inf 2500 WITHSCORES # 显示工资 <=2500            |
|     | 的所有成员                                                                             |
| 43  | 1) "kuangshen"                                                                         |
| 44  | 2) "500"                                                                               |
| 45  | 3) "xiaoming"                                                                          |
| 46  | 4) "2500"                                                                              |
| 47  |                                                                                        |

| 48  |                                                                                    |
| --- | ---------------------------------------------------------------------------------- |
| 49  | # ===================================================                              |
| 50  | # zrem 移除有序集中的一个或多个成员                                                |
| 51  | # ===================================================                              |
| 52  | 127.0.0.1:6379> ZRANGE salary 0 -1                                                 |
| 53  | 1) "kuangshen"                                                                     |
| 54  | 2) "xiaoming"                                                                      |
| 55  | 3) "xiaohong"                                                                      |
| 56  | 127.0.0.1:6379> zrem salary kuangshen                                              |
| 57  | (integer) 1                                                                        |
| 58  | 127.0.0.1:6379> ZRANGE salary 0 -1                                                 |
| 59  | 1) "xiaoming"                                                                      |
| 60  | 2) "xiaohong"                                                                      |
| 61  |                                                                                    |
| 62  | # ===================================================                              |
| 63  | # zcard 命令用于计算集合中元素的数量。                                             |
| 64  | # ===================================================                              |
| 65  | 127.0.0.1:6379> zcard salary                                                       |
| 66  | (integer) 2                                                                        |
| 67  | OK                                                                                 |
| 68  |                                                                                    |
| 69  | # ===================================================                              |
| 70  | # zcount 计算有序集合中指定分数区间的成员数量。                                    |
| 71  | # ===================================================                              |
| 72  | 127.0.0.1:6379> zadd myset 1 "hello"                                               |
| 73  | (integer) 1                                                                        |
| 74  | 127.0.0.1:6379> zadd myset 2 "world" 3 "kuangshen"                                 |
| 75  | (integer) 2                                                                        |
| 76  | 127.0.0.1:6379> ZCOUNT myset 1 3                                                   |
| 77  | (integer) 3                                                                        |
| 78  | 127.0.0.1:6379> ZCOUNT myset 1 2                                                   |
| 79  | (integer) 2                                                                        |
| 80  |                                                                                    |
| 81  | # ===================================================                              |
| 82  | # zrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。 |
| 83  | # ===================================================                              |
| 84  | 127.0.0.1:6379> zadd salary 2500 xiaoming                                          |
| 85  | (integer) 1                                                                        |
| 86  | 127.0.0.1:6379> zadd salary 5000 xiaohong                                          |
| 87  | (integer) 1                                                                        |
| 88  | 127.0.0.1:6379> zadd salary 500 kuangshen                                          |
| 89  | (integer) 1                                                                        |
| 90  | 127.0.0.1:6379> ZRANGE salary 0 -1 WITHSCORES # 显示所有成员及其 score 值          |
| 91  | 1) "kuangshen"                                                                     |
| 92  | 2) "500"                                                                           |
| 93  | 3) "xiaoming"                                                                      |
| 94  | 4) "2500"                                                                          |
| 95  | 5) "xiaohong"                                                                      |
| 96  | 6) "5000"                                                                          |
| 97  | 127.0.0.1:6379> zrank salary kuangshen # 显示 kuangshen 的薪水排名，最少           |
| 98  | (integer) 0                                                                        |
| 99  | 127.0.0.1:6379> zrank salary xiaohong # 显示 xiaohong 的薪水排名，第三             |
| 100 | (integer) 2                                                                        |
| 101 |                                                                                    |
| 102 | # ===================================================                              |
| 103 | # zrevrank 返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。      |
| 104 | # ===================================================                              |
| 105 | 127.0.0.1:6379> ZREVRANK salary kuangshen # 狂神第三                               |

| 106 | (integer) 2     |          |        |          |     |          |
| --- | --------------- | -------- | ------ | -------- | --- | -------- |
| 107 | 127.0.0.1:6379> | ZREVRANK | salary | xiaohong | #   | 小红第一 |
| 108 | (integer) 0     |          |        |          |     |          |

和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，比如一个存储全班同学成绩的 sorted set，其集合 value 可以是同学的学号，而 score 就可以是其考试得分， 这样在数据插入集合的时候，就已经进行了天然的排序。可以用 sorted set 来做带权重的队列，比如普通消息的 score 为 1，重要消息的 score 为 2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。
排行榜应用，取 TOP N 操作 ！

# 三种特殊数据类型

## GEO 地理位置

简介
Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。geo 的数据类型为 zset。
GEO 的数据结构总共有六个常用命令：geoadd、geopos、geodist、georadius、
georadiusbymember、gethash
官方文档：[https://www.redis.net.cn/order/3685.html](https://www.redis.net.cn/order/3685.html)

geoadd
解析：

| 1   | # 语法                                                                                       |
| --- | -------------------------------------------------------------------------------------------- |
| 2   | geoadd key longitude latitude member ...                                                     |
| 3   |                                                                                              |
| 4   | # 将给定的空间元素(纬度、经度、名字)添加到指定的键里面。                                     |
| 5   | # 这些数据会以有序集 he 的形式被储存在键里面，从而使得 georadius 和 georadiusbymember 这样的 |
|     | 命令可以在之后通过位置查询取得这些元素。                                                     |
| 6   | # geoadd 命令以标准的 x,y 格式接受参数,所以用户必须先输入经度,然后再输入纬度。               |
| 7   | # geoadd 能够记录的坐标是有限的:非常接近两极的区域无法被索引。                               |
| 8   | # 有效的经度介于-180-180 度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间。，      |
|     | 当用户尝试输入一个超出范围的经度或者纬度时,geoadd 命令将返回一个错误。                       |

测试：百度搜索经纬度查询，模拟真实数据

| 1   | 127.0.0.1:6379> geoadd china:city 116.23 40.22 北京                          |
| --- | ---------------------------------------------------------------------------- |
| 2   | (integer) 1                                                                  |
| 3   | 127.0.0.1:6379> geoadd china:city 121.48 31.40 上海 113.88 22.55 深圳 120.21 |
|     | 30.20 杭州                                                                   |
| 4   | (integer) 3                                                                  |
| 5   | 127.0.0.1:6379> geoadd china:city 106.54 29.40 重庆 108.93 34.23 西安 114.02 |
|     | 30.58 武汉                                                                   |
| 6   | (integer) 3                                                                  |

geopos
解析：

| 1   | # 语法                                             |
| --- | -------------------------------------------------- |
| 2   | geopos key member [member...]                      |
| 3   |                                                    |
| 4   | #从 key 里返回所有给定位置元素的位置（经度和纬度） |

测试：

| 1   | 127.0.0.1:6379> geopos china:city | 北京 |      |
| --- | --------------------------------- | ---- | ---- |
| 2   | 1) 1) "116.23000055551528931"     |      |      |
| 3   | 2) "40.2200010338739844"          |      |      |
| 4   | 127.0.0.1:6379> geopos china:city | 上海 | 重庆 |
| 5   | 1) 1) "121.48000091314315796"     |      |      |
| 6   | 2) "31.40000025319353938"         |      |      |
| 7   | 2) 1) "106.54000014066696167"     |      |      |
| 8   | 2) "29.39999880018641676"         |      |      |
| 9   | 127.0.0.1:6379> geopos china:city | 新疆 |      |
| 10  | 1) (nil)                          |      |      |

geodist
解析：

| 1   | # 语法                                                                                   |
| --- | ---------------------------------------------------------------------------------------- |
| 2   | geodist key member1 member2 [unit]                                                       |
| 3   |                                                                                          |
| 4   | # 返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在,那么命令返回空值。        |
| 5   | # 指定单位的参数 unit 必须是以下单位的其中一个：                                         |
| 6   | # m 表示单位为米                                                                         |
| 7   | # km 表示单位为千米                                                                      |
| 8   | # mi 表示单位为英里                                                                      |
| 9   | # ft 表示单位为英尺                                                                      |
| 10  | # 如果用户没有显式地指定单位参数,那么 geodist 默认使用米作为单位。                       |
| 11  | #geodist 命令在计算距离时会假设地球为完美的球形,在极限情况下,这一假设最大会造成 0.5%的误 |
|     | 差。                                                                                     |

测试：

| 1   | 127.0.0.1:6379> geodist china:city 北京 上海    |
| --- | ----------------------------------------------- |
| 2   | "1088785.4302"                                  |
| 3   | 127.0.0.1:6379> geodist china:city 北京 上海 km |
| 4   | "1088.7854"                                     |
| 5   | 127.0.0.1:6379> geodist china:city 重庆 北京 km |
| 6   | "1491.6716"                                     |

georadius

解析：

| 1   | # 语法                                        |
| --- | --------------------------------------------- | ------------------ | --- | ------------------------ |
| 2   | georadius key longitude latitude radius m     | km                 | ft  | mi [withcoord][withdist] |
|     | [withhash]asc                                 | desc][count count] |
| 3   |                                               |
| 4   | # 以给定的经纬度为中心， 找出某一半径内的元素 |

测试：重新连接 redis-cli，增加参数 --raw ，可以强制输出中文，不然会乱码

| 1   | [root@kuangshen bin]# redis-cli --raw -p 6379                                |
| --- | ---------------------------------------------------------------------------- |
| 2   | # 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市                       |
| 3   | 127.0.0.1:6379> georadius china:city 100 30 1000 km                          |
| 4   | 重庆                                                                         |
| 5   | 西安                                                                         |
| 6   |                                                                              |
| 7   | # withdist 返回位置名称和中心距离                                            |
| 8   | 127.0.0.1:6379> georadius china:city 100 30 1000 km withdist                 |
| 9   | 重庆                                                                         |
| 10  | 635.2850                                                                     |
| 11  | 西安                                                                         |
| 12  | 963.3171                                                                     |
| 13  |                                                                              |
| 14  | # withcoord 返回位置名称和经纬度                                             |
| 15  | 127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord                |
| 16  | 重庆                                                                         |
| 17  | 106.54000014066696167                                                        |
| 18  | 29.39999880018641676                                                         |
| 19  | 西安                                                                         |
| 20  | 108.92999857664108276                                                        |
| 21  | 34.23000121926852302                                                         |
| 22  |                                                                              |
| 23  | # withdist withcoord 返回位置名称 距离 和经纬度 count 限定寻找个数           |
| 24  | 127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord withdist count |
|     | 1                                                                            |
| 25  | 重庆                                                                         |
| 26  | 635.2850                                                                     |
| 27  | 106.54000014066696167                                                        |
| 28  | 29.39999880018641676                                                         |
| 29  | 127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord withdist count |
|     | 2                                                                            |
| 30  | 重庆                                                                         |
| 31  | 635.2850                                                                     |
| 32  | 106.54000014066696167                                                        |
| 33  | 29.39999880018641676                                                         |
| 34  | 西安                                                                         |
| 35  | 963.3171                                                                     |
| 36  | 108.92999857664108276                                                        |
| 37  | 34.23000121926852302                                                         |

georadiusbymember
解析：

| 1   | # 语法                                                   |
| --- | -------------------------------------------------------- | ------------------ | --- | ------------------------ |
| 2   | georadiusbymember key member radius m                    | km                 | ft  | mi [withcoord][withdist] |
|     | [withhash]asc                                            | desc][count count] |
| 3   |                                                          |
| 4   | # 找出位于指定范围内的元素，中心点是由给定的位置元素决定 |

测试：

| 1   | 127.0.0.1:6379> GEORADIUSBYMEMBER china:city 北京 1000 km |
| --- | --------------------------------------------------------- |
| 2   | 北京                                                      |
| 3   | 西安                                                      |
| 4   | 127.0.0.1:6379> GEORADIUSBYMEMBER china:city 上海 400 km  |
| 5   | 杭州                                                      |
| 6   | 上海                                                      |

geohash
解析：

| 1   | # 语法                                                                                       |
| --- | -------------------------------------------------------------------------------------------- |
| 2   | geohash key member [member...]                                                               |
| 3   |                                                                                              |
| 4   | # Redis 使用 geohash 将二维经纬度转换为一维字符串，字符串越长表示位置更精确,两个字符串越相似 |
|     | 表示距离越近。                                                                               |

测试：

| 1   | 127.0.0.1:6379> geohash china:city 北京 重庆 |
| --- | -------------------------------------------- |
| 2   | wx4sucu47r0                                  |
| 3   | wm5z22h53v0                                  |
| 4   | 127.0.0.1:6379> geohash china:city 北京 上海 |
| 5   | wx4sucu47r0                                  |
| 6   | wtw6sk5n300                                  |

zrem
GEO 没有提供删除成员的命令，但是因为 GEO 的底层实现是 zset，所以可以借用 zrem 命令实现对地理位置信息的删除.

| 1   | 127.0.0.1:6379> geoadd china:city 116.23 40.22 beijin   |
| --- | ------------------------------------------------------- |
| 2   | 1                                                       |
| 3   | 127.0.0.1:6379> zrange china:city 0 -1 # 查看全部的元素 |
| 4   | 重庆                                                    |
| 5   | 西安                                                    |
| 6   | 深圳                                                    |
| 7   | 武汉                                                    |
| 8   | 杭州                                                    |
| 9   | 上海                                                    |
| 10  | beijin                                                  |
| 11  | 北京                                                    |
| 12  | 127.0.0.1:6379> zrem china:city beijin # 移除元素       |
| 13  | 1                                                       |

| 14  | 127.0.0.1:6379> zrem china:city 北京   | # 移除元素 |
| --- | -------------------------------------- | ---------- |
| 15  | 1                                      |            |
| 16  | 127.0.0.1:6379> zrange china:city 0 -1 |            |
| 17  | 重庆                                   |            |
| 18  | 西安                                   |            |
| 19  | 深圳                                   |            |
| 20  | 武汉                                   |            |
| 21  | 杭州                                   |            |
| 22  | 上海                                   |            |

## HyperLogLog

简介
Redis 在 2.8.9 版本添加了 HyperLogLog 结构。
Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。
在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。
HyperLogLog 则是一种算法，它提供了不精确的去重计数方案。
举个栗子：假如我要统计网页的 UV（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的 解决方案是使用 Set 来保存用户 id，然后统计 Set 中的元素数量来获取页面 UV。但这种方案只能承载少量 用户，一旦用户数量大起来就需要消耗大量的空间来存储用户 id。我的目的是统计用户数量而不是保存 用户，这简直是个吃力不讨好的方案！而使用 Redis 的 HyperLogLog 最多需要 12k 就可以统计大量的用户数，尽管它大概有 0.81%的错误率，但对于统计 UV 这种不需要很精确的数据是可以忽略不计的。
什么是基数？
比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为 5。基数估计就是在误差可接受的范围内，快速计算基数。

基本命令

| **命令**                                   | **描述**                                            |
| ------------------------------------------ | --------------------------------------------------- |
| [PFADD key element [element ...]           | 添加指定元素到 HyperLogLog 中。                     |
| [PFCOUNT key [key ...]                     | 返回给定 HyperLogLog 的基数估算值。                 |
| [PFMERGE destkey sourcekey [sourcekey ...] | 将多个 HyperLogLog 合并为一个 HyperLogLog，并集计算 |

测试

| 1   | 127.0.0.1:6379> PFADD mykey a b c d e f g h i j |
| --- | ----------------------------------------------- |
| 2   | 1                                               |
| 3   | 127.0.0.1:6379> PFCOUNT mykey                   |
| 4   | 10                                              |
| 5   | 127.0.0.1:6379> PFADD mykey2 i j z x c v b n m  |
| 6   | 1                                               |
| 7   | 127.0.0.1:6379> PFMERGE mykey3 mykey mykey2     |
| 8   | OK                                              |
| 9   | 127.0.0.1:6379> PFCOUNT mykey3                  |
| 10  | 15                                              |

## BitMap

简介
在开发中，可能会遇到这种情况：需要统计用户的某些信息，如活跃或不活跃，登录或者不登录；又如 需要记录用户一年的打卡情况，打卡了是 1， 没有打卡是 0，如果使用普通的 key/value 存储，则要记录 365 条记录，如果用户量很大，需要的空间也会很大，所以 Redis 提供了 Bitmap 位图这中数据结构， Bitmap 就是通过操作二进制位来进行记录，即为 0 和 1；如果要记录 365 天的打卡情况，使用 Bitmap 表示的形式大概如下：0101000111000111. ，这样有什么好处呢？当然就是节约内存
了，365 天相当于 365 bit，又 1 字节 = 8 bit , 所以相当于使用 46 个字节即可。
BitMap 就是通过一个 bit 位来表示某个元素对应的值或者状态, 其中的 key 就是对应元素本身，实际上底层也是通过对字符串的操作来实现。Redis 从 2.2 版本之后新增了 setbit, getbit, bitcount 等几个 bitmap 相关命令。
setbit 设置操作
SETBIT key oﬀset value : 设置 key 的第 oﬀset 位为 value (1 或 0)

| 1   | # 使用 bitmap 来记录上述事例中一周的打卡记录如下所示：                                   |
| --- | ---------------------------------------------------------------------------------------- |
| 2   | # 周一：1，周二：0，周三：0，周四：1，周五：1，周六：0，周天：0 （1 为打卡，0 为不打卡） |
| 3   | 127.0.0.1:6379> setbit sign 0 1                                                          |
| 4   | 0                                                                                        |
| 5   | 127.0.0.1:6379> setbit sign 1 0                                                          |
| 6   | 0                                                                                        |
| 7   | 127.0.0.1:6379> setbit sign 2 0                                                          |
| 8   | 0                                                                                        |
| 9   | 127.0.0.1:6379> setbit sign 3 1                                                          |
| 10  | 0                                                                                        |
| 11  | 127.0.0.1:6379> setbit sign 4 1                                                          |
| 12  | 0                                                                                        |
| 13  | 127.0.0.1:6379> setbit sign 5 0                                                          |
| 14  | 0                                                                                        |
| 15  | 127.0.0.1:6379> setbit sign 6 0                                                          |
| 16  | 0                                                                                        |

getbit 获取操作
GETBIT key oﬀset 获取 oﬀset 设置的值，未设置过默认返回 0

| 1   | 127.0.0.1:6379> getbit sign 3 | # 查看周四是否打卡 |
| --- | ----------------------------- | ------------------ |
| 2   | 1                             |                    |
| 3   | 127.0.0.1:6379> getbit sign 6 | # 查看周七是否打卡 |
| 4   | 0                             |                    |

bitcount 统计操作
bitcount key [start, end] 统计 key 上位为 1 的个数

| 1   | # 统计这周打卡的记录，可以看到只有 3 天是打卡的状态： |
| --- | ----------------------------------------------------- |
| 2   | 127.0.0.1:6379> bitcount sign                         |
| 3   | 3                                                     |

# Redis.conf

## 熟悉基本配置

位置
Redis 的配置文件位于 Redis 安装目录下，文件名为 **redis.conf**

| 1   | config | get | \*  | #   | 获取全部的配置 |
| --- | ------ | --- | --- | --- | -------------- |

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834902914-91bab427-d7b6-4877-8bf9-3c67c7713922.png#)配置文件的地址：
我们一般情况下，会单独拷贝出来一份进行操作。来保证初始文件的安全。

Units 单位

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834903303-435fc664-78a4-4f1f-b64b-54d61af83940.png#)

1、配置大小单位，开头定义了一些基本的度量单位，只支持 bytes，不支持 bit
2、对 大小写 不敏感
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834903631-8e0eccb3-d9a3-4a41-8e55-c6f2127bc667.png#)
INCLUDES 包含

和 Spring 配置文件类似，可以通过 includes 包含，redis.conf 可以作为总文件，可以包含其他文件！

NETWORK 网络配置

| 1   | bind 127.0.0.1 |     | #   | 绑定的 ip |
| --- | -------------- | --- | --- | --------- |
| 2   | protected-mode | yes | #   | 保护模式  |
| 3   | port 6379      |     | #   | 默认端口  |

GENERAL 通用
daemonize yes # 默认情况下，Redis 不作为守护进程运行。需要开启的话，改为 yes supervised no # 可通过 upstart 和 systemd 管理 Redis 守护进程
pidfile /var/run/redis_6379.pid # 以后台进程方式运行 redis，则需要指定 pid 文件

loglevel notice # 日志级别。可选项有：

# debug（记录大量日志信息，适用于开发、测试阶段）； # verbose（较多日志信息）；

1
2
3
4
5
6
7
8
9

| 10  | # notice（适量日志信息，使用于生产环境）；                  |
| --- | ----------------------------------------------------------- |
| 11  | # warning（仅有部分重要、关键信息才会被记录）。             |
| 12  |                                                             |
| 13  | logfile "" # 日志文件的位置，当指定为空字符串时，为标准输出 |
| 14  | databases 16 # 设置数据库的数目。默认的数据库是 DB 0        |
| 15  | always-show-logo yes # 是否总是显示 logo                    |

SNAPSHOPTING 快照

| 1   | # 900 秒（15 分钟）内至少 1 个 key 值改变（则进行数据库保存--持久化）               |
| --- | ----------------------------------------------------------------------------------- |
| 2   | save 900 1                                                                          |
| 3   | # 300 秒（5 分钟）内至少 10 个 key 值改变（则进行数据库保存--持久化）               |
| 4   | save 300 10                                                                         |
| 5   | # 60 秒（1 分钟）内至少 10000 个 key 值改变（则进行数据库保存--持久化）             |
| 6   | save 60 10000                                                                       |
| 7   |                                                                                     |
| 8   | stop-writes-on-bgsave-error yes # 持久化出现错误后，是否依然进行继续进行工作        |
| 9   |                                                                                     |
| 10  | rdbcompression yes # 使用压缩 rdb 文件 yes：压缩，但是需要一些 cpu 的消耗。no：不压 |
|     | 缩，需要更多的磁盘空间                                                              |
| 11  |                                                                                     |
| 12  | rdbchecksum yes # 是否校验 rdb 文件，更有利于文件的容错性，但是在保存 rdb 文件的时  |
|     | 候，会有大概 10%的性能损耗                                                          |
| 13  |                                                                                     |
| 14  | dbfilename dump.rdb # dbfilenamerdb 文件名称                                        |
| 15  |                                                                                     |
| 16  | dir ./ # dir 数据目录，数据库的写入会在这个目录。rdb、aof 文件也会写在这个目录      |

REPLICATION 复制 我们后面讲主从复制再给大家讲解！这里先跳过！
SECURITY 安全

访问密码的查看，设置和取消

| 1   | # 启动 redis                    |
| --- | ------------------------------- |
| 2   | # 连接客户端                    |
| 3   |                                 |
| 4   | # 获得和设置密码                |
| 5   | config get requirepass          |
| 6   | config set requirepass "123456" |
| 7   |                                 |
| 8   | #测试 ping，发现需要验证        |
| 9   | 127.0.0.1:6379> ping            |
| 10  | NOAUTH Authentication required. |
| 11  | # 验证                          |
| 12  | 127.0.0.1:6379> auth 123456     |
| 13  | OK                              |
| 14  | 127.0.0.1:6379> ping            |
| 15  | PONG                            |

限制

| 1   | maxclients 10000 # 设置能连上 redis 的最大客户端连接数量              |
| --- | --------------------------------------------------------------------- |
| 2   |                                                                       |
| 3   | maxmemory <bytes> # redis 配置的最大内存容量                          |
| 4   |                                                                       |
| 5   | maxmemory-policy noeviction # maxmemory-policy 内存达到上限的处理策略 |
| 6   | #volatile-lru：利用 LRU 算法移除设置过过期时间的 key。                |
| 7   | #volatile-random：随机移除设置过过期时间的 key。                      |
| 8   | #volatile-ttl：移除即将过期的 key，根据最近过期时间来删除（辅以 TTL） |
| 9   | #allkeys-lru：利用 LRU 算法移除任何 key。                             |
| 10  | #allkeys-random：随机移除任何 key。                                   |
| 11  | #noeviction：不移除任何 key，只是返回一个写错误。                     |

append only 模式

| 1   | appendonly no # 是否以 append only 模式作为持久化方式，默认使用的是 rdb 方式持久化，这种 |
| --- | ---------------------------------------------------------------------------------------- |
|     | 方式在许多应用中已经足够用了                                                             |
| 2   |                                                                                          |
| 3   | appendfilename "appendonly.aof" # appendfilename AOF 文件名称                            |
| 4   |                                                                                          |
| 5   | appendfsync everysec # appendfsync aof 持久化策略的配置                                  |
| 6   | # no 表示不执行 fsync，由操作系统保证数据同步到磁盘，速度最快。                          |
| 7   | # always 表示每次写入都执行 fsync，以保证数据同步到磁盘。                                |
| 8   | # everysec 表示每秒执行一次 fsync，可能会导致丢失这 1s 数据。                            |

具体的我们会在后面讲解 Redis 的持久化配置的时候进行讲解！先了解下，听个耳音！

## 常见配置介绍

1、Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程

daemonize no
2、当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入/var/run/redis.pid 文件，可以通过 pidﬁle 指 定

pidﬁle /var/run/redis.pid
3、指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字

port 6379
4、绑定的主机地址

bind 127.0.0.1

5、当 客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能
timeout 300
6、指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 verbose

loglevel verbose
7、日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方 式为标准输出，则日志将会发送给/dev/null

logﬁle stdout
8、设置数据库的数量，默认数据库为 0，可以使用 SELECT 命令在连接上指定数据库 id

databases 16
9、指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合

save
Redis 默认配置文件中提供了三个条件： save 900 1
save 300 10
save 60 10000
分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。
10、指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大

rdbcompression yes
11、指定本地数据库文件名，默认值为 dump.rdb

dbﬁlename dump.rdb
12、指定本地数据库存放目录

dir ./
13、设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master
进行数据同步

slaveof
14、当 master 服务设置了密码保护时，slav 服务连接 master 的密码

masterauth

15、设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH 命令提供密码， 默认关闭
requirepass foobared
16、设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可 以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时， Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息

maxclients 128
17、指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作， 但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区
maxmemory
18、指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不 开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no

appendonly no
19、指定更新日志文件名，默认为 appendonly.aof

appendﬁlename appendonly.aof
20、指定更新日志条件，共有 3 个可选值：

no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用 fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值）
appendfsync everysec
21、指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将 访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔 细分析 Redis 的 VM 机制）
vm-enabled no
22、虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个 Redis 实例共享

vm-swap-ﬁle /tmp/redis.swap
23、将所有大于 vm-max-memory 的数据存入虚拟内存,无论 vm-max-memory 设置多小,所有索引数据 都是内存存储的(Redis 的索引数据 就是 keys),也就是说,当 vm-max-memory 设置为 0 的时候,其实是所有 value 都存在于磁盘。默认值为 0

vm-max-memory 0

24、Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不 确定，就使用默认值
vm-page-size 32
25、设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。

vm-pages 134217728
26、设置访问 swap 文件的线程数,最好不要超过机器的核数,如果设置为 0,那么所有对 swap 文件的操作都 是串行的，可能会造成比较长时间的延迟。默认值为 4

vm-max-threads 4
27、设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启

glueoutputbuf yes
28、指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法

hash-max-zipmap-entries 64
hash-max-zipmap-value 512
29、指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）

activerehashing yes
30、指定包含其它的配置文件，可以在同一主机上多个 Redis 实例之间使用同一份配置文件，而同时各 个实例又拥有自己的特定配置文件

include /path/to/local.conf

# Redis 的持久化

Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！

## RDB（Redis DataBase）

什么是 RDB
在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的 Snapshot 快照，它恢复时是将快 照文件直接读到内存里。

Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程 都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何 IO 操作的。 这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。RDB 的缺点是最后一次持久化后的数据可能丢失。

Fork
Fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量，环境变量，程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。

### ![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834904046-ebe78088-9605-4ae3-964d-44715b310681.png#)![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834904353-be7793e0-77df-4c59-ad14-6d08c0081698.png#)Rdb 保存的是 dump.rdb 文件

配置位置及 SNAPSHOTTING 解析

这里的触发条件机制，我们可以修改测试一下：

| 1   | save | 120 | 10  | #   | 120 秒内修改 10 次则触发 RDB |
| --- | ---- | --- | --- | --- | ---------------------------- |

RDB 是整合内存的压缩过的 Snapshot，RDB 的数据结构，可以配置复合的快照触发条件。默认：

1 分钟内改了 1 万次
5 分钟内改了 10 次
15 分钟内改了 1 次
如果想禁用 RDB 持久化的策略，只要不设置任何 save 指令，或者给 save 传入一个空字符串参数也可以。 若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效 !

其余命令解析
Stop-writes-on-bgsave-error：如果配置为 no，表示你不在乎数据不一致或者有其他的手段发现和控 制，默认为 yes。
rbdcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis 会采用 LZF 算法进行压缩，如果你不想消耗 CPU 来进行压缩的话，可以设置为关闭此功能。
rdbchecksum：在存储快照后，还可以让 redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。默认为 yes。

如何触发 RDB 快照
1、配置文件中默认的快照配置，建议多用一台机子作为备份，复制一份 dump.rdb 2、命令 save 或者是 bgsave
save 时只管保存，其他不管，全部阻塞
bgsave，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过 lastsave 命令获取最后一次成功执行快照的时间。
3、执行 ﬂushall 命令，也会产生 dump.rdb 文件，但里面是空的，无意义 ! 4、退出的时候也会产生 dump.rdb 文件！

如何恢复
1、将备份文件（dump.rdb）移动到 redis 安装目录并启动服务即可 2、CONFIG GET dir 获取目录

| 1   | 127.0.0.1:6379> config get dir |
| --- | ------------------------------ |
| 2   | dir                            |
| 3   | /usr/local/bin                 |

优点和缺点

### 优点：

1、适合大规模的数据恢复
2、对数据完整性和一致性要求不高

### 缺点：

1、在一定间隔时间做一次备份，所以如果 redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改
2、Fork 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834904608-4b5531a9-08d4-40e7-8d92-f39283fc489b.jpeg#)
小结

## AOF（Append Only File）

是什么
以日志的形式来记录每个写操作，将 Redis 执行过的所有指令记录下来（读操作不记录），只许追加文件 但不可以改写文件，redis 启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件 的内容将写指令从前到后执行一次以完成数据的恢复工作
Aof 保存的是 appendonly.aof 文件

配置

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834904881-169725be-0463-47cb-9d24-6624742f68e8.png#)

appendonly no # 是否以 append only 模式作为持久化方式，默认使用的是 rdb 方式持久化，这种方式在许多应用中已经足够用了

appendfilename "appendonly.aof" # appendfilename AOF 文件名称

appendfsync everysec # appendfsync aof 持久化策略的配置

# no 表示不执行 fsync，由操作系统保证数据同步到磁盘，速度最快。# always 表示每次写入都执行 fsync，以保证数据同步到磁盘。

# everysec 表示每秒执行一次 fsync，可能会导致丢失这 1s 数据。

No-appendfsync-on-rewrite #重写时是否可以运用 Appendfsync，用默认 no 即可，保证数据安全性

Auto-aof-rewrite-min-size # 设置重写的基准值

Auto-aof-rewrite-percentage #设置重写的基准值
1

2
3
4
5
6
7
8
9
10

11
12
13
14
AOF 启动/修复/恢复

正常恢复：
启动：设置 Yes，修改默认的 appendonly no，改为 yes
将有数据的 aof 文件复制一份保存到对应目录（conﬁg get dir） 恢复：重启 redis 然后重新加载
异常恢复：
启动：设置 Yes
故意破坏 appendonly.aof 文件！

修复：
redis-check-aof --fix appendonly.aof
恢复：重启 redis 然后重新加载
进行修复

Rewrite

### 是什么：

AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 bgrewriteaof ！

### 重写原理：

AOF 文件持续增长而过大时，会 fork 出一条新进程来将文件重写（也是先写临时文件最后再 rename），遍历新进程的内存中数据，每条记录有一条的 Set 语句。重写 aof 文件的操作，并没有读取旧 的 aof 文件，这点和快照有点类似！

### 触发机制：

Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次 rewrite 后大小的已被且文件大于 64M 的触发。
行家一出手，就只有没有，内行看门道，外行看热闹

优点和缺点

### 优点：

1、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好
2、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失
3、不同步： appendfsync no 从不同步

### 缺点：

1、相同数据集的数据而言，aof 文件要远大于 rdb 文件，恢复速度慢于 rdb。
2、Aof 运行效率要慢于 rdb，每秒同步策略效率较好，不同步效率和 rdb 相同。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834905201-13146fe7-e9e8-49ae-a056-8eaa7952c0f4.jpeg#)
小总结

## 总结

1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储
2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以 Redis 协议追加保存每次写的操作到文件末尾，Redis 还能对 AOF 文件进行后台重写，使得 AOF 文件的体积不至于过大。
3、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化
4、同时开启两种持久化方式
在这种情况下，当 redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。
RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件，那要不要只使用 AOF 呢？作者建议不要，因为 RDB 更适合用于备份数据库（AOF 在不断变化不好备份），快速重启，而且不会有 AOF 可能潜在的 Bug，留着作为一个万一的手段。
5、性能建议
因为 RDB 文件只用作后备用途，建议只在 Slave 上持久化 RDB 文件，而且只要 15 分钟备份一次就够了，只保留 save 900 1 这条规则。
如果 Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只 load 自己的 AOF 文件就可以了，代价一是带来了持续的 IO，二是 AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少 AOF rewrite 的频率，AOF 重写的基础大小默认值 64M 太小了，可以设到 5G 以上，默认超过原大小 100%大小重 写可以改到适当的数值。
如果不 Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔 IO，也减少了 rewrite 时带来的系统波动。代价是如果 Master/Slave 同时倒掉，会丢失十几分钟的数据， 启动脚本也要比较两个 Master/Slave 中的 RDB 文件，载入较新的那个，微博就是这种架构。

# Redis 事务

## 理论

### Redis 事务的概念：

Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事 务执行命令序列中。
总结说：redis 事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

### Redis 事务没有隔离级别的概念：

批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行！

### Redis 不保证原子性：

Redis 中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其 余的命令仍会被执行。

### Redis 事务的三个阶段：

开始事务命令入队执行事务
**Redis 事务相关命令：**

| 1   | watch key1 key2 ... #监视一或多个 key,如果在事务执行之前，被监视的 key 被其他命令改动，则 |
| --- | ----------------------------------------------------------------------------------------- |
|     | 事务被打断 （ 类似乐观锁 ）                                                               |
| 2   | multi # 标记一个事务块的开始（ queued ）                                                  |
| 3   | exec # 执行所有事务块的命令 （ 一旦执行 exec 后，之前加的监控锁都会被取消掉 ）            |
| 4   | discard # 取消事务，放弃事务块中的所有命令                                                |
| 5   | unwatch # 取消 watch 对所有 key 的监控                                                    |

## ![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834905466-02d981b2-e9ec-4ebb-904e-8c25f612053f.png#)![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834905796-dd4a375d-9514-421c-a954-3285c3c0725c.png#)实践

正常执行
放弃事务
若在事务队列中存在命令性错误（类似于 java 编译性错误），则执行 EXEC 命令时，所有命令都不会 执行

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834906206-cccab9c5-0bb3-40bc-81c6-371e860158f8.png#)![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834906699-8ec3dec1-0631-4fb7-be41-4c2da9498498.png#)
若在事务队列中存在语法性错误（类似于 java 的 1/0 的运行时异常），则执行 EXEC 命令时，其他正确 命令会被执行，错误命令抛出异常。
Watch 监控

### 悲观锁：

悲观锁(Pessimistic Lock),顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿到这个数据就会 block 直到它拿到锁。传统的关系型数据库里面就 用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在操作之前先上锁。

### 乐观锁：

乐观锁(Optimistic Lock),顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下再此期间别人有没有去更新这个数据，可以使用版本号等机制，乐 观锁适用于多读的应用类型，这样可以提高吞吐量，乐观锁策略：提交版本必须大于记录当前版本才能 执行更新。

### 测试：

1、初始化信用卡可用余额和欠额

| 1   | 127.0.0.1:6379> set balance 100 |
| --- | ------------------------------- |
| 2   | OK                              |
| 3   | 127.0.0.1:6379> set debt 0      |
| 4   | OK                              |

2、使用 watch 检测 balance，事务期间 balance 数据未变动，事务执行成功

| 1   | 127.0.0.1:6379> watch balance     |
| --- | --------------------------------- |
| 2   | OK                                |
| 3   | 127.0.0.1:6379> MULTI             |
| 4   | OK                                |
| 5   | 127.0.0.1:6379> decrby balance 20 |
| 6   | QUEUED                            |
| 7   | 127.0.0.1:6379> incrby debt 20    |
| 8   | QUEUED                            |
| 9   | 127.0.0.1:6379> exec              |
| 10  | 1) (integer) 80                   |
| 11  | 2) (integer) 20                   |

3、使用 watch 检测 balance，事务期间 balance 数据变动，事务执行失败！

| 1   | # 窗口一                                               |
| --- | ------------------------------------------------------ |
| 2   | 127.0.0.1:6379> watch balance                          |
| 3   | OK                                                     |
| 4   | 127.0.0.1:6379> MULTI # 执行完毕后，执行窗口二代码测试 |
| 5   | OK                                                     |
| 6   | 127.0.0.1:6379> decrby balance 20                      |
| 7   | QUEUED                                                 |
| 8   | 127.0.0.1:6379> incrby debt 20                         |
| 9   | QUEUED                                                 |
| 10  | 127.0.0.1:6379> exec # 修改失败！                      |
| 11  | (nil)                                                  |
| 12  |                                                        |
| 13  | # 窗口二                                               |
| 14  | 127.0.0.1:6379> get balance                            |
| 15  | "80"                                                   |
| 16  | 127.0.0.1:6379> set balance 200                        |
| 17  | OK                                                     |
| 18  |                                                        |
| 19  | # 窗口一：出现问题后放弃监视，然后重来！               |
| 20  | 127.0.0.1:6379> UNWATCH # 放弃监视                     |
| 21  | OK                                                     |
| 22  | 127.0.0.1:6379> watch balance                          |
| 23  | OK                                                     |
| 24  | 127.0.0.1:6379> MULTI                                  |
| 25  | OK                                                     |
| 26  | 127.0.0.1:6379> decrby balance 20                      |
| 27  | QUEUED                                                 |
| 28  | 127.0.0.1:6379> incrby debt 20                         |

| 29  | QUEUED               |          |
| --- | -------------------- | -------- |
| 30  | 127.0.0.1:6379> exec | # 成功！ |
| 31  | 1) (integer) 180     |          |
| 32  | 2) (integer) 40      |          |

说明：
一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。故当事务执行失败后，需重新执行 WATCH 命令对变量进行监控，并开启新的事务进行操作。

## 小结

watch 指令类似于乐观锁，在事务提交时，如果 watch 监控的多个 KEY 中任何 KEY 的值已经被其他客户端更改，则使用 EXEC 执行事务时，事务队列将不会被执行，同时返回 Nullmulti-bulk 应答以通知调用者事务执行失败。

# Redis 发布订阅

是什么
Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。
Redis 客户端可以订阅任意数量的频道。订阅/发布消息图：
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834907145-7d98f17f-f9be-4041-a853-4eb81c8a6bc6.jpeg#)
下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834907472-0676eef6-7f96-4389-87c2-1501b9e4b85b.png#)

当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834907757-c72917b5-139a-4ad5-acad-33818ed09d25.png#)

命令
这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834908055-4e5c3887-4131-4150-a4ce-bc5d15ca9dcb.jpeg#)

测试
以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 **redisChat**:

| 1   | redis 127.0.0.1:6379> SUBSCRIBE redisChat  |
| --- | ------------------------------------------ |
| 2   |                                            |
| 3   | Reading messages... (press Ctrl-C to quit) |
| 4   | 1) "subscribe"                             |
| 5   | 2) "redisChat"                             |
| 6   | 3) (integer) 1                             |

现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。

| 1   | redis 127.0.0.1:6379> PUBLISH  | redisChat | "Hello,Redis"      |
| --- | ------------------------------ | --------- | ------------------ |
| 2   | (integer) 1                    |           |                    |
| 3   | redis 127.0.0.1:6379> PUBLISH  | redisChat | "Hello，Kuangshen" |
| 4   | (integer) 1                    |           |                    |
| 5   |                                |           |                    |
| 6   | # 订阅者的客户端会显示如下消息 |           |                    |
| 7   | 1) "message"                   |           |                    |
| 8   | 2) "redisChat"                 |           |                    |
| 9   | 3) "Hello,Redis"               |           |                    |
| 10  | 1) "message"                   |           |                    |
| 11  | 2) "redisChat"                 |           |                    |
| 12  | 3) "Hello，Kuangshen"          |           |                    |

原理
Redis 是使用 C 实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。
Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。
通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel
，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。
通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel
字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。
Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在 Redis 中，你可以设定对某一个 key 值进行消息发布及消息订阅，当一个 key 值上进行了消息发布后，所有订阅它的客户端都会收到相应 的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。
使用场景
Pub/Sub 构建实时消息系统
Redis 的 Pub/Sub 系统可以构建实时的消息系统
比如很多用 Pub/Sub 构建的实时聊天系统的例子。

# Redis 主从复制

## 概念

主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。Master 以写为主，Slave 以读为主。
默认情况下，每台 Redis 服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从 节点只能有一个主节点。
主从复制的作用主要包括：
1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。

2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务 的冗余。
3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务
（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写 少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。
4、高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础。

一般来说，要将 Redis 运用于工程项目中，只使用一台 Redis 是万万不能的，原因如下：
1、从结构上，单个 Redis 服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较 大；
2、从容量上，单个 Redis 服务器内存容量有限，就算一台 Redis 服务器内存容量为 256G，也不能将所有内存用作 Redis 存储内存，一般来说，单台 Redis 最大使用内存不应该超过 20G。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834908371-79e7ff56-728e-473b-a4b1-05e60ee97f05.jpeg#)电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是"多读少写"。 对于这种场景，我们可以使如下这种架构：

## 环境配置

基本配置
配从库不配主库，从库配置：

| 1   | slaveof 主库 ip 主库端口 # 配置主从 |
| --- | ----------------------------------- |
| 2   | Info replication # 查看信息         |

每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件！

修改配置文件！
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834908758-9a6e90b4-fdcd-40b7-b0e1-7bb24af1d80a.png#)准备工作：我们配置主从复制，至少需要三个，一主二从！配置三个客户端！
1、拷贝多个 redis.conf 文件
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834909252-ec99feed-672a-43c5-aba8-a9d6afdfcd4e.png#)

2、指定端口 6379，依次类推 3、开启 daemonize yes
4、Pid 文件名字
pidfile /var/run/redis_6379.pid
5、Log 文件名字
logfile "6379.log"

, 依次类推

, 依次类推

6、Dump.rdb 名字 , 依次类推
dbfilename dump6379.rdb
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834909646-c6e91269-bfeb-4b73-9ceb-18eba978e949.png#)
上面都配置完毕后，3 个服务通过 3 个不同的配置文件开启，我们的准备环境就 OK 了！
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834909885-d9b72f3a-0ad0-4926-a3b9-4dc6ae63b874.png#)

## 一主二从

一主二仆
1、环境初始化

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834910302-0eae1a95-97cf-4ee9-bd38-6d87e4d8a4c2.png#)

默认三个都是 Master 主节点
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834910635-461fc5fc-1433-4db2-8155-237111f44f8f.jpeg#)
2、配置为一个 Master 两个 Slave
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834911049-6abc1420-5c12-4857-9e06-bee965d9c41e.jpeg#)

3、在主机设置值，在从机都可以取到！从机不能写值！
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834911392-19c6a5bd-1e72-4105-91f4-1acbbd519c8f.jpeg#)
测试一：主机挂了，查看从机信息，主机恢复，再次查看信息测试二：从机挂了，查看主机信息，从机恢复，查看从机信息

层层链路
上一个 Slave 可以是下一个 slave 和 Master，Slave 同样可以接收其他 slaves 的连接和同步请求，那么该 slave 作为了链条中下一个的 master，可以有效减轻 master 的写压力！
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834911913-a3515aec-3c13-47c4-a006-b6791a376de5.png#)![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834912282-d90afdfe-a568-42f9-9935-048266cbe36e.jpeg#)

测试：6379 设置值以后 6380 和 6381 都可以获取到！OK！

谋朝篡位
一主二从的情况下，如果主机断了，从机可以使用命令 将自己改为主机！这个时
SLAVEOF NO ONE
候其余的从机链接到这个节点。对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834912573-1629f6ff-3ef8-42a2-b2c6-4c83f41ec71b.png#)
主机再回来，也只是一个光杆司令了，从机为了正常使用跑到了新的主机上！

复制原理
Slave 启动成功连接到 master 后会发送一个 sync 命令
Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master 将传送整个数据文件到 slave，并完成一次完全同步。
全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave，完成同步但是只要是重新连接 master，一次完全同步（全量复制）将被自动执行

## 哨兵模式

概述
主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工 干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑 哨兵模式。Redis 从 2.8 开始正式提供了 Sentinel（哨兵） 架构来解决这个问题。
谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。
哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独 立运行。其原理是**哨兵通过发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例。**
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834912807-83555a01-3f30-4d3d-af8c-5a464547c353.png#)

这里的哨兵有两个作用
通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器。
当哨兵监测到 master 宕机，会自动将 slave 切换成 master，然后通过**发布订阅模式**通知其他的从服务器，修改配置文件，让它们切换主机。
然而一个哨兵进程对 Redis 服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。 各个哨兵之间还会进行监控，这样就形成了多哨兵模式。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834913161-3b011792-9a90-43fc-bd74-8dd4c44c06cb.jpeg#)
假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵 1 主观的认 为主服务器不可用，这个现象成为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一 定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover[故障转移]操作。 切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为 **客观下线**。

配置测试
1、调整结构，6379 带着 80、81
2、自定义的 /myredis 目录下新建 sentinel.conf 文件，名字千万不要错
3、配置哨兵，填写内容

sentinel monitor 被监控主机名字 127.0.0.1 6379 1
上面最后一个数字 1，表示主机挂掉后 slave 投票看让谁接替成为主机，得票数多少后成为主机
4、启动哨兵
Redis-sentinel /myredis/sentinel.conf
上述目录依照各自的实际情况配置，可能目录不同
5、正常主从演示
6、原有的 Master 挂了
7、投票新选
8、重新主从继续开工，info replication 查查看
9、问题：如果之前的 master 重启回来，会不会双 master 冲突？ 之前的回来只能做小弟了

哨兵模式的优缺点

### 优点

1.  哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。
1.  主从可以切换，故障可以转移，系统可用性更好。
1.  哨兵模式是主从模式的升级，系统更健壮，可用性更高。

### 缺点

1. Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。
1. 实现哨兵模式的配置也不简单，甚至可以说有些繁琐

哨兵配置说明

| 1   | # Example sentinel.conf                                                                    |
| --- | ------------------------------------------------------------------------------------------ |
| 2   |                                                                                            |
| 3   | # 哨兵 sentinel 实例运行的端口 默认 26379                                                  |
| 4   | port 26379                                                                                 |
| 5   |                                                                                            |
| 6   | # 哨兵 sentinel 的工作目录                                                                 |
| 7   | dir /tmp                                                                                   |
| 8   |                                                                                            |
| 9   | # 哨兵 sentinel 监控的 redis 主节点的 ip port                                              |
| 10  | # master-name 可以自己命名的主节点名字 只能由字母 A-z、数字 0-9 、这三个字符".-\_"组成。   |
| 11  | # quorum 配置多少个 sentinel 哨兵统一认为 master 主节点失联 那么这时客观上认为主节点失联了 |
| 12  | # sentinel monitor <master-name> <ip> <redis-port> <quorum>                                |
| 13  | sentinel monitor mymaster 127.0.0.1 6379 2                                                 |
| 14  |                                                                                            |

| 15  | # 当在 Redis 实例中开启了 requirepass foobared 授权密码 这样所有连接 Redis 实例的客户端都    |
| --- | -------------------------------------------------------------------------------------------- |
|     | 要提供密码                                                                                   |
| 16  | # 设置哨兵 sentinel 连接主从的密码 注意必须为主从设置一样的验证密码                          |
| 17  | # sentinel auth-pass <master-name> <password>                                                |
| 18  | sentinel auth-pass mymaster MySUPER--secret-0123passw0rd                                     |
| 19  |                                                                                              |
| 20  | # 指定多少毫秒之后 主节点没有应答哨兵 sentinel 此时 哨兵主观上认为主节点下线 默认 30 秒      |
| 21  | # sentinel down-after-milliseconds <master-name> <milliseconds>                              |
| 22  | sentinel down-after-milliseconds mymaster 30000                                              |
| 23  |                                                                                              |
| 24  | # 这个配置项指定了在发生 failover 主备切换时最多可以有多少个 slave 同时对新的 master 进行 同 |
|     | 步，                                                                                         |
| 25  | 这个数字越小，完成 failover 所需的时间就越长，                                               |
| 26  | 但是如果这个数字越大，就意味着越 多的 slave 因为 replication 而不可用。                      |
| 27  | 可以通过将这个值设为 1 来保证每次只有一个 slave 处于不能处理命令请求的状态。                 |
| 28  | # sentinel parallel-syncs <master-name> <numslaves>                                          |
| 29  | sentinel parallel-syncs mymaster 1                                                           |
| 30  |                                                                                              |
| 31  | # 故障转移的超时时间 failover-timeout 可以用在以下这些方面：                                 |
| 32  | #1. 同一个 sentinel 对同一个 master 两次 failover 之间的间隔时间。                           |
| 33  | #2. 当一个 slave 从一个错误的 master 那里同步数据开始计算时间。直到 slave 被纠正为向正确的   |
|     | master 那里同步数据时。                                                                      |
| 34  | #3.当想要取消一个正在进行的 failover 所需要的时间。                                          |
| 35  | #4.当进行 failover 时，配置所有 slaves 指向新的 master 所需的最大时间。不过，即使过了这个超  |
|     | 时，slaves 依然会被正确配置为指向 master，但是就不按 parallel-syncs 所配置的规则来了         |
| 36  | # 默认三分钟                                                                                 |
| 37  | # sentinel failover-timeout <master-name> <milliseconds>                                     |
| 38  | sentinel failover-timeout mymaster 180000                                                    |
| 39  |                                                                                              |
| 40  | # SCRIPTS EXECUTION                                                                          |
| 41  |                                                                                              |
| 42  | #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮  |
|     | 件通知相关人员。                                                                             |
| 43  | #对于脚本的运行结果有以下规则：                                                              |
| 44  | #若脚本执行后返回 1，那么该脚本稍后将会被再次执行，重复次数目前默认为 10                     |
| 45  | #若脚本执行后返回 2，或者比 2 更高的一个返回值，脚本将不会重复执行。                         |
| 46  | #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为 1 时的行为相同。             |
| 47  | #一个脚本的最大执行时间为 60s，如果超过这个时间，脚本将会被一个 SIGKILL 信号终止，之后重新执 |
|     | 行。                                                                                         |
| 48  |                                                                                              |
| 49  | #通知型脚本:当 sentinel 有任何警告级别的事件发生时（比如说 redis 实例的主观失效和客观失效等  |
|     | 等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS 等方式去通知系统管理员关于系统不正常 |
|     | 运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果       |
|     | sentinel.conf 配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执   |
|     | 行的，否则 sentinel 无法正常启动成功。                                                       |
| 50  | #通知脚本                                                                                    |
| 51  | # sentinel notification-script <master-name> <script-path>                                   |
| 52  | sentinel notification-script mymaster /var/redis/notify.sh                                   |
| 53  |                                                                                              |
| 54  | # 客户端重新配置主节点参数脚本                                                               |
| 55  | # 当一个 master 由于 failover 而发生改变时，这个脚本将会被调用，通知相关的客户端关于 master  |
|     | 地址已经发生改变的信息。                                                                     |
| 56  | # 以下参数将会在调用脚本时传给脚本:                                                          |
| 57  | # <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>                       |
| 58  | # 目前<state>总是“failover”,                                                                 |
| 59  | # <role>是“leader”或者“observer”中的一个。                                                   |
| 60  | # 参数 from-ip, from-port, to-ip, to-port 是用来和旧的 master 和新的 master(即旧的           |
|     | slave)通信的                                                                                 |

| 61  | # 这个脚本应该是通用的，能被多次调用，不是针对性的。            |
| --- | --------------------------------------------------------------- |
| 62  | # sentinel client-reconfig-script <master-name> <script-path>   |
| 63  | sentinel client-reconfig-script mymaster /var/redis/reconfig.sh |

# 缓存穿透和雪崩

Redis 缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一 些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据 的一致性要求很高，那么就不能使用缓存。
另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。

## 缓存穿透

概念
缓存穿透的概念很简单，用户想要查询一个数据，发现 redis 内存数据库没有，也就是缓存没有命中，于 是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是 都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。

解决方案

### 布隆过滤器

布隆过滤器是一种数据结构，对所有可能查询的参数以 hash 形式存储，在控制层先进行校验，不符合则 丢弃，从而避免了对底层存储系统的查询压力；
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834913505-0266dd07-d54d-4cff-b5f6-2ee6293b66d4.jpeg#)

### 缓存空对象

当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数 据将会从缓存中获取，保护了后端数据源；

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834913879-c35720f3-c4c5-4a11-9942-844c0f4b748c.jpeg#)

但是这种方法会存在两个问题：
1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多 的空值的键；
2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于 需要保持一致性的业务会有影响。

## 缓存击穿

概述
这里需要注意和缓存击穿的区别，缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中 对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一 个屏障上凿开了一个洞。
当某个 key 在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访 问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。

解决方案

### 设置热点数据永不过期

从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。

### 加互斥锁

分布式锁：使用分布式锁，保证对于每个 key 同时只有一个线程去查询后端服务，其他线程没有获得分布 式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考 验很大。

## 缓存雪崩

概念
缓存雪崩，是指在某一个时间段，缓存集中过期失效。
产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商 品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都 过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波 峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834914176-82a324d8-a3ef-46f9-b987-326d87aece20.jpeg#)

其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然 形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就 是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知 的，很有可能瞬间就把数据库压垮。
解决方案

### redis 高可用

这个思想的含义是，既然 redis 有可能挂掉，那我多增设几台 redis，这样一台挂掉之后其他的还可以继续 工作，其实就是搭建的集群。

### 限流降级

这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对 某个 key 只允许一个线程查询数据和写缓存，其他线程等待。

### 数据预热

数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数 据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让 缓存失效的时间点尽量均匀。

# Jedis

Jedis 是 Redis 官方推荐的 Java 连接开发工具。要在 Java 开发中使用好 Redis 中间件，必须对 Jedis 熟悉才能写成漂亮的代码

## 测试联通

1、新建一个普通的 Maven 项目 2、导入 redis 的依赖！

<!-- [https://mvnrepository.com/artifact/redis.clients/jedis](https://mvnrepository.com/artifact/redis.clients/jedis) -->
<dependency>
<groupId>redis.clients</groupId>
<artifactId>jedis</artifactId>
<version>3.2.0</version>
</dependency>
<dependency>
<groupId>com.alibaba</groupId>
<artifactId>fastjson</artifactId>
<version>1.2.58</version>
</dependency>
1
2
3
4
5
6
7
8
9
10
11

3、编写测试代码

| 1   | package com.kuang.ping;                            |
| --- | -------------------------------------------------- |
| 2   |                                                    |
| 3   | import redis.clients.jedis.Jedis;                  |
| 4   |                                                    |
| 5   | public class Ping {                                |
| 6   | public static void main(String[] args) {           |
| 7   | Jedis jedis = new Jedis("127.0.0.1",6379);         |
| 8   | System.out.println("连接成功");                    |
| 9   | //查看服务是否运行                                 |
| 10  | System.out.println("服务正在运行: "+jedis.ping()); |
| 11  | }                                                  |
| 12  | }                                                  |

4、启动 redis 服务 5、启动测试，结果

| 1   | 连接成功           |
| --- | ------------------ |
| 2   | 服务正在运行: PONG |

## 常用 API

基本操作

| 1   | public class TestPassword {                 |
| --- | ------------------------------------------- |
| 2   | public static void main(String[] args) {    |
| 3   | Jedis jedis = new Jedis("127.0.0.1", 6379); |
| 4   |                                             |
| 5   | //验证密码，如果没有设置密码这段代码省略    |
| 6   | // jedis.auth("password");                  |
| 7   |                                             |
| 8   | jedis.connect(); //连接                     |
| 9   | jedis.disconnect(); //断开连接              |
| 10  |                                             |
| 11  | jedis.flushAll(); //清空所有的 key          |
| 12  | }                                           |
| 13  | }                                           |

对 key 操作的命令

| 1   | public class TestKey {                                                  |
| --- | ----------------------------------------------------------------------- |
| 2   | public static void main(String[] args) {                                |
| 3   | Jedis jedis = new Jedis("127.0.0.1", 6379);                             |
| 4   |                                                                         |
| 5   | System.out.println("清空数据："+jedis.flushDB());                       |
| 6   | System.out.println("判断某个键是否存在："+jedis.exists("username"));    |
| 7   | System.out.println("新增<'username','kuangshen'>的键值                  |
|     | 对："+jedis.set("username", "kuangshen"));                              |
| 8   | System.out.println("新增<'password','password'>的键值                   |
|     | 对："+jedis.set("password", "password"));                               |
| 9   | System.out.print("系统中所有的键如下：");                               |
| 10  | Set<String> keys = jedis.keys("\*");                                    |
| 11  | System.out.println(keys);                                               |
| 12  | System.out.println("删除键 password:"+jedis.del("password"));           |
| 13  | System.out.println("判断键 password 是否存                              |
|     | 在："+jedis.exists("password"));                                        |
| 14  | System.out.println("查看键 username 所存储的值的类                      |
|     | 型："+jedis.type("username"));                                          |
| 15  | System.out.println("随机返回 key 空间的一个："+jedis.randomKey());      |
| 16  | System.out.println("重命名 key："+jedis.rename("username","name"));     |
| 17  | System.out.println("取出改后的 name："+jedis.get("name"));              |
| 18  | System.out.println("按索引查询："+jedis.select(0));                     |
| 19  | System.out.println("删除当前选择数据库中的所有 key："+jedis.flushDB()); |
| 20  | System.out.println("返回当前数据库中 key 的数目："+jedis.dbSize());     |
| 21  | System.out.println("删除所有数据库中的所有 key："+jedis.flushAll());    |
| 22  | }                                                                       |
| 23  | }                                                                       |

对 String 操作的命令

| 1   | public class TestString {                             |
| --- | ----------------------------------------------------- |
| 2   | public static void main(String[] args) {              |
| 3   | Jedis jedis = new Jedis("127.0.0.1", 6379);           |
| 4   |                                                       |
| 5   | jedis.flushDB();                                      |
| 6   | System.out.println("===========增加数据==========="); |
| 7   | System.out.println(jedis.set("key1","value1"));       |
| 8   | System.out.println(jedis.set("key2","value2"));       |
| 9   | System.out.println(jedis.set("key3", "value3"));      |

| 10  | System.out.println("删除键 key2:"+jedis.del("key2"));                     |
| --- | ------------------------------------------------------------------------- |
| 11  | System.out.println("获取键 key2:"+jedis.get("key2"));                     |
| 12  | System.out.println("修改 key1:"+jedis.set("key1", "value1Changed"));      |
| 13  | System.out.println("获取 key1 的值："+jedis.get("key1"));                 |
| 14  | System.out.println("在 key3 后面加入值："+jedis.append("key3", "End"));   |
| 15  | System.out.println("key3 的值："+jedis.get("key3"));                      |
| 16  | System.out.println("增加多个键值                                          |
|     | 对："+jedis.mset("key01","value01","key02","value02","key03","value03")); |
| 17  | System.out.println("获取多个键值                                          |
|     | 对："+jedis.mget("key01","key02","key03"));                               |
| 18  | System.out.println("获取多个键值                                          |
|     | 对："+jedis.mget("key01","key02","key03","key04"));                       |
| 19  | System.out.println("删除多个键值对："+jedis.del("key01","key02"));        |
| 20  | System.out.println("获取多个键值                                          |
|     | 对："+jedis.mget("key01","key02","key03"));                               |
| 21  |                                                                           |
| 22  | jedis.flushDB();                                                          |
| 23  | System.out.println("===========新增键值对防止覆盖原先值==============");  |
| 24  | System.out.println(jedis.setnx("key1", "value1"));                        |
| 25  | System.out.println(jedis.setnx("key2", "value2"));                        |
| 26  | System.out.println(jedis.setnx("key2", "value2-new"));                    |
| 27  | System.out.println(jedis.get("key1"));                                    |
| 28  | System.out.println(jedis.get("key2"));                                    |
| 29  |                                                                           |
| 30  | System.out.println("===========新增键值对并设置有效时间=============");   |
| 31  | System.out.println(jedis.setex("key3", 2, "value3"));                     |
| 32  | System.out.println(jedis.get("key3"));                                    |
| 33  | try {                                                                     |
| 34  | TimeUnit.SECONDS.sleep(3);                                                |
| 35  | } catch (InterruptedException e) {                                        |
| 36  | e.printStackTrace();                                                      |
| 37  | }                                                                         |
| 38  | System.out.println(jedis.get("key3"));                                    |
| 39  |                                                                           |
| 40  | System.out.println("===========获取原值，更新为新值==========");          |
| 41  | System.out.println(jedis.getSet("key2", "key2GetSet"));                   |
| 42  | System.out.println(jedis.get("key2"));                                    |
| 43  |                                                                           |
| 44  | System.out.println("获得 key2 的值的字串："+jedis.getrange("key2", 2,     |
|     | 4));                                                                      |
| 45  | }                                                                         |
| 46  | }                                                                         |

对 List 操作命令
public class TestList {
public static void main(String[] args) {
Jedis jedis = new Jedis("127.0.0.1", 6379); jedis.flushDB();
System.out.println("===========添加一个 list===========");
jedis.lpush("collections", "ArrayList", "Vector", "Stack", "HashMap", "WeakHashMap", "LinkedHashMap");
jedis.lpush("collections", "HashSet"); jedis.lpush("collections", "TreeSet"); jedis.lpush("collections", "TreeMap");
System.out.println("collections 的内容："+jedis.lrange("collections",
0, -1));//-1 代表倒数第一个元素，-2 代表倒数第二个元素,end 为-1 表示查询全部
1
2
3
4
5
6

7
8
9
10

| 11 | System.out.println("collections 区间 0-3 的元素："+jedis.lrange("collections",0,3));
System.out.println("===============================");
// 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后 add 进去的值先被删，类
似于出栈
System.out.println("删除指定元素个数："+jedis.lrem("collections", 2, "HashMap"));
System.out.println("collections 的内容："+jedis.lrange("collections",
0, -1));
System.out.println("删除下表 0-3 区间之外的元素："+jedis.ltrim("collections", 0, 3));
System.out.println("collections 的内容："+jedis.lrange("collections",
0, -1));
System.out.println("collections 列表出栈（左端）："+jedis.lpop("collections"));
System.out.println("collections 的内容："+jedis.lrange("collections",
0, -1));
System.out.println("collections 添加元素，从列表右端，与 lpush 相对 应："+jedis.rpush("collections", "EnumMap"));
System.out.println("collections 的内容："+jedis.lrange("collections",
0, -1));
System.out.println("collections 列表出栈（右端）："+jedis.rpop("collections"));
System.out.println("collections 的内容："+jedis.lrange("collections",
0, -1));
System.out.println("修改 collections 指定下标 1 的内 容："+jedis.lset("collections", 1, "LinkedArrayList"));
System.out.println("collections 的内容："+jedis.lrange("collections",
0, -1));
System.out.println("===============================");
System.out.println("collections 的长度："+jedis.llen("collections"));
System.out.println("获取 collections 下标为 2 的元素："+jedis.lindex("collections", 2));
System.out.println("===============================");
jedis.lpush("sortedList", "3","6","2","0","7","4");
System.out.println("sortedList 排序前："+jedis.lrange("sortedList", 0,
-1));
System.out.println(jedis.sort("sortedList")); | |
| --- | --- | --- |
|
12 | |
| 13 | |
|
14 | |
|
15 | |
|
16 | |
|
17 | |
|
18 | |
|
19 | |
|
20 | |
|
21 | |
|
22 | |
|
23 | |
|
24 | |
|
25 | |
|
26 | |
| 27 | |
| 28 | |
|
29 | |
| 30 | |
| 31 | |
|
32 | |
| 33 | | System.out.println("sortedList 排序后："+jedis.lrange("sortedList", 0, |
| -1)); | | |
| 34 } | | |
| 35 } | | |

对 Set 的操作命令
public class TestSet {
public static void main(String[] args) {
Jedis jedis = new Jedis("127.0.0.1", 6379); jedis.flushDB();
System.out.println("============向集合中添加元素（不重复）
============");
System.out.println(jedis.sadd("eleSet", "e1","e2","e4","e3","e0","e8","e7","e5"));
System.out.println(jedis.sadd("eleSet", "e6")); System.out.println(jedis.sadd("eleSet", "e6"));
System.out.println("eleSet 的所有元素为："+jedis.smembers("eleSet"));
System.out.println("删除一个元素 e0："+jedis.srem("eleSet", "e0"));
1
2
3
4
5

6

7
8
9
10

| 11
12

13
14
15
16
17
18

19

20

21
22

23

24

25

26
27
28
29
30
31

32

33

34

35
36
37 | System.out.println("eleSet 的所有元素为："+jedis.smembers("eleSet")); System.out.println("删除两个元素 e7 和 e6："+jedis.srem("eleSet",
"e7","e6"));
System.out.println("eleSet 的所有元素为："+jedis.smembers("eleSet")); System.out.println("随机的移除集合中的一个元素："+jedis.spop("eleSet")); System.out.println("随机的移除集合中的一个元素："+jedis.spop("eleSet")); System.out.println("eleSet 的所有元素为："+jedis.smembers("eleSet")); System.out.println("eleSet 中包含元素的个数："+jedis.scard("eleSet")); System.out.println("e3 是否在 eleSet 中："+jedis.sismember("eleSet",
"e3"));
System.out.println("e1 是否在 eleSet 中："+jedis.sismember("eleSet",
"e1"));
System.out.println("e1 是否在 eleSet 中："+jedis.sismember("eleSet",
"e5"));
System.out.println("=================================");
System.out.println(jedis.sadd("eleSet1", "e1","e2","e4","e3","e0","e8","e7","e5"));
System.out.println(jedis.sadd("eleSet2", "e1","e2","e4","e3","e0","e8"));
System.out.println("将 eleSet1 中删除 e1 并存入 eleSet3
中："+jedis.smove("eleSet1", "eleSet3", "e1"));//移到集合元素 System.out.println("将 eleSet1 中删除 e2 并存入 eleSet3
中 ："+jedis.smove("eleSet1", "eleSet3", "e2")); System.out.println("eleSet1 中的元素："+jedis.smembers("eleSet1")); System.out.println("eleSet3 中的元素："+jedis.smembers("eleSet3")); System.out.println("============ 集 合 运 算 ================="); System.out.println("eleSet1 中的元素："+jedis.smembers("eleSet1")); System.out.println("eleSet2 中的元素："+jedis.smembers("eleSet2"));
System.out.println("eleSet1 和 eleSet2 的交集:"+jedis.sinter("eleSet1","eleSet2"));
System.out.println("eleSet1 和 eleSet2 的并集:"+jedis.sunion("eleSet1","eleSet2"));
System.out.println("eleSet1 和 eleSet2 的差
集:"+jedis.sdiff("eleSet1","eleSet2"));//eleSet1 中有，eleSet2 中没有
jedis.sinterstore("eleSet4","eleSet1","eleSet2");//求交集并将交集保存到 dstkey 的集合
System.out.println("eleSet4 中的元素："+jedis.smembers("eleSet4"));
}
} |
| --- | --- |

对 Hash 的操作命令

| 1
2
3
4
5
6
7
8
9
10
11
12
13
14 | public class TestHash {
public static void main(String[] args) {
Jedis jedis = new Jedis("127.0.0.1", 6379); jedis.flushDB();
Map<String,String> map = new HashMap<>(); map.put("key1","value1");
map.put("key2","value2");
map.put("key3","value3");
map.put("key4","value4");
//添加名称为 hash（key）的 hash 元素 jedis.hmset("hash",map);
//向名称为 hash 的 hash 中添加 key 为 key5，value 为 value5 元素 jedis.hset("hash", "key5", "value5");
System.out.println("散列 hash 的所有键值对
为："+jedis.hgetAll("hash"));//return Map<String,String> |
| --- | --- |

System.out.println("散列 hash 的所有键为："+jedis.hkeys("hash"));//return Set<String>
System.out.println("散列 hash 的所有值为："+jedis.hvals("hash"));//return List<String>
System.out.println("将 key6 保存的值加上一个整数，如果 key6 不存在则添加 key6："+jedis.hincrBy("hash", "key6", 6));
System.out.println("散列 hash 的所有键值对为："+jedis.hgetAll("hash"));
System.out.println("将 key6 保存的值加上一个整数，如果 key6 不存在则添加 key6："+jedis.hincrBy("hash", "key6", 3));
System.out.println("散列 hash 的所有键值对为："+jedis.hgetAll("hash")); System.out.println("删除一个或者多个键值对："+jedis.hdel("hash",
"key2"));
System.out.println("散列 hash 的所有键值对为："+jedis.hgetAll("hash")); System.out.println("散列 hash 中键值对的个数："+jedis.hlen("hash"));
System.out.println("判断 hash 中是否存在 key2："+jedis.hexists("hash","key2"));
System.out.println("判断 hash 中是否存在 key3："+jedis.hexists("hash","key3"));
System.out.println("获取 hash 中的值："+jedis.hmget("hash","key3"));
System.out.println("获取 hash 中的值："+jedis.hmget("hash","key3","key4"));
}
}
15

16

17

18
19

20
21

22
23
24

25

26
27

28
29

**事务**
基本操作

| 1   | package com.kuang.multi;                       |
| --- | ---------------------------------------------- |
| 2   |                                                |
| 3   | import com.alibaba.fastjson.JSONObject;        |
| 4   | import redis.clients.jedis.Jedis;              |
| 5   | import redis.clients.jedis.Transaction;        |
| 6   |                                                |
| 7   | public class TestMulti {                       |
| 8   | public static void main(String[] args) {       |
| 9   | //创建客户端连接服务端，redis 服务端需要被开启 |
| 10  | Jedis jedis = new Jedis("127.0.0.1", 6379);    |
| 11  | jedis.flushDB();                               |
| 12  |                                                |
| 13  | JSONObject jsonObject = new JSONObject();      |
| 14  | jsonObject.put("hello", "world");              |
| 15  | jsonObject.put("name", "java");                |
| 16  | //开启事务                                     |
| 17  | Transaction multi = jedis.multi();             |
| 18  | String result = jsonObject.toJSONString();     |
| 19  | try{                                           |
| 20  | //向 redis 存入一条数据                        |
| 21  | multi.set("json", result);                     |
| 22  | //再存入一条数据                               |
| 23  | multi.set("json2", result);                    |
| 24  | //这里引发了异常，用 0 作为被除数              |
| 25  | int i = 100/0;                                 |
| 26  | //如果没有引发异常，执行进入队列的命令         |

| 27 |

} |

} | multi.exec();
}catch(Exception e){ e.printStackTrace();
//如果出现异常，回滚
multi.discard();
}finally{
System.out.println(jedis.get("json")); System.out.println(jedis.get("json2"));
//最终关闭客户端
jedis.close();
} |
| --- | --- | --- | --- |
| 28 | | | |
| 29 | | | |
| 30 | | | |
| 31 | | | |
| 32 | | | |
| 33 | | | |
| 34 | | | |
| 35 | | | |
| 36 | | | |
| 37 | | | |
| 38 | | | |
| 39 | | | |

# SpringBoot 整合

## 基础使用

概述
在 SpringBoot 中一般使用 RedisTemplate 提供的方法来操作 Redis。那么使用 SpringBoot 整合 Redis 需要 那些步骤呢。
1、 (这个是配置连接池)
JedisPoolConfig
2、 这个是配置连接信息，这里的 RedisConnectionFactory 是一个接
RedisConnectionFactory
口，我们需要使用它的实现类，在 SpringD Data Redis 方案中提供了以下四种工厂模型：
JredisConnectionFactory JedisConnectionFactory LettuceConnectionFactory SrpConnectionFactory
3、 基本操作
RedisTemplate

导入依赖
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
1
2
3
4
yaml 配置

1. spring:
1. redis:

3 host: 127.0.0.1
4 port: 6379

1. password: 123456
1. jedis:
1. pool:
1. max-active: 8
1. max-wait: -1ms
1. max-idle: 500
1. min-idle: 0
1. lettuce:
1. shutdown-timeout: 0ms

测试

| 1   | @SpringBootTest                                               |
| --- | ------------------------------------------------------------- |
| 2   | class SpringbootRedisApplicationTests {                       |
| 3   |                                                               |
| 4   | @Autowired                                                    |
| 5   | private RedisTemplate<String,String> redisTemplate;           |
| 6   |                                                               |
| 7   | @Test                                                         |
| 8   | void contextLoads() {                                         |
| 9   | redisTemplate.opsForValue().set("myKey","myValue");           |
| 10  | System.out.println(redisTemplate.opsForValue().get("myKey")); |
| 11  | }                                                             |
| 12  |                                                               |
| 13  | }                                                             |

## 封装工具类

1、新建一个 SpringBoot 项目 2、导入 redis 的启动器
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
1
2
3
4

3、配置 redis，可以查看 RedisProperties 分析

| 1   | # Redis 服务器地址          |
| --- | --------------------------- |
| 2   | spring.redis.host=127.0.0.1 |
| 3   | # Redis 服务器连接端口      |
| 4   | spring.redis.port=6379      |

4、分析 RedisAutoConﬁguration 自动配置类

| 1   | @Configuration(proxyBeanMethods = false)              |
| --- | ----------------------------------------------------- |
| 2   | @ConditionalOnClass(RedisOperations.class)            |
| 3   | @EnableConfigurationProperties(RedisProperties.class) |

| 4   | @Import({ LettuceConnectionConfiguration.class,                       |
| --- | --------------------------------------------------------------------- |
|     | JedisConnectionConfiguration.class })                                 |
| 5   | public class RedisAutoConfiguration {                                 |
| 6   |                                                                       |
| 7   | @Bean                                                                 |
| 8   | @ConditionalOnMissingBean(name = "redisTemplate")                     |
| 9   | public RedisTemplate<Object, Object>                                  |
|     | redisTemplate(RedisConnectionFactory redisConnectionFactory)          |
| 10  | throws UnknownHostException {                                         |
| 11  | RedisTemplate<Object, Object> template = new RedisTemplate<>();       |
| 12  | template.setConnectionFactory(redisConnectionFactory);                |
| 13  | return template;                                                      |
| 14  | }                                                                     |
| 15  |                                                                       |
| 16  | @Bean                                                                 |
| 17  | @ConditionalOnMissingBean                                             |
| 18  | public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory |
|     | redisConnectionFactory)                                               |
| 19  | throws UnknownHostException {                                         |
| 20  | StringRedisTemplate template = new StringRedisTemplate();             |
| 21  | template.setConnectionFactory(redisConnectionFactory);                |
| 22  | return template;                                                      |
| 23  | }                                                                     |
| 24  |                                                                       |
| 25  | }                                                                     |

通过源码可以看出，SpringBoot 自动帮我们在容器中生成了一个 RedisTemplate 和一个
StringRedisTemplate。
但是，这个 RedisTemplate 的泛型是<Object,Object>，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为<String,Object>形式的 RedisTemplate。
并且，这个 RedisTemplate 没有设置数据存在 Redis 时，key 及 value 的序列化方式。
看到这个@ConditionalOnMissingBean 注解后，就知道如果 Spring 容器中有了 RedisTemplate 对象了， 这个自动配置的 RedisTemplate 不会实例化。因此我们可以直接自己写个配置类，配置
RedisTemplate。

### 5、既然自动配置不好用，就重新配置一个 RedisTemplate

| 1   | package com.kuang.config;                                                |
| --- | ------------------------------------------------------------------------ |
| 2   |                                                                          |
| 3   | import com.fasterxml.jackson.annotation.JsonAutoDetect;                  |
| 4   | import com.fasterxml.jackson.annotation.PropertyAccessor;                |
| 5   | import com.fasterxml.jackson.databind.ObjectMapper;                      |
| 6   | import org.springframework.context.annotation.Bean;                      |
| 7   | import org.springframework.context.annotation.Configuration;             |
| 8   | import org.springframework.data.redis.connection.RedisConnectionFactory; |
| 9   | import org.springframework.data.redis.core.RedisTemplate;                |
| 10  | import                                                                   |
|     | org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;   |
| 11  | import org.springframework.data.redis.serializer.StringRedisSerializer;  |
| 12  |                                                                          |
| 13  | @Configuration                                                           |
| 14  | public class RedisConfig {                                               |
| 15  |                                                                          |
| 16  | @Bean                                                                    |
| 17  | @SuppressWarnings("all")                                                 |

| 18  | public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory |
| --- | ------------------------------------------------------------------------- |
|     | factory) {                                                                |
| 19  | RedisTemplate<String, Object> template = new RedisTemplate<String,        |
|     | Object>();                                                                |
| 20  | template.setConnectionFactory(factory);                                   |
| 21  | Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new             |
|     | Jackson2JsonRedisSerializer(Object.class);                                |
| 22  | ObjectMapper om = new ObjectMapper();                                     |
| 23  | om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);    |
| 24  | om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);             |
| 25  | jackson2JsonRedisSerializer.setObjectMapper(om);                          |
| 26  | StringRedisSerializer stringRedisSerializer = new                         |
|     | StringRedisSerializer();                                                  |
| 27  |                                                                           |
| 28  | // key 采用 String 的序列化方式                                           |
| 29  | template.setKeySerializer(stringRedisSerializer);                         |
| 30  | // hash 的 key 也采用 String 的序列化方式                                 |
| 31  | template.setHashKeySerializer(stringRedisSerializer);                     |
| 32  | // value 序列化方式采用 jackson                                           |
| 33  | template.setValueSerializer(jackson2JsonRedisSerializer);                 |
| 34  | // hash 的 value 序列化方式采用 jackson                                   |
| 35  | template.setHashValueSerializer(jackson2JsonRedisSerializer);             |
| 36  | template.afterPropertiesSet();                                            |
| 37  |                                                                           |
| 38  | return template;                                                          |
| 39  | }                                                                         |
| 40  |                                                                           |
| 41  | }                                                                         |

6、写一个 Redis 工具类（直接用 RedisTemplate 操作 Redis，需要很多行代码，因此直接封装好一个 RedisUtils，这样写代码更方便点。这个 RedisUtils 交给 Spring 容器实例化，使用时直接注解注入。）

| 1   | package com.kuang.utils;                                           |
| --- | ------------------------------------------------------------------ |
| 2   |                                                                    |
| 3   | import org.springframework.beans.factory.annotation.Autowired;     |
| 4   | import org.springframework.data.redis.core.RedisTemplate;          |
| 5   | import org.springframework.stereotype.Component;                   |
| 6   | import org.springframework.util.CollectionUtils;                   |
| 7   |                                                                    |
| 8   | import java.util.List;                                             |
| 9   | import java.util.Map;                                              |
| 10  | import java.util.Set;                                              |
| 11  | import java.util.concurrent.TimeUnit;                              |
| 12  |                                                                    |
| 13  | @Component                                                         |
| 14  | public final class RedisUtil {                                     |
| 15  |                                                                    |
| 16  | @Autowired                                                         |
| 17  | private RedisTemplate<String, Object> redisTemplate;               |
| 18  |                                                                    |
| 19  | // =============================common============================ |
| 20  | /\*\*                                                              |
| 21  | \* 指定缓存失效时间                                                |
| 22  | \* @param key 键                                                   |
| 23  | \* @param time 时间(秒)                                            |
| 24  | \*/                                                                |
| 25  | public boolean expire(String key, long time) {                     |
| 26  | try {                                                              |

| 27  | if (time > 0) {                                                    |
| --- | ------------------------------------------------------------------ |
| 28  | redisTemplate.expire(key, time, TimeUnit.SECONDS);                 |
| 29  | }                                                                  |
| 30  | return true;                                                       |
| 31  | } catch (Exception e) {                                            |
| 32  | e.printStackTrace();                                               |
| 33  | return false;                                                      |
| 34  | }                                                                  |
| 35  | }                                                                  |
| 36  |                                                                    |
| 37  | /\*\*                                                              |
| 38  | \* 根据 key 获取过期时间                                           |
| 39  | \* @param key 键 不能为 null                                       |
| 40  | \* @return 时间(秒) 返回 0 代表为永久有效                          |
| 41  | \*/                                                                |
| 42  | public long getExpire(String key) {                                |
| 43  | return redisTemplate.getExpire(key, TimeUnit.SECONDS);             |
| 44  | }                                                                  |
| 45  |                                                                    |
| 46  |                                                                    |
| 47  | /\*\*                                                              |
| 48  | \* 判断 key 是否存在                                               |
| 49  | \* @param key 键                                                   |
| 50  | \* @return true 存在 false 不存在                                  |
| 51  | \*/                                                                |
| 52  | public boolean hasKey(String key) {                                |
| 53  | try {                                                              |
| 54  | return redisTemplate.hasKey(key);                                  |
| 55  | } catch (Exception e) {                                            |
| 56  | e.printStackTrace();                                               |
| 57  | return false;                                                      |
| 58  | }                                                                  |
| 59  | }                                                                  |
| 60  |                                                                    |
| 61  |                                                                    |
| 62  | /\*\*                                                              |
| 63  | \* 删除缓存                                                        |
| 64  | \* @param key 可以传一个值 或多个                                  |
| 65  | \*/                                                                |
| 66  | @SuppressWarnings("unchecked")                                     |
| 67  | public void del(String... key) {                                   |
| 68  | if (key != null && key.length > 0) {                               |
| 69  | if (key.length == 1) {                                             |
| 70  | redisTemplate.delete(key[0]);                                      |
| 71  | } else {                                                           |
| 72  | redisTemplate.delete(CollectionUtils.arrayToList(key));            |
| 73  | }                                                                  |
| 74  | }                                                                  |
| 75  | }                                                                  |
| 76  |                                                                    |
| 77  |                                                                    |
| 78  | // ============================String============================= |
| 79  |                                                                    |
| 80  | /\*\*                                                              |
| 81  | \* 普通缓存获取                                                    |
| 82  | \* @param key 键                                                   |
| 83  | \* @return 值                                                      |
| 84  | \*/                                                                |

| 85  | public Object get(String key) {                                         |
| --- | ----------------------------------------------------------------------- |
| 86  | return key == null ? null : redisTemplate.opsForValue().get(key);       |
| 87  | }                                                                       |
| 88  |                                                                         |
| 89  | /\*\*                                                                   |
| 90  | \* 普通缓存放入                                                         |
| 91  | \* @param key 键                                                        |
| 92  | \* @param value 值                                                      |
| 93  | \* @return true 成功 false 失败                                         |
| 94  | \*/                                                                     |
| 95  |                                                                         |
| 96  | public boolean set(String key, Object value) {                          |
| 97  | try {                                                                   |
| 98  | redisTemplate.opsForValue().set(key, value);                            |
| 99  | return true;                                                            |
| 100 | } catch (Exception e) {                                                 |
| 101 | e.printStackTrace();                                                    |
| 102 | return false;                                                           |
| 103 | }                                                                       |
| 104 | }                                                                       |
| 105 |                                                                         |
| 106 |                                                                         |
| 107 | /\*\*                                                                   |
| 108 | \* 普通缓存放入并设置时间                                               |
| 109 | \* @param key 键                                                        |
| 110 | \* @param value 值                                                      |
| 111 | \* @param time 时间(秒) time 要大于 0 如果 time 小于等于 0 将设置无限期 |
| 112 | \* @return true 成功 false 失败                                         |
| 113 | \*/                                                                     |
| 114 |                                                                         |
| 115 | public boolean set(String key, Object value, long time) {               |
| 116 | try {                                                                   |
| 117 | if (time > 0) {                                                         |
| 118 | redisTemplate.opsForValue().set(key, value, time,                       |
|     | TimeUnit.SECONDS);                                                      |
| 119 | } else {                                                                |
| 120 | set(key, value);                                                        |
| 121 | }                                                                       |
| 122 | return true;                                                            |
| 123 | } catch (Exception e) {                                                 |
| 124 | e.printStackTrace();                                                    |
| 125 | return false;                                                           |
| 126 | }                                                                       |
| 127 | }                                                                       |
| 128 |                                                                         |
| 129 |                                                                         |
| 130 | /\*\*                                                                   |
| 131 | \* 递增                                                                 |
| 132 | \* @param key 键                                                        |
| 133 | \* @param delta 要增加几(大于 0)                                        |
| 134 | \*/                                                                     |
| 135 | public long incr(String key, long delta) {                              |
| 136 | if (delta < 0) {                                                        |
| 137 | throw new RuntimeException("递增因子必须大于 0");                       |
| 138 | }                                                                       |
| 139 | return redisTemplate.opsForValue().increment(key, delta);               |
| 140 | }                                                                       |
| 141 |                                                                         |

| 142 |                                                                         |
| --- | ----------------------------------------------------------------------- |
| 143 | /\*\*                                                                   |
| 144 | \* 递减                                                                 |
| 145 | \* @param key 键                                                        |
| 146 | \* @param delta 要减少几(小于 0)                                        |
| 147 | \*/                                                                     |
| 148 | public long decr(String key, long delta) {                              |
| 149 | if (delta < 0) {                                                        |
| 150 | throw new RuntimeException("递减因子必须大于 0");                       |
| 151 | }                                                                       |
| 152 | return redisTemplate.opsForValue().increment(key, -delta);              |
| 153 | }                                                                       |
| 154 |                                                                         |
| 155 |                                                                         |
| 156 | // ================================Map================================= |
| 157 |                                                                         |
| 158 | /\*\*                                                                   |
| 159 | \* HashGet                                                              |
| 160 | \* @param key 键 不能为 null                                            |
| 161 | \* @param item 项 不能为 null                                           |
| 162 | \*/                                                                     |
| 163 | public Object hget(String key, String item) {                           |
| 164 | return redisTemplate.opsForHash().get(key, item);                       |
| 165 | }                                                                       |
| 166 |                                                                         |
| 167 | /\*\*                                                                   |
| 168 | \* 获取 hashKey 对应的所有键值                                          |
| 169 | \* @param key 键                                                        |
| 170 | \* @return 对应的多个键值                                               |
| 171 | \*/                                                                     |
| 172 | public Map<Object, Object> hmget(String key) {                          |
| 173 | return redisTemplate.opsForHash().entries(key);                         |
| 174 | }                                                                       |
| 175 |                                                                         |
| 176 | /\*\*                                                                   |
| 177 | \* HashSet                                                              |
| 178 | \* @param key 键                                                        |
| 179 | \* @param map 对应多个键值                                              |
| 180 | \*/                                                                     |
| 181 | public boolean hmset(String key, Map<String, Object> map) {             |
| 182 | try {                                                                   |
| 183 | redisTemplate.opsForHash().putAll(key, map);                            |
| 184 | return true;                                                            |
| 185 | } catch (Exception e) {                                                 |
| 186 | e.printStackTrace();                                                    |
| 187 | return false;                                                           |
| 188 | }                                                                       |
| 189 | }                                                                       |
| 190 |                                                                         |
| 191 |                                                                         |
| 192 | /\*\*                                                                   |
| 193 | \* HashSet 并设置时间                                                   |
| 194 | \* @param key 键                                                        |
| 195 | \* @param map 对应多个键值                                              |
| 196 | \* @param time 时间(秒)                                                 |
| 197 | \* @return true 成功 false 失败                                         |
| 198 | \*/                                                                     |
| 199 | public boolean hmset(String key, Map<String, Object> map, long time) {  |

| 200 | try {                                                                          |
| --- | ------------------------------------------------------------------------------ |
| 201 | redisTemplate.opsForHash().putAll(key, map);                                   |
| 202 | if (time > 0) {                                                                |
| 203 | expire(key, time);                                                             |
| 204 | }                                                                              |
| 205 | return true;                                                                   |
| 206 | } catch (Exception e) {                                                        |
| 207 | e.printStackTrace();                                                           |
| 208 | return false;                                                                  |
| 209 | }                                                                              |
| 210 | }                                                                              |
| 211 |                                                                                |
| 212 |                                                                                |
| 213 | /\*\*                                                                          |
| 214 | \* 向一张 hash 表中放入数据,如果不存在将创建                                   |
| 215 | \*                                                                             |
| 216 | \* @param key 键                                                               |
| 217 | \* @param item 项                                                              |
| 218 | \* @param value 值                                                             |
| 219 | \* @return true 成功 false 失败                                                |
| 220 | \*/                                                                            |
| 221 | public boolean hset(String key, String item, Object value) {                   |
| 222 | try {                                                                          |
| 223 | redisTemplate.opsForHash().put(key, item, value);                              |
| 224 | return true;                                                                   |
| 225 | } catch (Exception e) {                                                        |
| 226 | e.printStackTrace();                                                           |
| 227 | return false;                                                                  |
| 228 | }                                                                              |
| 229 | }                                                                              |
| 230 |                                                                                |
| 231 | /\*\*                                                                          |
| 232 | \* 向一张 hash 表中放入数据,如果不存在将创建                                   |
| 233 | \*                                                                             |
| 234 | \* @param key 键                                                               |
| 235 | \* @param item 项                                                              |
| 236 | \* @param value 值                                                             |
| 237 | \* @param time 时间(秒) 注意:如果已存在的 hash 表有时间,这里将会替换原有的时间 |
| 238 | \* @return true 成功 false 失败                                                |
| 239 | \*/                                                                            |
| 240 | public boolean hset(String key, String item, Object value, long time) {        |
| 241 | try {                                                                          |
| 242 | redisTemplate.opsForHash().put(key, item, value);                              |
| 243 | if (time > 0) {                                                                |
| 244 | expire(key, time);                                                             |
| 245 | }                                                                              |
| 246 | return true;                                                                   |
| 247 | } catch (Exception e) {                                                        |
| 248 | e.printStackTrace();                                                           |
| 249 | return false;                                                                  |
| 250 | }                                                                              |
| 251 | }                                                                              |
| 252 |                                                                                |
| 253 |                                                                                |
| 254 | /\*\*                                                                          |
| 255 | \* 删除 hash 表中的值                                                          |
| 256 | \*                                                                             |
| 257 | \* @param key 键 不能为 null                                                   |

| 258 | \* @param item 项 可以使多个 不能为 null                        |
| --- | --------------------------------------------------------------- |
| 259 | \*/                                                             |
| 260 | public void hdel(String key, Object... item) {                  |
| 261 | redisTemplate.opsForHash().delete(key, item);                   |
| 262 | }                                                               |
| 263 |                                                                 |
| 264 |                                                                 |
| 265 | /\*\*                                                           |
| 266 | \* 判断 hash 表中是否有该项的值                                 |
| 267 | \*                                                              |
| 268 | \* @param key 键 不能为 null                                    |
| 269 | \* @param item 项 不能为 null                                   |
| 270 | \* @return true 存在 false 不存在                               |
| 271 | \*/                                                             |
| 272 | public boolean hHasKey(String key, String item) {               |
| 273 | return redisTemplate.opsForHash().hasKey(key, item);            |
| 274 | }                                                               |
| 275 |                                                                 |
| 276 |                                                                 |
| 277 | /\*\*                                                           |
| 278 | \* hash 递增 如果不存在,就会创建一个 并把新增后的值返回         |
| 279 | \*                                                              |
| 280 | \* @param key 键                                                |
| 281 | \* @param item 项                                               |
| 282 | \* @param by 要增加几(大于 0)                                   |
| 283 | \*/                                                             |
| 284 | public double hincr(String key, String item, double by) {       |
| 285 | return redisTemplate.opsForHash().increment(key, item, by);     |
| 286 | }                                                               |
| 287 |                                                                 |
| 288 |                                                                 |
| 289 | /\*\*                                                           |
| 290 | \* hash 递减                                                    |
| 291 | \*                                                              |
| 292 | \* @param key 键                                                |
| 293 | \* @param item 项                                               |
| 294 | \* @param by 要减少记(小于 0)                                   |
| 295 | \*/                                                             |
| 296 | public double hdecr(String key, String item, double by) {       |
| 297 | return redisTemplate.opsForHash().increment(key, item, -by);    |
| 298 | }                                                               |
| 299 |                                                                 |
| 300 |                                                                 |
| 301 | // ============================set============================= |
| 302 |                                                                 |
| 303 | /\*\*                                                           |
| 304 | \* 根据 key 获取 Set 中的所有值                                 |
| 305 | \* @param key 键                                                |
| 306 | \*/                                                             |
| 307 | public Set<Object> sGet(String key) {                           |
| 308 | try {                                                           |
| 309 | return redisTemplate.opsForSet().members(key);                  |
| 310 | } catch (Exception e) {                                         |
| 311 | e.printStackTrace();                                            |
| 312 | return null;                                                    |
| 313 | }                                                               |
| 314 | }                                                               |
| 315 |                                                                 |

| 316 |                                                                    |
| --- | ------------------------------------------------------------------ |
| 317 | /\*\*                                                              |
| 318 | \* 根据 value 从一个 set 中查询,是否存在                           |
| 319 | \*                                                                 |
| 320 | \* @param key 键                                                   |
| 321 | \* @param value 值                                                 |
| 322 | \* @return true 存在 false 不存在                                  |
| 323 | \*/                                                                |
| 324 | public boolean sHasKey(String key, Object value) {                 |
| 325 | try {                                                              |
| 326 | return redisTemplate.opsForSet().isMember(key, value);             |
| 327 | } catch (Exception e) {                                            |
| 328 | e.printStackTrace();                                               |
| 329 | return false;                                                      |
| 330 | }                                                                  |
| 331 | }                                                                  |
| 332 |                                                                    |
| 333 |                                                                    |
| 334 | /\*\*                                                              |
| 335 | \* 将数据放入 set 缓存                                             |
| 336 | \*                                                                 |
| 337 | \* @param key 键                                                   |
| 338 | \* @param values 值 可以是多个                                     |
| 339 | \* @return 成功个数                                                |
| 340 | \*/                                                                |
| 341 | public long sSet(String key, Object... values) {                   |
| 342 | try {                                                              |
| 343 | return redisTemplate.opsForSet().add(key, values);                 |
| 344 | } catch (Exception e) {                                            |
| 345 | e.printStackTrace();                                               |
| 346 | return 0;                                                          |
| 347 | }                                                                  |
| 348 | }                                                                  |
| 349 |                                                                    |
| 350 |                                                                    |
| 351 | /\*\*                                                              |
| 352 | \* 将 set 数据放入缓存                                             |
| 353 | \*                                                                 |
| 354 | \* @param key 键                                                   |
| 355 | \* @param time 时间(秒)                                            |
| 356 | \* @param values 值 可以是多个                                     |
| 357 | \* @return 成功个数                                                |
| 358 | \*/                                                                |
| 359 | public long sSetAndTime(String key, long time, Object... values) { |
| 360 | try {                                                              |
| 361 | Long count = redisTemplate.opsForSet().add(key, values);           |
| 362 | if (time > 0)                                                      |
| 363 | expire(key, time);                                                 |
| 364 | return count;                                                      |
| 365 | } catch (Exception e) {                                            |
| 366 | e.printStackTrace();                                               |
| 367 | return 0;                                                          |
| 368 | }                                                                  |
| 369 | }                                                                  |
| 370 |                                                                    |
| 371 |                                                                    |
| 372 | /\*\*                                                              |
| 373 | \* 获取 set 缓存的长度                                             |

| 374 | \*                                                                      |
| --- | ----------------------------------------------------------------------- |
| 375 | \* @param key 键                                                        |
| 376 | \*/                                                                     |
| 377 | public long sGetSetSize(String key) {                                   |
| 378 | try {                                                                   |
| 379 | return redisTemplate.opsForSet().size(key);                             |
| 380 | } catch (Exception e) {                                                 |
| 381 | e.printStackTrace();                                                    |
| 382 | return 0;                                                               |
| 383 | }                                                                       |
| 384 | }                                                                       |
| 385 |                                                                         |
| 386 |                                                                         |
| 387 | /\*\*                                                                   |
| 388 | \* 移除值为 value 的                                                    |
| 389 | \*                                                                      |
| 390 | \* @param key 键                                                        |
| 391 | \* @param values 值 可以是多个                                          |
| 392 | \* @return 移除的个数                                                   |
| 393 | \*/                                                                     |
| 394 |                                                                         |
| 395 | public long setRemove(String key, Object... values) {                   |
| 396 | try {                                                                   |
| 397 | Long count = redisTemplate.opsForSet().remove(key, values);             |
| 398 | return count;                                                           |
| 399 | } catch (Exception e) {                                                 |
| 400 | e.printStackTrace();                                                    |
| 401 | return 0;                                                               |
| 402 | }                                                                       |
| 403 | }                                                                       |
| 404 |                                                                         |
| 405 | // ===============================list================================= |
| 406 |                                                                         |
| 407 | /\*\*                                                                   |
| 408 | \* 获取 list 缓存的内容                                                 |
| 409 | \*                                                                      |
| 410 | \* @param key 键                                                        |
| 411 | \* @param start 开始                                                    |
| 412 | \* @param end 结束 0 到 -1 代表所有值                                   |
| 413 | \*/                                                                     |
| 414 | public List<Object> lGet(String key, long start, long end) {            |
| 415 | try {                                                                   |
| 416 | return redisTemplate.opsForList().range(key, start, end);               |
| 417 | } catch (Exception e) {                                                 |
| 418 | e.printStackTrace();                                                    |
| 419 | return null;                                                            |
| 420 | }                                                                       |
| 421 | }                                                                       |
| 422 |                                                                         |
| 423 |                                                                         |
| 424 | /\*\*                                                                   |
| 425 | \* 获取 list 缓存的长度                                                 |
| 426 | \*                                                                      |
| 427 | \* @param key 键                                                        |
| 428 | \*/                                                                     |
| 429 | public long lGetListSize(String key) {                                  |
| 430 | try {                                                                   |
| 431 | return redisTemplate.opsForList().size(key);                            |

| 432 | } catch (Exception e) {                                                    |
| --- | -------------------------------------------------------------------------- |
| 433 | e.printStackTrace();                                                       |
| 434 | return 0;                                                                  |
| 435 | }                                                                          |
| 436 | }                                                                          |
| 437 |                                                                            |
| 438 |                                                                            |
| 439 | /\*\*                                                                      |
| 440 | \* 通过索引 获取 list 中的值                                               |
| 441 | \*                                                                         |
| 442 | \* @param key 键                                                           |
| 443 | \* @param index 索引 index>=0 时， 0 表头，1 第二个元素，依次类推；index<0 |
|     | 时，-1，表尾，-2 倒数第二个元素，依次类推                                  |
| 444 | \*/                                                                        |
| 445 | public Object lGetIndex(String key, long index) {                          |
| 446 | try {                                                                      |
| 447 | return redisTemplate.opsForList().index(key, index);                       |
| 448 | } catch (Exception e) {                                                    |
| 449 | e.printStackTrace();                                                       |
| 450 | return null;                                                               |
| 451 | }                                                                          |
| 452 | }                                                                          |
| 453 |                                                                            |
| 454 |                                                                            |
| 455 | /\*\*                                                                      |
| 456 | \* 将 list 放入缓存                                                        |
| 457 | \*                                                                         |
| 458 | \* @param key 键                                                           |
| 459 | \* @param value 值                                                         |
| 460 | \*/                                                                        |
| 461 | public boolean lSet(String key, Object value) {                            |
| 462 | try {                                                                      |
| 463 | redisTemplate.opsForList().rightPush(key, value);                          |
| 464 | return true;                                                               |
| 465 | } catch (Exception e) {                                                    |
| 466 | e.printStackTrace();                                                       |
| 467 | return false;                                                              |
| 468 | }                                                                          |
| 469 | }                                                                          |
| 470 |                                                                            |
| 471 |                                                                            |
| 472 | /\*\*                                                                      |
| 473 | \* 将 list 放入缓存                                                        |
| 474 | \* @param key 键                                                           |
| 475 | \* @param value 值                                                         |
| 476 | \* @param time 时间(秒)                                                    |
| 477 | \*/                                                                        |
| 478 | public boolean lSet(String key, Object value, long time) {                 |
| 479 | try {                                                                      |
| 480 | redisTemplate.opsForList().rightPush(key, value);                          |
| 481 | if (time > 0)                                                              |
| 482 | expire(key, time);                                                         |
| 483 | return true;                                                               |
| 484 | } catch (Exception e) {                                                    |
| 485 | e.printStackTrace();                                                       |
| 486 | return false;                                                              |
| 487 | }                                                                          |
| 488 |                                                                            |

| 489 | }                                                                   |
| --- | ------------------------------------------------------------------- |
| 490 |                                                                     |
| 491 |                                                                     |
| 492 | /\*\*                                                               |
| 493 | \* 将 list 放入缓存                                                 |
| 494 | \*                                                                  |
| 495 | \* @param key 键                                                    |
| 496 | \* @param value 值                                                  |
| 497 | \* @return                                                          |
| 498 | \*/                                                                 |
| 499 | public boolean lSet(String key, List<Object> value) {               |
| 500 | try {                                                               |
| 501 | redisTemplate.opsForList().rightPushAll(key, value);                |
| 502 | return true;                                                        |
| 503 | } catch (Exception e) {                                             |
| 504 | e.printStackTrace();                                                |
| 505 | return false;                                                       |
| 506 | }                                                                   |
| 507 |                                                                     |
| 508 | }                                                                   |
| 509 |                                                                     |
| 510 |                                                                     |
| 511 | /\*\*                                                               |
| 512 | \* 将 list 放入缓存                                                 |
| 513 | \*                                                                  |
| 514 | \* @param key 键                                                    |
| 515 | \* @param value 值                                                  |
| 516 | \* @param time 时间(秒)                                             |
| 517 | \* @return                                                          |
| 518 | \*/                                                                 |
| 519 | public boolean lSet(String key, List<Object> value, long time) {    |
| 520 | try {                                                               |
| 521 | redisTemplate.opsForList().rightPushAll(key, value);                |
| 522 | if (time > 0)                                                       |
| 523 | expire(key, time);                                                  |
| 524 | return true;                                                        |
| 525 | } catch (Exception e) {                                             |
| 526 | e.printStackTrace();                                                |
| 527 | return false;                                                       |
| 528 | }                                                                   |
| 529 | }                                                                   |
| 530 |                                                                     |
| 531 | /\*\*                                                               |
| 532 | \* 根据索引修改 list 中的某条数据                                   |
| 533 | \*                                                                  |
| 534 | \* @param key 键                                                    |
| 535 | \* @param index 索引                                                |
| 536 | \* @param value 值                                                  |
| 537 | \* @return                                                          |
| 538 | \*/                                                                 |
| 539 |                                                                     |
| 540 | public boolean lUpdateIndex(String key, long index, Object value) { |
| 541 | try {                                                               |
| 542 | redisTemplate.opsForList().set(key, index, value);                  |
| 543 | ren true;                                                           |
| 544 | } catch (Exception e) {                                             |
| 545 | e.printStackTrace();                                                |
| 546 | return false;                                                       |

| 547 | }                                                           |
| --- | ----------------------------------------------------------- |
| 548 | }                                                           |
| 549 |                                                             |
| 550 | /\*\*                                                       |
| 551 | \* 移除 N 个值为 value                                      |
| 552 | \*                                                          |
| 553 | \* @param key 键                                            |
| 554 | \* @param count 移除多少个                                  |
| 555 | \* @param value 值                                          |
| 556 | \* @return 移除的个数                                       |
| 557 | \*/                                                         |
| 558 |                                                             |
| 559 | public long lRemove(String key, long count, Object value) { |
| 560 | try {                                                       |
| 561 | Long remove = redisTemplate.opsForList().remove(key, count, |
|     | value);                                                     |
| 562 | return remove;                                              |
| 563 | } catch (Exception e) {                                     |
| 564 | e.printStackTrace();                                        |
| 565 | return 0;                                                   |
| 566 | }                                                           |
| 567 |                                                             |
| 568 | }                                                           |
| 569 |                                                             |
| 570 | }                                                           |
