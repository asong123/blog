---
title: 14、JavaSE：注解和反射
urlname: df28a3
date: '2021-07-09 20:38:33 +0800'
tags: []
categories: []
---

# 注解 Annotation

## 1、什么是注解

Annotation 是从 JDK5.0 开始引入的新技术 .
Annotation 的作用
不是程序本身 , 可以对程序作出解释.(这一点和注释(comment)没什么区别) 可以被其他程序(比如:编译器等)读取.
Annotation 的格式
注解是以"@注释名"在代码中存在的
还可以添加一些参数值 , 例如:@SuppressWarnings(value="unchecked") Annotation 在哪里使用?
可以附加在 package , class , method , ﬁeld 等上面 , 相当于给他们添加了额外的辅助信息我们可以通过反射机制实现对这些元数据的访问

## 2、内置注解

@Override
定义在 java.lang.Override 中 , 此注释只适用于修辞方法 , 表示一个方法声明打算重写超类中的另一个方法声明.
@Deprecated
定义在 java.lang.Deprecated 中 , 此注释可以用于修辞方法 , 属性 , 类 ,
表示不鼓励程序员使用这样的元素 , 通常是因为它很危险或者存在更好的选择 .
@SuppressWarnings
定义在 java.lang.SuppressWarnings 中,用来抑制编译时的警告信息.
与前两个注释有所不同,你需要添加一个参数才能正确使用,这些参数都是已经定义好了的,我们选择性的使用就好了 .
@SuppressWarnings("all") @SuppressWarnings("unchecked") @SuppressWarnings(value={"unchecked","deprecation"}) 等等 .....

1
2
3
4
5
6
7
8
9
10
11
12
13
14
package com.annotation;
//测试内置注解
import java.util.ArrayList; import java.util.List;
//所有类默认继承 Object 类
public class Test1 extends Object {

//@Override 表示方法重写
//--> 查看 JDK 帮助文档
//--> 测试名字不同产生的效果
@Override
public String toString() { return super.toString();

| 15  |     | }                                                         |
| --- | --- | --------------------------------------------------------- |
| 16  |     |                                                           |
| 17  |     | //方法过时了, 不建议使用 , 可能存在问题 , 并不是不能使用! |
| 18  |     | //--> 查看 JDK 帮助文档                                   |
| 19  |     | @Deprecated                                               |
| 20  |     | public static void stop(){                                |
| 21  |     | System.out.println("测试 @Deprecated");                   |
| 22  |     | }                                                         |
| 23  |     |                                                           |
| 24  |     | //@SuppressWarnings 抑制警告 , 可以传参数                 |
| 25  |     | //--> 查看 JDK 帮助文档                                   |
| 26  |     | //查看源码:发现 参数类型 和 参数名称 , 并不是方法!        |
| 27  |     | @SuppressWarnings("all")                                  |
| 28  |     | public void sw(){                                         |
| 29  |     | List list = new ArrayList();                              |
| 30  |     | }                                                         |
| 31  |     |                                                           |
| 32  |     | public static void main(String[] args) {                  |
| 33  |     | stop();                                                   |
| 34  |     | }                                                         |
| 35  |     |                                                           |
| 36  | }   |                                                           |

## 3、元注解

元注解的作用就是负责注解其他注解 , Java 定义了 4 个标准的 meta-annotation 类型,他们被用来提供对其他 annotation 类型作说明 .
这些类型和它们所支持的类在 java.lang.annotation 包中可以找到 .( @Target , @Retention , @Documented , @Inherited )
@Target : 用于描述注解的使用范围(即:被描述的注解可以用在什么地方) @Retention : 表示需要在什么级别保存该注释信息 , 用于描述注解的生命周期
(SOURCE < CLASS < RUNTIME)
@Document：说明该注解将被包含在 javadoc 中@Inherited：说明子类可以继承父类中的该注解
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
package com.annotation;
import java.lang.annotation.\*;
//测试元注解
public class Test2 { @MyAnnotation public void test(){
}
}
//定义一个注解
@Target(value = {ElementType.METHOD,ElementType.TYPE}) @Retention(value = RetentionPolicy.RUNTIME) @Inherited
@Documented
@interface MyAnnotation{

| 19 |
} | //测试作用域 , 了解@Retention 的概念 |
| --- | --- | --- |
| 20 | | |

## 4、自定义注解

使用 @interface 自定义注解时 , 自动继承了 java.lang.annotation.Annotation 接口分析 :
@ interface 用来声明一个注解 , 格式 : public @ interface 注解名 { 定义内容 }
其中的每一个方法实际上是声明了一个配置参数. 方法的名称就是参数的名称.
返回值类型就是参数的类型 ( 返回值只能是基本类型,Class , String , enum ).
可以通过 default 来声明参数的默认值
如果只有一个参数成员 , 一般参数名为 value
注解元素必须要有值 , 我们定义注解元素时 , 经常使用空字符串,0 作为默认值 .

| 1   | package com.annotation;                                              |
| --- | -------------------------------------------------------------------- |
| 2   |                                                                      |
| 3   | import java.lang.annotation.ElementType;                             |
| 4   | import java.lang.annotation.Retention;                               |
| 5   | import java.lang.annotation.RetentionPolicy;                         |
| 6   | import java.lang.annotation.Target;                                  |
| 7   |                                                                      |
| 8   | //测试自定义注解                                                     |
| 9   | public class Test3 {                                                 |
| 10  |                                                                      |
| 11  | //显示定义值 / 不显示值就是默认值                                    |
| 12  | @MyAnnotation2(age = 18,name = "秦疆",id = 001,schools = {"西工大"}) |
| 13  | public void test() {                                                 |
| 14  |                                                                      |
| 15  | }                                                                    |
| 16  |                                                                      |
| 17  | //只有一个参数, 默认名字一般是 value.使用可省略不写                  |
| 18  | @MyAnnotation3("aaa")                                                |
| 19  | public void test2(){                                                 |
| 20  | }                                                                    |
| 21  |                                                                      |
| 22  | }                                                                    |
| 23  |                                                                      |
| 24  |                                                                      |
| 25  | @Target(value = {ElementType.METHOD})                                |
| 26  | @Retention(value = RetentionPolicy.RUNTIME)                          |
| 27  | @interface MyAnnotation2{                                            |
| 28  | //参数类型 , 参数名                                                  |
| 29  | String name() default "";                                            |
| 30  | int age() default 0;                                                 |
| 31  | int id() default -1; //String indexOf("abc") -1 , 不存在,找不到      |
| 32  |                                                                      |
| 33  | String[] schools() default {"西部开源","狂神说 Java"};               |
| 34  | }                                                                    |
| 35  |                                                                      |
| 36  |                                                                      |
| 37  | @Target(value = {ElementType.METHOD})                                |
| 38  | @Retention(value = RetentionPolicy.RUNTIME)                          |
| 39  | @interface MyAnnotation3{                                            |

| 40 |

} | // 参数类型 参数名称
String value(); |
| --- | --- | --- |
| 41 | | |
| 42 | | |

## 5、反射读取注解

1 package com.annotation; 2

1. import java.lang.annotation.\*;
1. import java.lang.reflect.Field; 5

6 //测试 ORM:对象关系映射
7
8 //使用反射读取注解信息三步:
9 // 1.定义注解 ,

1. // 2.在类中使用注解 ,
1. // 3. 使用反射获取注解 , 一般都是现成框架实现 , 我们手动实现
1. public class Test4 {
1. public static void main(String[] args) {
1. try {
1. //反射 , Class 可以获得类的全部信息 , 所有的东西
1. Class clazz = Class.forName("com.annotation.Student");
1. //获得这个类的注解
1. Annotation[] annotations = clazz.getAnnotations();
1. for (Annotation annotation:annotations){
1. System.out.println(annotation); 21 }

22

1.  //获得类的注解 value 的值
1.      TableKuang table = (TableKuang) clazz.getAnnotation(TableKuang.class);
1.  System.out.println(table.value()); 26
1.  //获得类指定注解的值
1.  Field name = clazz.getDeclaredField("name");
1.  FieldKuang fieldKuang = name.getAnnotation(FieldKuang.class);
1.  System.out.println(fieldKuang.columnName()+"--

> "+fieldKuang.type()
> 31 +"-->"+fieldKuang.length()); 32
> 33
> 34 //我们可以根据得到的类的信息 , 通过 JDBC 生成相关的 SQL 语句,执行就可以动态生成数据库表
> 35

1. } catch (ClassNotFoundException e) {
1. e.printStackTrace();
1. } catch (NoSuchFieldException e) {
1. e.printStackTrace(); 40 }

41 }
42 }
43

1. @TableKuang("db_student") //假设数据库表名为 db_student .
1. class Student{ 46
1. @FieldKuang(columnName = "db_id",type="int",length = 10)
1. private int id;
   | 49 | @FieldKuang(columnName = "db_name",type="varchar",length = 10) |
   | --- | --- |
   | 50 | private String name; |
   | 51 | @FieldKuang(columnName = "db_age",type="int",length = 3) |
   | 52 | private int age; |
   | 53 | |
   | 54 | public Student() { |
   | 55 | } |
   | 56 | |
   | 57 | public Student(int id, String name, int age) { |
   | 58 | this.id = id; |
   | 59 | this.name = name; |
   | 60 | this.age = age; |
   | 61 | } |
   | 62 | |
   | 63 | public int getId() { |
   | 64 | return id; |
   | 65 | } |
   | 66 | |
   | 67 | public void setId(int id) { |
   | 68 | this.id = id; |
   | 69 | } |
   | 70 | |
   | 71 | public String getName() { |
   | 72 | return name; |
   | 73 | } |
   | 74 | |
   | 75 | public void setName(String name) { |
   | 76 | this.name = name; |
   | 77 | } |
   | 78 | |
   | 79 | public int getAge() { |
   | 80 | return age; |
   | 81 | } |
   | 82 | |
   | 83 | public void setAge(int age) { |
   | 84 | this.age = age; |
   | 85 | } |
   | 86 | |
   | 87 | @Override |
   | 88 | public String toString() { |
   | 89 | return "Student{" + |
   | 90 | "id=" + id + |
   | 91 | ", name='" + name + '\'' + |
   | 92 | ", age=" + age + |
   | 93 | '}'; |
   | 94 | } |
   | 95 | } |
   | 96 | |
   | 97 | |
   | 98 | //表名注解 , 只有一个参数 , 建议使用 value 命名 |
   | 99 | @Target(value = {ElementType.TYPE}) |
   | 100 | @Retention(value = RetentionPolicy.RUNTIME) |
   | 101 | @interface TableKuang{ |
   | 102 | String value(); |
   | 103 | } |
   | 104 | |
   | 105 | //属性注解 |
   | 106 | @Target(value = {ElementType.FIELD}) //注意字段 |

| 107 | @Retention(value = RetentionPolicy.RUNTIME) |
| --- | ------------------------------------------- |
| 108 | @interface FieldKuang{                      |
| 109 | String columnName(); //列名                 |
| 110 | String type(); //类型                       |
| 111 | int length();//长度                         |
| 112 | }                                           |

# 反射机制 Reﬂection

## 1、静态 VS 动态语言

动态语言
是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的 函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自 身结构。
主要动态语言：Object-C、C#、JavaScript、PHP、Python 等。

//体现动态语言的代码 function test() {
var x = "var a=3;var b=5;alert(a+b)"; eval(x);
}
1
2
3
4
5

静态语言
与动态语言相对应的，运行时结构不可变的语言就是静态语言。如 Java、C、C++。
Java 不是动态语言，但 Java 可以称之为“准动态语言”。即 Java 有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java 的动态性让编程的时候更加灵活！

## 2、Java Reﬂection

Reﬂection（反射）是 Java 被视为动态语言的关键，反射机制允许程序在执行期借助于 Reﬂection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

| 1   | Class | c   | =   | Class.forName("java.lang.String") |
| --- | ----- | --- | --- | --------------------------------- |

加载完类之后，在堆内存的方法区中就产生了一个 Class 类型的对象（一个类只有一个 Class 对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子， 透过这个镜子看到类的结构，所以，我们形象的称之为：**反射**
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834315197-27496b86-3353-458e-9871-ea8236174444.jpeg#)
1
2
3
4
5
package com.reflection;
public class Test2 {
public static void main(String[] args) { try {

| 6   | //通过反射获取类的 Class                                       |
| --- | -------------------------------------------------------------- |
| 7   | //--->查看 JDK 帮助文档                                        |
| 8   | Class<?> c1 = Class.forName("com.reflection.User");            |
| 9   | //一个类被加载后 , 类的整个结构信息会被放到对应的 Class 对象中 |
| 10  | System.out.println(c1);                                        |
| 11  |                                                                |
| 12  | //一个类只对应一个 Class 对象                                  |
| 13  | Class<?> c2 = Class.forName("com.reflection.User");            |
| 14  | System.out.println(c1.hashCode());                             |
| 15  | System.out.println(c2.hashCode());                             |
| 16  |                                                                |
| 17  | } catch (ClassNotFoundException e) {                           |
| 18  | e.printStackTrace();                                           |
| 19  | }                                                              |
| 20  | }                                                              |
| 21  | }                                                              |
| 22  |                                                                |
| 23  | //1. 创建一个实体类                                            |
| 24  | class User{                                                    |
| 25  | private int id;                                                |
| 26  | private int age;                                               |
| 27  | private String name;                                           |
| 28  |                                                                |
| 29  | public User() {                                                |
| 30  | }                                                              |
| 31  |                                                                |
| 32  | public User(int id, int age, String name) {                    |
| 33  | this.id = id;                                                  |
| 34  | this.age = age;                                                |
| 35  | this.name = name;                                              |
| 36  | }                                                              |
| 37  |                                                                |
| 38  | public int getId() {                                           |
| 39  | return id;                                                     |
| 40  | }                                                              |
| 41  |                                                                |
| 42  | public void setId(int id) {                                    |
| 43  | this.id = id;                                                  |
| 44  | }                                                              |
| 45  |                                                                |
| 46  | public int getAge() {                                          |
| 47  | return age;                                                    |
| 48  | }                                                              |
| 49  |                                                                |
| 50  | public void setAge(int age) {                                  |
| 51  | this.age = age;                                                |
| 52  | }                                                              |
| 53  |                                                                |
| 54  | public String getName() {                                      |
| 55  | return name;                                                   |
| 56  | }                                                              |
| 57  |                                                                |
| 58  | public void setName(String name) {                             |
| 59  | this.name = name;                                              |
| 60  | }                                                              |
| 61  |                                                                |
| 62  | @Override                                                      |
| 63  | public String toString() {                                     |

| 64 |

} |

} | return "User{" +
"id=" + id +
", age=" + age + ", name=" + name + '}'; |
| --- | --- | --- | --- |
| 65 | | | |
| 66 | | | |
| 67 | | | |
| 68 | | | |
| 69 | | | |
| 70 | | | |

### Java 反射机制提供的功能

在运行时判断任意一个对象所属的类在运行时构造任意一个类的对象
在运行时判断任意一个类所具有的成员变量和方法在运行时获取泛型信息
在运行时调用任意一个对象的成员变量和方法在运行时处理注解
生成动态代理
......

### Java 反射优点和缺点

优点：可以实现动态创建对象和编译，体现出很大的灵活性 !
缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉 JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于 直接执行相同的操作。

## 3、反射相关的主要 API

java.lang.Class : 代表一个类 java.lang.reﬂect.Method : 代表类的方法 java.lang.reﬂect.Field : 代表类的成员变量 java.lang.reﬂect.Constructor : 代表类的构造器
.......

## 4、Class 类

在 Object 类中定义了以下的方法，此方法将被所有子类继承

| 1   | public | final | Class | getClass(); |
| --- | ------ | ----- | ----- | ----------- |

以上的方法返回值的类型是一个 Class 类，此类是 Java 反射的源头，实际上所谓反射从程序的运行结果来 看也很好理解，即：可以通过对象反射求出类的名称。

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834315714-5d8b37d7-c663-4371-8417-9828785f4372.jpeg#)

对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个 类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。
Class 本身也是一个类
Class 对象只能由系统建立对象
一个加载的类在 JVM 中只会有一个 Class 实例
一个 Class 对象对应的是一个加载到 JVM 中的一个.class 文件每个类的实例都会记得自己是由哪个 Class 实例所生成
通过 Class 可以完整地得到一个类中的所有被加载的结构
Class 类是 Reﬂection 的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 Class 对象

package com.reflection;

//测试各种类型获得 Class 对象的方式 public class Test3 {
public static void main(String[] args) throws ClassNotFoundException { Person person = new Student();

System.out.println("这个人是:"+person.name);

//获得 class 办法一:通过对象获得
Class clazz1 = person.getClass();

//获得 class 办法二:通过字符串获得(包名+类名)
Class clazz2 = Class.forName("com.reflection.Student");

//获得 class 办法三:通过类的静态成员 class 获得 Class clazz3 = Person.class;

//获得 class 办法四:只针对内置的基本数据类型 Class clazz4 = Integer.TYPE;

//获得父类类型
Class clazz5 = clazz2.getSuperclass();
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

| 24  |                               |
| --- | ----------------------------- |
| 25  | System.out.println(clazz1);   |
| 26  | System.out.println(clazz2);   |
| 27  | System.out.println(clazz3);   |
| 28  | System.out.println(clazz4);   |
| 29  | System.out.println(clazz5);   |
| 30  |                               |
| 31  | }                             |
| 32  | }                             |
| 33  |                               |
| 34  | class Person {                |
| 35  | public String name;           |
| 36  |                               |
| 37  | public Person() {             |
| 38  | }                             |
| 39  |                               |
| 40  | public Person(String name) {  |
| 41  | this.name = name;             |
| 42  | }                             |
| 43  |                               |
| 44  | @Override                     |
| 45  | public String toString() {    |
| 46  | return "Person{" +            |
| 47  | "name='" + name + '\'' +      |
| 48  | '}';                          |
| 49  | }                             |
| 50  | }                             |
| 51  |                               |
| 52  | class Student extends Person{ |
| 53  | public Student(){             |
| 54  | this.name = "学生";           |
| 55  | }                             |
| 56  | }                             |
| 57  |                               |
| 58  | class Teacher extends Person{ |
| 59  | public Teacher(){             |
| 60  | this.name = "老师";           |
| 61  | }                             |
| 62  | }                             |

### Class 类的常用方法

| **方法名**                       | **功能说明**                                |
| -------------------------------- | ------------------------------------------- |
| static ClassforName(String name) | 返回指定类名 name 的 Class 对象             |
| Object newInstance()             | 调用缺省构造函数，返回 Class 对象的一个实例 |

|
getName() | 返回此 Class 对象所表示的实体（类，接口，数组类或
void）的名称。 |
| Class getSuperClass() | 返回当前 Class 对象的父类的 Class 对象 |
| Class[] getinterfaces() | 获取当前 Class 对象的接口 |
| ClassLoader getClassLoader() | 返回该类的类加载器 |
| Constructor[] getConstructors() | 返回一个包含某些 Constructor 对象的数组 |
| Method getMothed(String name,Class.. T) | 返回一个 Method 对象，此对象的形参类型为 paramType |
| Field[] getDeclaredFields() | 返回 Field 对象的一个数组 |

**获取 Class 类的实例**

1. 若已知具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高。

| 1   | Class | clazz | =   | Person.class; |
| --- | ----- | ----- | --- | ------------- |

1. 已知某个类的实例，调用该实例的 getClass()方法获取 Class 对象

| 1   | Class | clazz | =   | person.getClass(); |
| --- | ----- | ----- | --- | ------------------ |

1. 已知一个类的全类名，且该类在类路径下，可通过 Class 类的静态方法 forName()获取，可能抛出 ClassNotFoundException

| 1   | Class | clazz | =   | Class.forName("demo01.Student"); |
| --- | ----- | ----- | --- | -------------------------------- |

1. 内置基本数据类型可以直接用类名.Type e）还可以利用 ClassLoader 我们之后讲解

### 哪些类型可以有 Class 对象？

class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。interface：接口
[]：数组 enum：枚举
annotation：注解@interface primitive type：基本数据类型
void

| 1   | package com.reflection;                  |
| --- | ---------------------------------------- |
| 2   |                                          |
| 3   | import java.lang.annotation.ElementType; |
| 4   |                                          |
| 5   | //演示 : 所有类型的 class                |

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
public class Test4 {
public static void main(String[] args) { Class c1 = Object.class;
Class c2 = Comparable.class; Class c3 = String[].class; Class c4 = int[][].class; Class c5 = ElementType.class; Class c6 = Override.class; Class c7 = Integer.class; Class c8 = void.class;
Class c9 = Class.class;
int[] a = new int[10]; int[] b = new int[100]; Class c10 = a.getClass(); Class c11 = b.getClass();

System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); System.out.println(c5); System.out.println(c6); System.out.println(c7); System.out.println(c8); System.out.println(c9); System.out.println(c10); System.out.println(c11);
//只要元素类型与维度一样,就是同一个 Class
System.out.println(c11==c10);
}
}

## 5、Java 内存分析

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834316108-26cc2d82-39c5-4cda-84af-0115ca7b34e4.jpeg#)

### 类的加载过程

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834316418-a47a5808-7433-4d38-b094-27f479f804ba.jpeg#)

**类的加载与 ClassLoader 的理解**
加载：
将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构， 然后生成一个代表这个类的 java.lang.Class 对象.
链接：将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程。
验证：确保加载的类信息符合 JVM 规范，没有安全方面的问题
准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。
解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 初始化：
执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造 器）。
当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。

### 什么时候会发生类初始化？

类的主动引用（一定会发生类的初始化）
当虚拟机启动，先初始化 main 方法所在的类
new 一个类的对象
调用类的静态成员（除了 ﬁnal 常量）和静态方法使用 java.lang.reﬂect 包的方法对类进行反射调用
当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类类的被动引用（不会发生类的初始化）
当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静 态变量，不会导致子类初始化
通过数组定义类引用，不会触发此类的初始化
引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）

### 类加载器的作用

类加载的作用：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区中类数据的访问入
口。
类缓存：标准的 JavaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过 JVM 垃圾回收机制可以回收这些 Class 对象
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834316765-6a51f17e-6379-4765-9220-5c085aad11de.jpeg#)
类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834317103-a0fee4ed-d72c-45fb-88fb-7033569fc89c.jpeg#)

## 6、创建运行时类的对象

通过反射获取运行时类的完整结构
Field、Method、Constructor、Superclass、Interface、Annotation
实现的全部接口所继承的父类全部的构造器全部的方法
全部的 Field 注解
。。。

### 小结

在实际的操作中，取得类的信息的操作代码，并不会经常开发。一定要熟悉 java.lang.reﬂect 包的作用，反射机制。

如何取得属性、方法、构造器的名称，修饰符等。

## 7、有了 Class 对象,能做什么?

创建类的对象：调用 Class 对象的 newInstance()方法 类必须有一个无参数的构造器。
类的构造器的访问权限需要足够
思考？难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器， 并将参数传递进去之后，才可以实例化操作。
步骤如下：
通过 Class 类的 getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器
向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。 通过 Constructor 实例化对象

### 调用指定的方法

通过反射，调用类中的方法，通过 Method 类完成。
通过 Class 类的 getMethod(String name,Class…parameterTypes)方法取得一个 Method 对象，并设置此方法操作时所需要的参数类型。
之后使用 Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的 obj 对象的参数信息。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834317399-2c5ed687-cba2-4ab0-9daf-40691be294ba.jpeg#)![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834317806-7247cd45-341c-40ed-af07-bf927012ec7c.jpeg#)

Object 对应原方法的返回值，若原方法无返回值，此时返回 null 若原方法若为静态方法，此时形参 Object obj 可为 null
若原方法形参列表为空，则 Object[] args 为 null
若原方法声明为 private,则需要在调用此 invoke()方法前，显式调用方法对象的
setAccessible(true)方法，将可访问 private 的方法。

## 8、setAccessible

Method 和 Field、Constructor 对象都有 setAccessible()方法。setAccessible 作用是启动和禁用访问安全检查的开关。
参数值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。
提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为 true。

使得原本无法访问的私有成员也可以访问
参数值为 false 则指示反射的对象应该实施 Java 语言访问检查

## 9、反射操作泛型

Java 采用泛型擦除的机制来引入泛型 , Java 中的泛型仅仅是给编译器 javac 使用的,确保数据的安全性和免去强制类型转换问题 , 但是 , 一旦编译完成 , 所有和泛型有关的类型全部擦除
为了通过反射操作这些类型 , Java 新增了 ParameterizedType , GenericArrayType , TypeVariable
和 WildcardType 几种类型来代表不能被归一到 Class 类中的类型但是又和原始类型齐名的类型. ParameterizedType : 表示一种参数化类型,比如 Collection
GenericArrayType : 表示一种元素类型是参数化类型或者类型变量的数组类型
TypeVariable : 是各种类型变量的公共父接口
WildcardType : 代表一种通配符类型表达式

### 反射操作注解

getAnnotations getAnnotation

## 10、练习:ORM

了解什么是 ORM ?
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834318207-76ac455f-df54-42c6-8fef-e507eeb5f4cf.png#)Object relationship Mapping --> 对象关系映射
类和表结构对应属性和字段对应对象和记录对应
要求 : 利用注解和反射完成类和表结构的映射关系
