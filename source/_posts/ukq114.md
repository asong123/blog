---
title: 31、Shiro
urlname: ukq114
date: '2021-07-09 20:44:58 +0800'
tags: []
categories: []
---

# 1、Shiro 简介

## 、什么是 Shiro？

Apache Shiro 是一个 Java 的安全（权限）框架。
Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。
Shiro 可以完成，认证，授权，加密，会话管理，Web 集成，缓存等。下载地址：[http://shiro.apac ](http://shiro.apac/)he.org/
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834700937-1bb023c0-681a-42bc-b3d7-b9b2cf766984.jpeg#)

## 、有哪些功能？

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834701474-3fc458bf-6d8c-4beb-8faa-c5f74534a2d3.jpeg#)

Authentication： 身 份 认 证 、 登 录 ， 验 证 用 户 是 不 是 拥 有 相 应 的 身 份 ； Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限，即判断用户能否进行什么操作，如：验证某个用户是否拥有某个角色，或者细粒度的验证某个用户对某个资源是否
具有某个权限！
Session Manager：会话管理，即用户登录后就是第一次会话，在没有退出之前，它的所有信息都在 会 话 中 ； 会 话 可 以 是 普 通 的 JavaSE 环 境 ， 也 可 以 是 Web 环 境 ； Cryptography：加密，保护数据的安全性，如密码加密存储到数据库中，而不是明文存储；
Web Support：Web 支 持 ， 可 以 非 常 容 易 的 集 成 到 Web 环 境 ； Caching：缓存，比如用户登录后，其用户信息，拥有的角色、权限不必每次去查，这样可以提高效率
Concurrency：Shiro 支持多线程应用的并发验证，即，如在一个线程中开启另一个线程，能把权限 自动的传播过去
Testing：提供测试支持；
Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；
Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了

1.  **、Shiro 架构（外部）**

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834701855-cc6f04ef-626d-4068-8c40-00d36fd8f798.jpeg#)从外部来看 Shiro，即从应用程序角度来观察如何使用 shiro 完成工作：
subject： 应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject，
Subject 代表了当前的用户，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是
Subject，如网络爬虫，机器人等，与 Subject 的所有交互都会委托给 SecurityManager；Subject 其 实是一个门面，SecurityManageer 才是实际的执行者
SecurityManager：安全管理器，即所有与安全有关的操作都会与 SercurityManager 交互，并且它管理着所有的 Subject，可以看出它是 Shiro 的核心，它负责与 Shiro 的其他组件进行交互，它相当于
SpringMVC 的 DispatcherServlet 的角色
Realm：Shiro 从 Realm 获取安全数据（如用户，角色，权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较，来确定用户的身份是否合法；也需要从
Realm 得到用户相应的角色、权限，进行验证用户的操作是否能够进行，可以把 Realm 看成 DataSource；

1.  **、Shiro 架构（内部）**

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834702226-72e0e47d-1796-40c6-a248-96e627afeba1.jpeg#)

Subject：任何可以与应用交互的 ‘用户’；
Security Manager：相当于 SpringMVC 中的 DispatcherServlet；是 Shiro 的心脏，所有具体的交互都通过 Security Manager 进行控制，它管理者所有的 Subject，且负责进行认证，授权，会话，及缓存的管理。
Authenticator：负责 Subject 认证，是一个扩展点，可以自定义实现；可以使用认证策略
（Authentication Strategy）， 即 什 么 情 况 下 算 用 户 认 证 通 过 了 ； Authorizer：授权器，即访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访 问 应 用 中 的 那 些 功 能 ； Realm：可以有一个或者多个的 realm，可以认为是安全实体数据源，即用于获取安全实体的，可以用 JDBC 实现，也可以是内存实现等等，由用户提供；所以一般在应用中都需要实现自己的 realm
SessionManager：管理 Session 生命周期的组件，而 Shiro 并不仅仅可以用在 Web 环境，也可以用在 普 通 的 JavaSE 环 境 中 CacheManager：缓存控制器，来管理如用户，角色，权限等缓存的；因为这些数据基本上很少改变，放到缓存中后可以提高访问的性能；
Cryptography：密码模块，Shiro 提高了一些常见的加密组件用于密码加密，解密等

**2、HelloWorld**

1.  **、快速实践**

查看官网文档：[http://shiro.apache.org/tutorial.html](http://shiro.apache.org/tutorial.html)
官方的 quickstart：[https://github.com/apache/shiro/tree/master/samples/quickstart/](https://github.com/apache/shiro/tree/master/samples/quickstart/)

1. 创建一个 maven 父工程，用于学习 Shiro，删掉不必要的东西
1. 创建一个普通的 Maven 子工程：shiro-01-helloworld
1. 根据官方文档，我们来导入 Shiro 的依赖

1. <dependencies>
1. <dependency>
1. <groupId>org.apache.shiro</groupId>
1. <artifactId>shiro-core</artifactId>
1. <version>1.4.1</version>
1. </dependency>
1. <!-- Shiro uses SLF4J for logging.	We'll use the 'simple' binding
1. in this example app. See [http://www.slf4j.org ](http://www.slf4j.org/)for more info. -

->

1. <dependency>
1. <groupId>org.slf4j</groupId>
1. <artifactId>slf4j-simple</artifactId>
1. <version>1.7.21</version>
1. <scope>test</scope>
1. </dependency>
1. <dependency>
1. <groupId>org.slf4j</groupId>
1. <artifactId>jcl-over-slf4j</artifactId>
1. <version>1.7.21</version>
1. <scope>test</scope>
1. </dependency>
1. </dependencies>

1. 编写 Shiro 配置

log4j.properties

| 1   | log4j.rootLogger=INFO, stdout                                     |
| --- | ----------------------------------------------------------------- |
| 2   |                                                                   |
| 3   | log4j.appender.stdout=org.apache.log4j.ConsoleAppender            |
| 4   | log4j.appender.stdout.layout=org.apache.log4j.PatternLayout       |
| 5   | log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n |
| 6   |                                                                   |
| 7   | # General Apache libraries                                        |
| 8   | log4j.logger.org.apache=WARN                                      |
| 9   |                                                                   |
| 10  | # Spring                                                          |
| 11  | log4j.logger.org.springframework=WARN                             |
| 12  |                                                                   |
| 13  | # Default Shiro logging                                           |
| 14  | log4j.logger.org.apache.shiro=INFO                                |
| 15  |                                                                   |
| 16  | # Disable verbose logging                                         |
| 17  | log4j.logger.org.apache.shiro.util.ThreadContext=WARN             |
| 18  | log4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN          |

shiro.ini

| 1   | # ---------------------------------------------------------------------- |
| --- | ------------------------------------------------------------------------ |
|     | -------                                                                  |
| 2   | # Users and their assigned roles                                         |
| 3   | #                                                                        |
| 4   | # Each line conforms to the format defined in the                        |

5 # org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions JavaDoc
6 # ----------------------------------------------------------------------

---

1. [users]
1. # user 'root' with password 'secret' and the 'admin' role
1. root = secret, admin
1. # user 'guest' with the password 'guest' and the 'guest' role
1. guest = guest, guest
1. # user 'presidentskroob' with password '12345' ("That's the same combination on
1. # my luggage!!!" ;)), and role 'president'
1. presidentskroob = 12345, president
1. # user 'darkhelmet' with password 'ludicrousspeed' and roles 'darklord' and 'schwartz'
1. darkhelmet = ludicrousspeed, darklord, schwartz
1. # user 'lonestarr' with password 'vespa' and roles 'goodguy' and 'schwartz'
1. lonestarr = vespa, goodguy, schwartz 19

## 20 # ----------------------------------------------------------------------

21 # Roles with assigned permissions 22 #

1. # Each line conforms to the format defined in the
1. # org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc

## 25 # ----------------------------------------------------------------------

1. [roles]
1. # 'admin' role has all permissions, indicated by the wildcard '\*'
1. admin = \*
1. # The 'schwartz' role can do anything (\*) with any lightsaber:
1. schwartz = lightsaber:\*
1. # The 'goodguy' role is allowed to 'drive' (action) the winnebago (type) with
1. # license plate 'eagle5' (instance specific id)
1. goodguy = winnebago:drive:eagle5

1. 编写我们的 QuickStrat

| 1 | import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.\*;
import org.apache.shiro.config.IniSecurityManagerFactory; import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.session.Session; import org.apache.shiro.subject.Subject; import org.apache.shiro.util.Factory; import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/\*\*

- Simple Quickstart application showing how to use Shiro's
  \*/
  public class Quickstart { |

| API. |
| ---- | --- | --- |
| 2    |     |     |
| 3    |     |     |
| 4    |     |     |
| 5    |     |     |
| 6    |     |     |
| 7    |     |     |
| 8    |     |     |
| 9    |     |     |
| 10   |     |     |
| 11   |     |     |
| 12   |     |     |
| 13   |     |     |
| 14   |     |     |
| 15   |     |     |
| 16   |     |     |

17 private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);
18
19
20 public static void main(String[] args) { 21

1.      // The easiest way to create a Shiro SecurityManager with configured
1.      // realms, users, roles and permissions is to use the simple INI config.
1.      // We'll do that by using a factory that can ingest a .ini file and
1.  // return a SecurityManager instance:

26

1.  // Use the shiro.ini file at the root of the classpath
1.      // (file: and url: prefixes load from files and urls respectively):
1.      Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiro.ini");
1.  SecurityManager securityManager = factory.getInstance(); 31
1.      // for this simple example quickstart, make the SecurityManager
1.      // accessible as a JVM singleton.	Most applications wouldn't do this
1.      // and instead rely on their container configuration or web.xml for
1.      // webapps.	That is outside the scope of this simple quickstart, so
1.      // we'll just do the bare minimum so you can continue to get a feel
1.  // for things.
1.  SecurityUtils.setSecurityManager(securityManager); 39

40 // Now that a simple Shiro environment is set up, let's see what you can do:
41

1.  // get the currently executing user:
1.  Subject currentUser = SecurityUtils.getSubject(); 44
1.      // Do some stuff with a Session (no need for a web or EJB container!!!)
1.  Session session = currentUser.getSession();
1.  session.setAttribute("someKey", "aValue");
1.  String value = (String) session.getAttribute("someKey");
1.  if (value.equals("aValue")) {
1.  log.info("Retrieved the correct value! [" + value + "]"); 51 }

52

1.      // let's login the current user so we can check against roles and permissions:
1.  if (!currentUser.isAuthenticated()) {
1.      UsernamePasswordToken token = new UsernamePasswordToken("lonestarr", "vespa");
1.  token.setRememberMe(true);
1.  try {
1.  currentUser.login(token);
1.  } catch (UnknownAccountException uae) {
1.      log.info("There is no user with username of " + token.getPrincipal());
1.  } catch (IncorrectCredentialsException ice) {
1.      log.info("Password for account " + token.getPrincipal() + " was incorrect!");
1.  } catch (LockedAccountException lae) {
1.      log.info("The account for username " + token.getPrincipal() + " is locked.	" +
1.      "Please contact your administrator to unlock it.");

66 }

1.      // ... catch more exceptions here (maybe custom ones specific to your application?
1.  catch (AuthenticationException ae) {
1.  //unexpected condition? error? 70 }

71 }
72

1.  //say who they are:
1.      //print their identifying principal (in this case, a username):
1.      log.info("User [" + currentUser.getPrincipal() + "] logged in successfully.");

76

1. //test a role:
1. if (currentUser.hasRole("schwartz")) {
1. log.info("May the Schwartz be with you!");
1. } else {
1. log.info("Hello, mere mortal."); 82 }

83

1.  //test a typed permission (not instance-level)
1.  if (currentUser.isPermitted("lightsaber:wield")) {
1.      log.info("You may use a lightsaber ring.	Use it wisely.");
1.  } else {
1.      log.info("Sorry, lightsaber rings are for schwartz masters only.");

89 }
90

1.  //a (very powerful) Instance Level permission:
1.  if (currentUser.isPermitted("winnebago:drive:eagle5")) {
1.      log.info("You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'.	" +
1.  "Here are the keys - have fun!");
1.  } else {
1.      log.info("Sorry, you aren't allowed to drive the 'eagle5' winnebago!");

97 }
98
99 //all done - log out!
100 currentUser.logout(); 101
102 System.exit(0);
103 }
104 }

1. 测试运行一下
1. 报错，则导入一下 的依赖

commons-logging

1. <!-- [https://mvnrepository.com/artifact/commons-logging/commons-logging](https://mvnrepository.com/artifact/commons-logging/commons-logging) -

->

1. <dependency>
1. <groupId>commons-logging</groupId>
1. <artifactId>commons-logging</artifactId>
1. <version>1.2</version>
1. </dependency> 7

1. 发现，执行完毕什么都没有，可能是 maven 依赖中的作用域问题，我们需要将 scope 作用域删掉， 默认是在 test，然后重启，那么我们的 quickstart 就结束了，默认的日志消息！

| 1   | [main] INFO org.apache.shiro.session.mgt.AbstractValidatingSessionManager |
| --- | ------------------------------------------------------------------------- |
|     | - Enabling session validation scheduler...                                |
| 2   | [main] INFO Quickstart - Retrieved the correct value! [aValue]            |
| 3   | [main] INFO Quickstart - User [lonestarr] logged in successfully.         |
| 4   | [main] INFO Quickstart - May the Schwartz be with you!                    |
| 5   | [main] INFO Quickstart - You may use a lightsaber ring. Use it wisely.    |
| 6   | [main] INFO Quickstart - You are permitted to 'drive' the winnebago with  |
|     | license plate (id) 'eagle5'. Here are the keys - have fun!                |

1. OK，开始解释！

   1. **、阅读代码**

1. 导入了一堆包！
1. 类的描述

| 1   | /\*\*                                                            |
| --- | ---------------------------------------------------------------- |
| 2   | \* Simple Quickstart application showing how to use Shiro's API. |
| 3   | \* 简单的快速启动应用程序，演示如何使用 Shiro 的 API。           |
| 4   | \*/                                                              |

1. 通过工厂模式创建 SecurityManager 的实例对象

| 1   | // The easiest way to create a Shiro SecurityManager with configured     |
| --- | ------------------------------------------------------------------------ |
| 2   | // realms, users, roles and permissions is to use the simple INI config. |
| 3   | // We'll do that by using a factory that can ingest a .ini file and      |
| 4   | // return a SecurityManager instance:                                    |
| 5   |                                                                          |
| 6   | // 使用类路径根目录下的 shiro.ini 文件                                   |
| 7   | // Use the shiro.ini file at the root of the classpath                   |
| 8   | // (file: and url: prefixes load from files and urls respectively):      |
| 9   | Factory<SecurityManager> factory = new                                   |
|     | IniSecurityManagerFactory("classpath:shiro.ini");                        |
| 10  | SecurityManager securityManager = factory.getInstance();                 |
| 11  |                                                                          |
| 12  | // for this simple example quickstart, make the SecurityManager          |
| 13  | // accessible as a JVM singleton. Most applications wouldn't do this     |
| 14  | // and instead rely on their container configuration or web.xml for      |
| 15  | // webapps. That is outside the scope of this simple quickstart, so      |
| 16  | // we'll just do the bare minimum so you can continue to get a feel      |
| 17  | // for things.                                                           |

| 18  | SecurityUtils.setSecurityManager(securityManager);                       |
| --- | ------------------------------------------------------------------------ |
| 19  |                                                                          |
| 20  | // 现在已经建立了一个简单的 Shiro 环境，让我们看看您可以做什么：         |
| 21  | // Now that a simple Shiro environment is set up, let's see what you can |
|     | do:                                                                      |

1. 获取当前的 Subject

| 1   | // get the currently executing user: 获取当前正在执行的用户 |
| --- | ----------------------------------------------------------- |
| 2   | Subject currentUser = SecurityUtils.getSubject();           |

1.  session 的操作

1.  // 用会话做一些事情（不需要 web 或 EJB 容器！!!)
1.  // Do some stuff with a Session (no need for a web or EJB container!!!)
1.  Session session = currentUser.getSession(); //获得 session
1.  session.setAttribute("someKey", "aValue"); //设置 Session 的值！
1.  String value = (String) session.getAttribute("someKey"); //从 session 中获取值
1.  if (value.equals("aValue")) { //判断 session 中是否存在这个值！
1.  log.info("==Retrieved the correct value! [" + value + "]"); 8 }

1.  用户认证功能

    1.  // 测试当前的用户是否已经被认证，即是否已经登录！
    1.  // let's login the current user so we can check against roles and permissions:
    1.  if (!currentUser.isAuthenticated()) { // isAuthenticated();是否认证
    1.  //将用户名和密码封装为 UsernamePasswordToken ；
    1.      UsernamePasswordToken token = new UsernamePasswordToken("lonestarr", "vespa");
    1.  token.setRememberMe(true); //记住我功能
    1.  try {
    1.  currentUser.login(token); //执行登录，可以登录成功的！
    1.  } catch (UnknownAccountException uae) { //如果没有指定的用户，则

UnknownAccountException 异常

1.      log.info("There is no user with username of " + token.getPrincipal());
1.  } catch (IncorrectCredentialsException ice) { //密码不对的异常！
1.      log.info("Password for account " + token.getPrincipal() + " was incorrect!");
1.  } catch (LockedAccountException lae) { //用户被锁定的异常
1.      log.info("The account for username " + token.getPrincipal() + " is locked.	" +
1.  "Please contact your administrator to unlock it."); 16 }
1.      // ... catch more exceptions here (maybe custom ones specific to your application?
1.  catch (AuthenticationException ae) { //认证异常，上面的异常都是它的子类
1.  //unexpected condition? error? 20 }

21 }
22

1. //说出他们是谁：
1. //say who they are:
1. //打印他们的标识主体（在本例中为用户名）：
1. //print their identifying principal (in this case, a username):

27 log.info("User [" + currentUser.getPrincipal() + "] logged in
successfully.");

1.  角色检查

1.  //test a role:
1.  //是否存在某一个角色
1.  if (currentUser.hasRole("schwartz")) {
1.  log.info("May the Schwartz be with you!");
1.  } else {
1.  log.info("Hello, mere mortal."); 7 }

1.  权限检查，粗粒度

1.  //测试用户是否具有某一个权限，行为
1.  //test a typed permission (not instance-level)
1.  if (currentUser.isPermitted("lightsaber:wield")) {
1.  log.info("You may use a lightsaber ring. Use it wisely.");
1.  } else {
1.  log.info("Sorry, lightsaber rings are for schwartz masters only."); 7 }

1.  权限检查，细粒度

1.  //测试用户是否具有某一个权限，行为，比上面更加的具体！
1.  //a (very powerful) Instance Level permission:
1.  if (currentUser.isPermitted("winnebago:drive:eagle5")) {
1.      log.info("You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'.	" +
1.  "Here are the keys - have fun!");
1.  } else {
1.      log.info("Sorry, you aren't allowed to drive the 'eagle5' winnebago!");

8 }

1. 注销操作

| 1   | //执行注销操作！      |
| --- | --------------------- |
| 2   | //all done - log out! |
| 3   | currentUser.logout(); |

1. 退出系统

System.exit(0);

OK，一个简单的 Shiro 程序体验，我们就在官方的带领下初步认识了！

**3、SpringBoot 集成**

1. **、准备工作**
1. 搭建一个 SpringBoot 项目、选中 web 模块即可！
1. 导入 Maven 依赖

thymeleaf

1. <!--thymeleaf模板-->
1. <dependency>
1. <groupId>org.thymeleaf</groupId>
1. <artifactId>thymeleaf-spring5</artifactId>
1. </dependency>
1. <dependency>
1. <groupId>org.thymeleaf.extras</groupId>
1. <artifactId>thymeleaf-extras-java8time</artifactId>
1. </dependency>

1. 编写一个页面 index.html

templates

1
2
3
4
5
6
7
8
9
10
11
12
13

<!DOCTYPE html>
<html lang="en"xmlns:th=["http://www.thymeleaf.org](http://www.thymeleaf.org/)">
<head>
<meta charset="UTF-8">
<title>Title</title>
</head>
<body>
<h1>首页</h1>
<p th:text="${msg}"></p>

</body>
</html>

1. 编写 controller 进行访问测试

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
package com.kuang.controller;
import org.springframework.stereotype.Controller; import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
@Controller
public class MyController {
@RequestMapping({"/","/index"}) public String toIndex(Model model){
model.addAttribute("msg","hello,Shiro"); return "index";
}
}

1. 测试访问首页！

   1. **、整合 Shiro**

回顾核心 API：

1. Subject：用户主体
1. SecurityManager：安全管理器
1. Realm：Shiro 连接数据

步骤：

1. 导入 Shiro 和 spring 整合的依赖

1. <dependency>
1. <groupId>org.apache.shiro</groupId>
1. <artifactId>shiro-spring</artifactId>
1. <version>1.4.1</version>
1. </dependency>

1. 编写 Shiro 配置类

config 包

1
2
3
4
5
6
7
8
9
10
11
12
13
14
package com.kuang.config;
import org.springframework.context.annotation.Configuration;
//声明为配置类
@Configuration
public class ShiroConfig {
//创建 ShiroFilterFactoryBean

//创建 DefaultWebSecurityManager

//创建 realm 对象
}

1. 我们倒着来，先想办法创建一个 对象

realm

1. 我们需要自定义一个 realm 的类，用来编写一些查询的方法，或者认证与授权的逻辑

1 package com.kuang.config; 2

1.  import org.apache.shiro.authc.AuthenticationException;
1.  import org.apache.shiro.authc.AuthenticationInfo;
1.  import org.apache.shiro.authc.AuthenticationToken;
1.  import org.apache.shiro.authz.AuthorizationInfo;
1.  import org.apache.shiro.realm.AuthorizingRealm;
1.  import org.apache.shiro.subject.PrincipalCollection; 9
1.  //自定义 Realm
1.  public class UserRealm extends AuthorizingRealm { 12
1.  //执行授权逻辑
1.  @Override
1.      protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
1.  System.out.println("执行了=>授权逻辑 PrincipalCollection");
1.  return null; 18 }

19

1.  //执行认证逻辑
1.  @Override
1.      protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
1.  System.out.println("执行了=>认证逻辑 AuthenticationToken");
1.  return null;
    | 25 | | } |
    | --- | --- | --- |
    | 26 | | |
    | 27 | } | |

1.  将这个类注册到我们的 Bean 中！

ShiroConfig

1
2
3
4
5
6
7
8
9
10
11
12
13
@Configuration
public class ShiroConfig {
//创建 ShiroFilterFactoryBean

//创建 DefaultWebSecurityManager

//创建 realm 对象
@Bean
public UserRealm userRealm(){ return new UserRealm();
}
}

1. 接下来我们该去创建 了

DefaultWebSecurityManager

1.  //创建 DefaultWebSecurityManager
1.  @Bean(name = "securityManager")
1.  public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier("userRealm")UserRealm userRealm){
1.      DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
1.  //关联 Realm
1.  securityManager.setRealm(userRealm);
1.  return securityManager; 8 }

1.  接下来我们该去创建 了

ShiroFilterFactoryBean

1
2
3

4

5
6
7
8
9
//创建 ShiroFilterFactoryBean
@Bean
public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier("securityManager")DefaultWebSecurity Manager securityManager){
ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
//设置安全管理器
shiroFilterFactoryBean.setSecurityManager(securityManager);
return shiroFilterFactoryBean;
}

最后上完整的配置：

| 1   | package com.kuang.config; |                                                         |
| --- | ------------------------- | ------------------------------------------------------- |
| 2   |                           |                                                         |
| 3   | import                    | org.apache.shiro.spring.web.ShiroFilterFactoryBean;     |
| 4   | import                    | org.apache.shiro.web.mgt.DefaultWebSecurityManager;     |
| 5   | import                    | org.springframework.beans.factory.annotation.Qualifier; |
| 6   | import                    | org.springframework.context.annotation.Bean;            |

7
8
9
10
11
12
13
14
15
import org.springframework.context.annotation.Configuration;
//声明为配置类
@Configuration
public class ShiroConfig {
16
17
18
19
20
21
22
23
24
25
//创建 ShiroFilterFactoryBean
@Bean
public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier("securityManager")DefaultWebSecurityMan ager securityManager){
ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
//设置安全管理器
shiroFilterFactoryBean.setSecurityManager(securityManager);

return shiroFilterFactoryBean;
}
26
27
28
29
30
31
32
33
34
35
36
37
//创建 DefaultWebSecurityManager
@Bean(name = "securityManager") public DefaultWebSecurityManager
getDefaultWebSecurityManager(@Qualifier("userRealm")UserRealm userRealm){ DefaultWebSecurityManager securityManager = new
DefaultWebSecurityManager();
// 关 联 Realm securityManager.setRealm(userRealm); return securityManager;
}

//创建 realm 对象
@Bean
public UserRealm userRealm(){ return new UserRealm();
}
}

1. **、页面拦截实现**
1. 编写两个页面、在 templates 目录下新建一个 user 目录

add.html update.html

| 1   | <body>       |
| --- | ------------ |
| 2   | <h1>add</h1> |
| 3   | </body>      |

| 1   | <body>          |
| --- | --------------- |
| 2   | <h1>update</h1> |
| 3   | </body>         |

1. 编写跳转到页面的 controller

1
2
3
4
5
6
7
8
9
@RequestMapping("/user/add") public String toAdd(){
return "user/add";
}
@RequestMapping("/user/update") public String toUpdate(){
return "user/update";
}

1. 在 index 页面上，增加跳转链接

1 <a th:href="@{/user/add}">add</a> | <a th:href="@{/user/update}">update</a>

1. 测试页面跳转是否 OK
1. 准备添加 Shiro 的内置过滤器

1
2

3

4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
@Bean
public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier("securityManager")DefaultWebSecurit yManager securityManager){
ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
//设置安全管理器
shiroFilterFactoryBean.setSecurityManager(securityManager);
/_
添加 Shiro 内置过滤器，常用的有如下过滤器：
anon： 无需认证就可以访问
authc： 必须认证才可以访问
user： 如果使用了记住我功能就可以直接访问
perms: 拥有某个资源权限才可以访问
role： 拥有某个角色权限才可以访问
_/
Map<String,String> filterMap = new LinkedHashMap<String, String>(); filterMap.put("/user/add","authc"); filterMap.put("/user/update","authc"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap);
return shiroFilterFactoryBean;
}

1. 再起启动测试，访问链接进行测试！拦截 OK！但是发现，点击后会跳转到一个 Login.jsp 页面，这个不是我们想要的效果，我们需要自己定义一个 Login 页面！
1. 我们编写一个自己的 Login 页面

1
2
3
4
5
6
7
8
9

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>登录页面</title>
</head>
<body>
<h1>登录页面</h1>

10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25

<hr>
<form action="">
<p>
用户名： <input type="text" name="username">
</p>
<p>
密码： <input type="text" name="password">
</p>
<p>
<input type="submit">
</p>
</form>

</body>
</html>

1. 编写跳转的 controller

1. @RequestMapping("/toLogin")
1. public String toLogin(){
1. return "login"; 4 }

1. 在 shiro 中配置一下！

ShiroFilterFactoryBean() 方法下面

| 1   | //修改到要跳转的 login 页面；                   |
| --- | ----------------------------------------------- |
| 2   | shiroFilterFactoryBean.setLoginUrl("/toLogin"); |

1. 再次测试，成功的跳转到了我们指定的 Login 页面！
1. 优化一下代码，我们这里的拦截可以使用 通配符来操作

| 1   | Map<String,String> filterMap = new LinkedHashMap<String, String>(); |
| --- | ------------------------------------------------------------------- |
| 2   | //filterMap.put("/user/add","authc");                               |
| 3   | //filterMap.put("/user/update","authc");                            |
| 4   | filterMap.put("/user/\*","authc");                                  |
| 5   | shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap);      |

1. 测试，完全 OK！

   1. **、登录认证操作**

1. 编写一个登录的 controller

1. //登录操作
1. @RequestMapping("/login")
1. public String login(String username,String password,Model model){
1. //使用 shiro，编写认证操作 5

6
7
8
9
10
//1. 获取 Subject
Subject subject = SecurityUtils.getSubject();
//2. 封装用户的数据
UsernamePasswordToken token = new UsernamePasswordToken(username, password);
//3. 执行登录的方法，只要没有异常就代表登录成功！

| 11 |

} | try {
subject.login(token); //登录成功！返回首页 return "index";
} catch (UnknownAccountException e) { //用户名不存在
model.addAttribute("msg","用户名不存在"); return "login";
} catch (IncorrectCredentialsException e) { //密码错误
model.addAttribute("msg","密码错误"); return "login";
} |
| --- | --- | --- |
| 12 | | |
| 13 | | |
| 14 | | |
| 15 | | |
| 16 | | |
| 17 | | |
| 18 | | |
| 19 | | |
| 20 | | |
| 21 | | |

1. 在前端修改对应的信息输出或者请求！ 登录页面增加一个 msg 提示：

1 <p style="color:red;" th:text="${msg}"></p>

给表单增加一个提交地址：

1. <form th:action="@{/login}">
1. <p>用户名： <input type="text" name="username"></p>
1. <p>密码： <input type="text" name="password"></p>
1. <p> <input type="submit"> </p>
1. </form>

1. ![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834702599-a3690620-2eaa-4369-aae8-3a6a7567940d.png#)理论，假设我们提交了表单，他会经过我们刚才编写的 UserRealm，我们提交测试一下

确实执行了我们的认证逻辑！

1. 在 UserRealm 中编写用户认证的判断逻辑

1
2
3

4
5
6
7
8
9
10
11
12
13
14
//执行认证逻辑
@Override
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
System.out.println("执行了=>认证逻辑 AuthenticationToken");
//假设数据库的用户名和密码
String name = "root"; String password = "123456";

//1.判断用户名
UsernamePasswordToken userToken = (UsernamePasswordToken)token; if (!userToken.getUsername().equals(name)){
//用户名不存在
return null; //shiro 底层就会抛出 UnknownAccountException

15
16
17
}
//2. 验证密码,我们可以使用一个 AuthenticationInfo 实现类
SimpleAuthenticationInfo
18
19
20
21
//
shiro 会自动帮我们验证！重点是第二个参数就是要验证的密码！
return new SimpleAuthenticationInfo("", password, "");
}

1. 测试一下！成功实现登录的认证操作！

   1. **、整合数据库**

1. 导入 Mybatis 相关依赖

1. <!-- 引入 myBatis，这是 MyBatis官方提供的适配 Spring Boot 的，而不是Spring

Boot 自己的-->

1. <dependency>
1. <groupId>org.mybatis.spring.boot</groupId>
1. <artifactId>mybatis-spring-boot-starter</artifactId>
1. <version>2.1.0</version>
1. </dependency>
1. <dependency>
1. <groupId>mysql</groupId>
1. <artifactId>mysql-connector-java</artifactId>
1. <scope>runtime</scope>
1. </dependency>
1. <!-- [https://mvnrepository.com/artifact/log4j/log4j](https://mvnrepository.com/artifact/log4j/log4j) -->
1. <dependency>
1. <groupId>log4j</groupId>
1. <artifactId>log4j</artifactId>
1. <version>1.2.17</version>
1. </dependency>
1. <!-- [https://mvnrepository.com/artifact/com.alibaba/druid](https://mvnrepository.com/artifact/com.alibaba/druid) -->
1. <dependency>
1. <groupId>com.alibaba</groupId>
1. <artifactId>druid</artifactId>
1. <version>1.1.12</version>
1. </dependency>

1. 编写配置文件-连接配置

application.yml

1
2
3
4
5
6

7
8
9
10
11
12
13
spring: datasource:
username: root password: 123456
#?serverTimezone=UTC 解决时区的报错
url: jdbc:mysql://localhost:3306/mybatis? serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8
driver-class-name: com.mysql.jdbc.Driver
type: com.alibaba.druid.pool.DruidDataSource
#Spring Boot 默认是不注入这些属性值的，需要自己绑定
#druid 数据源专有配置
initialSize: 5
minIdle: 5

14
15
16
17
18
19
20
21
22
23
24
25
maxActive: 20
maxWait: 60000
timeBetweenEvictionRunsMillis: 60000
minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true
testOnBorrow: false testOnReturn: false
poolPreparedStatements: true
26
27
28
29
30 #配置监控统计拦截的 filters，stat:监控统计、log4j：日志记录、wall：防御 sql 注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址：
[https://mvnrepository.com/artifact/log4j/log4j](https://mvnrepository.com/artifact/log4j/log4j) filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties:
druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500

1. 编写 mybatis 的配置

application.properties

| 1   | #别名配置                                        |
| --- | ------------------------------------------------ |
| 2   | mybatis.type-aliases-package=com.kuang.pojo      |
| 3   | mybatis.mapper-locations=classpath:mapper/\*.xml |

1. 编写实体类,引入 Lombok

1. <dependency>
1. <groupId>org.projectlombok</groupId>
1. <artifactId>lombok</artifactId>
1. <version>1.16.10</version>
1. </dependency>

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
package com.kuang.pojo;
import lombok.AllArgsConstructor; import lombok.Data;
import lombok.NoArgsConstructor;
@Data @AllArgsConstructor @NoArgsConstructor
public class User {
private int id;
private String name; private String pwd;
}

1. 编写 Mapper 接口

1
2
3
4
5
6
7
@Repository @Mapper
public interface UserMapper {
public User queryUserByName(String name);
}

1. 编写 Mapper 配置文件

1
2
3
4
5
6
7
8

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" ["http://mybatis.org/dtd/mybatis-3-mapper.dtd](http://mybatis.org/dtd/mybatis-3-mapper.dtd)">
<mapper namespace="com.kuang.mapper.UserMapper">
9
10
11
12
<select id="queryUserByName" parameterType="String" resultType="User">
select * from user where name = #{name}
</select>
</mapper>

1. 编写 UserService 层

1
2
3
4
public interface UserService {
public User queryUserByName(String name);
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
package com.kuang.service;
import com.kuang.mapper.UserMapper; import com.kuang.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
@Service
public class UserServiceImpl implements UserService {
@Autowired
UserMapper userMapper;

@Override
public User queryUserByName(String name) { return userMapper.queryUserByName(name);
}
}

1. 好了，一口气写了这些常规操作，可以去测试一下了，保证能够从数据库中查询出来

1
2
3
4
5
6
7
8
9
10
11
12
class Shiro02SpringbootApplicationTests {
@Autowired
UserServiceImpl userService;

@Test
void contextLoads() {
User user = userService.queryUserByName("root"); System.out.println(user);
}
}

完全 OK，成功查询出来了！

1. 改造 UserRealm，连接到数据库进行真实的操作！

1
2
3
4
5
6
7
8
9
//自定义 Realm
public class UserRealm extends AuthorizingRealm {
@Autowired
UserService userService;
10
11
12
13
14
15
16
//执行授权逻辑
@Override
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
System.out.println("执行了=>授权逻辑 PrincipalCollection");
return null;
}
17
18
19
20
21
22
//执行认证逻辑
@Override
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
System.out.println("执行了=>认证逻辑 AuthenticationToken");
UsernamePasswordToken userToken = (UsernamePasswordToken)token;
//真实连接数据库 User user =
userService.queryUserByName(userToken.getUsername());
23
24
25
26
27
28
29
30
31
32
if (user==null){
//用户名不存在
return null; //shiro 底层就会抛出 UnknownAccountException
}
return new SimpleAuthenticationInfo("", user.getPwd(), "");
}
}

1. 测试，现在查询都是从数据库查询的了！
   1. **思考：密码比对原理探究**

思考？这个 Shiro，是怎么帮我们实现密码自动比对的呢？
我们可以去 realm 的父类核心：
getCredentialsMatcher()
的父类
翻译过来：获取证书匹配器
AuthorizingRealm
AuthenticatingRealm
中找一个方法
我们去看这个接口 CredentialsMatcher 有很多的实现类，MD5 盐值加密
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834703106-681484d3-b357-49d9-ad5c-7c631440f14c.jpeg#)

我们的密码一般都不能使用明文保存？需要加密处理；思路分析

1. 如何把一个字符串加密为 MD5
1. 替换当前的 Realm 的 CredentialsMatcher 属性，直接使用并设置加密算法

Md5CredentialsMatcher

对象，

1.  **、用户授权操作**

使用 shiro 的过滤器来拦截请求即可！

1. 在

ShiroFilterFactoryBean

中添加一个过滤器

| 1   | //授权过滤器                                                       |
| --- | ------------------------------------------------------------------ |
| 2   | filterMap.put("/user/add","perms[user:add]"); //大家记得注意顺序！ |

1. ![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834703588-1412ed07-603c-4a18-be70-cbee8b00b567.jpeg#)我们再次启动测试一下，访问 add，发现以下错误！未授权错误！
1. 注意：当我们实现权限拦截后，shiro 会自动跳转到未授权的页面，但我们没有这个页面，所有 401 了
1. 配置一个未授权的提示的页面，增加一个 controller 提示

1. @RequestMapping("/noauth")
1. @ResponseBody
1. public String noAuth(){
1. return "未经授权不能访问此页面"; 5 }

然后再 中配置一个未授权的请求页面！
shiroFilterFactoryBean

1 shiroFilterFactoryBean.setUnauthorizedUrl("/noauth");

1. 测试，现在没有授权，可以跳转到我们指定的位置了！

   1. **、Shiro 授权**

在 UserRealm 中添加授权的逻辑，增加授权的字符串！

1
2
3

4
5
6
7
8
9
10
11
12
//执行授权逻辑
@Override
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
System.out.println("执行了=>授权逻辑 PrincipalCollection");
//给资源进行授权
SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
//添加资源的授权字符串 info.addStringPermission("user:add");

return info;
}

我们再次登录测试，发现登录的用户是可以进行访问 add 页面了！授权成功！
问题，我们现在完全是硬编码，无论是谁登录上来，都可以实现授权通过，但是真实的业务情况应该 是，每个用户拥有自己的一些权限，从而进行操作，所以说，权限，应该在用户的数据库中，正常的情 况下，应该数据库中是由一个权限表的，我们需要联表查询，但是这里为了大家操作理解方便一些，我 们直接在数据库表中增加一个字段来进行操作！
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834703977-c11b1d01-db5d-4133-b9e2-f242d295d921.png#)

1. 修改实体类，增加一个字段

1
2
3
4
5
6
7
8
9
10
11
@Data @AllArgsConstructor @NoArgsConstructor
public class User {
private int id; private String name; private String pwd;
private String perms;
}

1. 我们现在需要再自定义的授权认证中，获取登录的用户，从而实现动态认证授权操作！ 在用户登录授权的时候，将用户放在 Principal 中，改造下之前的代码

| 1   | return | new | SimpleAuthenticationInfo(user, | user.getPwd(), | ""); |
| --- | ------ | --- | ------------------------------ | -------------- | ---- |

然后再授权的地方获得这个用户，从而获得它的权限

1
2
3

4
5
6
7
8
9
10
11
12
13
14
15
16
//执行授权逻辑
@Override
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
System.out.println("执行了=>授权逻辑 PrincipalCollection");
//给资源进行授权
SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
//添加资源的授权字符串
//info.addStringPermission("user:add");

Subject subject = SecurityUtils.getSubject(); //获得当前对象 User currentUser = (User) subject.getPrincipal(); //拿到 User 对象

info.addStringPermission(currentUser.getPerms()); //设置权限 return info;
}

1. ![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834704261-7401b6ae-b2db-4060-aafe-ea2c6a1983eb.png#)我们给数据库中的用户增加一些权限
1. 在过滤器中，将 update 请求也进行权限拦截下

| 1   | //授权过滤器                                        |
| --- | --------------------------------------------------- |
| 2   | filterMap.put("/user/add","perms[user:add]");       |
| 3   | filterMap.put("/user/update","perms[user:update]"); |

1. 我们启动项目，登录不同的账户，进行测试一下！
1. 测试完美通过 OK！

   1. **、整合 Thymeleaf**

根据权限展示不同的前端页面

1. 添加 Maven 的依赖；

1 <!--
[https://mvnrepository.com/artifact/com.github.theborakompanioni/thymeleaf](https://mvnrepository.com/artifact/com.github.theborakompanioni/thymeleaf)
-extras-shiro -->

1. <dependency>
1. <groupId>com.github.theborakompanioni</groupId>
1. <artifactId>thymeleaf-extras-shiro</artifactId>
1. <version>2.0.0</version>
1. </dependency>

1. 配置一个 shiro 的 Dialect ，在 shiro 的配置中增加一个 Bean

1. //配置 ShiroDialect：方言，用于 thymeleaf 和 shiro 标签配合使用
1. @Bean
1. public ShiroDialect getShiroDialect(){
1. return new ShiroDialect(); 5 }

1. 修改前端的配置

1
2
3
4
5
6
7
8

<div shiro:hasPermission="user:add">
<a th:href="@{/user/add}">add</a>
</div>
<div shiro:hasPermission="user:update">
<a th:href="@{/user/update}">update</a>
</div>

1. 我们在去测试一下，可以发现，现在首页什么都没有了，因为我们没有登录，我们可以尝试登录下

，来判断这个 Shiro 的效果！登录后，可以看到不同的用户，有不同的效果，现在就已经接近完美了~！还不是最完美

1. 为了完美，我们在用户登录后应该把信息放到 Session 中，我们完善下！在执行认证逻辑时候，加入 session

| 1   | Subject subject = SecurityUtils.getSubject();        |
| --- | ---------------------------------------------------- |
| 2   | subject.getSession().setAttribute("loginUser",user); |

1. 前端从 session 中获取，然后用来判断是否显示登录

1. <p th:if="${session.loginUser==null}">
1. <a th:href="@{/toLogin}">登录</a> 3 </p>

1. 测试，效果完美~

   1. **、小结**

今天花了一天时间给大家讲解了 SpringSecurity 和 Shiro 两个安全的框架，主要是想让大家多一些思路，其实什么都不用，我们靠拦截器也可以实现这些功能对吧，但是可能需要花费大量的时间和代码， 还有就是 Bug 多，思考不全，而现在，我们两个框架都会使用了，也给大家对比的进行学习了，当然真 实的工作中，可能代码会更加的复杂。需要大家在工作中再多去练习和使用，将这些框架可以运用到自 己的项目中才是王道，不然学了也是白学对吧，几天就忘记了，没有什么用，关于底层的实现原理，也 希望大家下去可以多看源码学习，后面的学习中已经带大家看了很多源码了，希望大家能够自己多去总 结和吸收！
