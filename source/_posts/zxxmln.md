---
title: 11、JavaSE：多线程
urlname: zxxmln
date: '2021-07-09 20:37:15 +0800'
tags: []
categories: []
---

多线程详解
Java.Thread
讲师：秦疆
西安西部开源教育科技有限公司
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834237752-9dcfd100-9f0d-48cf-a593-5d6cb965dc94.jpeg#)

线程简介
线程实现（重点）
线程状态
目录
线程同步（重点）
线程通信问题
高级主题
CONTENTS
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834238231-3ce2b7d8-1fd2-4538-b313-1b38323bbd83.jpeg#)

线程简介
任务，进程，线程，多线程
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834238729-821d1aa6-6905-4a53-93d9-c39b7ec1265d.jpeg#)

多任务
u 现实中太多这样同时做多件事情的例子了，看起来是多个任务都在做，其实本质上我们
的大脑在同一时间依旧只做了一件事情。
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834239447-648cdb20-5fd0-4ff6-a36f-145397f7e5b6.jpeg#)

多线程
原来是一条路，慢慢因为车太多了，道路堵塞，效率极低。
为了提高使用的效率，能够充分利用道路，于是加了多个车道。
从此，妈妈再也不用担心道路堵塞了。
说说你们的多线程例子（生活，游戏，编程）
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834240166-895f7425-90d1-4e77-8a51-9eba074c39e6.jpeg#)

普通方法调用和多线程
主线程
主线程
调用 start()
调用 run()
子线程执行 run()方法
主线程执行 run()
t.run()
t.start()
多条执行路径，主线程和子
线程并行交替执行
只有主线程一条执行路径
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834240686-3710e8f9-06ce-440d-8806-187ec5fd9d29.jpeg#)

程序.进程.线程
在操作系统中运行的程序就是进程，比如你的
QQ，播放器，游戏，IDE 等等。。。。
声音
字幕
图像
进程
一个进程可以有多个线程，如视频中同时听声音，看图像，看弹幕，等等
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834241399-3c4eb306-e2ba-490a-8ed0-685e53ad8aaa.jpeg#)

Process 与 Thread
u 说起进程，就不得不说下程序。程序是指令和数据的有序集合，其本身没有任何运
行的含义，是一个静态的概念。
u 而进程则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单
位
u 通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没
有存在的意义。线程是 CPU 调度和执行的的单位。
注意：很多多线程是模拟出来的，真正的多线程是指有多个 cpu，即多核，如服务
器。如果是模拟出来的多线程，即在一个 cpu 的情况下，在同一个时间点，cpu 只能
执行一个代码，因为切换的很快，所以就有同时执行的错局。
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834241830-b10c712e-6d68-41c7-ad6a-317d86f82ab1.jpeg#)

本章核心概念
u 线程就是独立的执行路径；
u 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc 线程；
umain() 称之为主线程，为系统的入口，用于执行整个程序；
u 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与
操作系统紧密相关的，先后顺序是不能认为的干预的。
u 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制；
u 线程会带来额外的开销，如 cpu 调度时间，并发控制开销。
u 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834242406-570a0663-46c9-43f4-889b-73fdb3ca55a4.jpeg#)

线程创建
Thread 、Runnable、Callable
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834242796-df341b1f-9007-4c3d-af80-0cff2834a96f.jpeg#)

三种创建方式
继承 Thread 类（重点）
实现 Runnable 接口（重点）
实现 Callable 接口（了解）
Thread class
Runnable 接口
Callable 接口
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834243470-3439deee-2c14-4e47-b82a-7e7453bdfee7.jpeg#)

Thread
学习提示：查看 JDK 帮助文档
u 自定义线程类继承 Thread 类
u 重写 run()方法，编写线程执行体
u 创建线程对象，调用 start()方法启动线程
线程不一定立即执行，CPU 安排调度
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834243953-5d29cee2-54e1-4e38-9eed-e12fe33acac8.jpeg#)

案例：下载图片
第二步
第一步
第三步
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834244642-272cdd14-1b70-47c6-b6b6-37f085a7a254.jpeg#)

实现 Runnable
学习提示：查看 JDK 帮助文档
u 定义 MyRunnable 类实现 Runnable 接口
u 实现 run()方法，编写线程执行体
u 创建线程对象，调用 start()方法启动线程
推荐使用 Runnable 对象，因为 Java 单继承的局限性
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834245164-f442c484-edb3-4c0f-9d64-05e78645e5b0.jpeg#)

小结
u 继承 Thread 类
u 子类继承 Thread 类具备多线程能力
u 启动线程：子类对象. start()
u 不建议使用：避免 OOP 单继承局限性
u 实现 Runnable 接口
u 实现接口 Runnable 具有多线程能力
u 启动线程：传入目标对象+Thread 对象.start()
u 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834245624-08caa99e-ab5e-4e5c-aea1-272333b69a32.jpeg#)

案例：龟兔赛跑-Race

1. 首先来个赛道距离，然后要离终点越来越近
2. 判断比赛是否结束
3. 打印出胜利者
4. 龟兔赛跑开始
5. 故事中是乌龟赢的，兔子需要睡觉，所以我们来模拟兔子睡觉
6. 终于，乌龟赢得比赛
   版权：西部开源-秦疆 禁止售卖，盗版必究
   ![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834246060-224f5afa-03ce-4142-bf6b-0e59fe6ff022.jpeg#)

实现 Callable 接口（了解即可）

1. 实现 Callable 接口，需要返回值类型
2. 重写 call 方法，需要抛出异常
3. 创建目标对象
4. 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1);
5. 提交执行：Future<Boolean> result1 = ser.submit(t1);
6. 获取结果：boolean r1 = result1.get()
7. 关闭服务：ser.shutdownNow();
   演示：利用 callable 改造下载图片案例
   版权：西部开源-秦疆 禁止售卖，盗版必究
   ![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834246636-1d988df8-2308-41d7-ac3b-f52307011dfd.jpeg#)

静态代理
u 你：真实角色
u 婚庆公司：代理你，帮你处理结婚的事
u 结婚：实现都实现结婚接口即可
演示：实现静态代理对比 Thread
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834247143-16a4dcfc-b48e-405c-a1be-17a99dbf4a26.jpeg#)

Lamda 表达式
u λ 希腊字母表中排序第十一位的字母，英语名称为 Lambda
u 避免匿名内部类定义过多
u 其实质属于函数式编程的概念
（params）-> expression [ 表达式 ]
（params）-> statement [ 语句 ]
（params）-> { statements }
new Thread（()->System.out.println(“多线程学习。。。。”)）.start();
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834247667-f3e451f2-03d0-4a9e-9e25-6f4e5823e452.jpeg#)

Lamda 表达式
u 为什么要使用 lambda 表达式
u 避免匿名内部类定义过多
u 可以让你的代码看起来很简洁
u 去掉了一堆没有意义的代码，只留下核心的逻辑。
u 也许你会说，我看了 Lambda 表达式，不但不觉得简洁，反
而觉得更乱，看不懂了。那是因为我们还没有习惯，用的多
了，看习惯了，就好了。
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834248083-b648f1af-5801-4c3d-b8af-044b0a1dcf75.jpeg#)

Lamda 表达式
u 理解 Functional Interface（函数式接口）是学习 Java8 lambda 表达式的关键所在。
u 函数式接口的定义：
u 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。
public interface Runnable {
public abstract void run();
}
u 对于函数式接口，我们可以通过 lambda 表达式来创建该接口的对象。
演示：代码推导 lambda 表达式
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834248658-d424dd7c-31d0-4b69-89b9-0ea59a8ac1a1.jpeg#)

线程状态
五大状态
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834249106-47d0079a-76b2-4072-b706-e51b1f3e3b5f.jpeg#)

线程状态
创建状态
阻塞状态
死亡状态
等待用户输
阻塞解除
线程休眠等
线程自然执行完毕
外部干涉终止线程
启动线程
得 CP
就绪状态
运行状态
释放 CPU 资源
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834249705-fa0a1ce1-c50d-4106-aa51-af4fb58907d3.jpeg#)

线程状态
当调用 sleep，wait 或同步
锁定时，线程进入阻塞状态，
就是代码不往下执行，阻塞
事件解除后，重新进入就绪
状态，等待 cpu 调度执行。
阻塞状态
调度
当调用 start()方法，线程立即
进入就绪状态，但不意味着
立即调度执行
运行状态
就绪状态
dead
new
线程中断或者结束，一旦进
入死亡状态，就不能再次启
动
Thread t = new Thread()
线程对象一旦创建就进入到
了新生状态
进入运行状态，线程才真正
执行线程体的代码块
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834250183-cac731ae-dc0d-4608-8de8-2dd55fc3a87c.jpeg#)

线程方法
方 法
说 明
setPriority(int newPriority) 更改线程的优先级
在指定的毫秒数内让当前正在执行的线程休
static void sleep(long millis)
void join()
眠
等待该线程终止
暂停当前正在执行的线程对象，并执行其他
线程
static void yield()
void interrupt()
boolean isAlive()
中断线程，别用这个方式
测试线程是否处于活动状态
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834251254-d882dbba-37d6-469c-a852-80477244f75e.jpeg#)

停止线程
u 不推荐使用 JDK 提供的 stop()、
destroy()方法。【已废弃】
u 推荐线程自己停止下来
u 建议使用一个标志位进行终止变量
当 flag=false，则终止线程运行。
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834252016-24a1c13a-6682-4b6d-94fb-ca46d3443b54.jpeg#)

线程休眠
u sleep (时间) 指定当前线程阻塞的毫秒数；
u sleep 存在异常 InterruptedException；
u sleep 时间达到后线程进入就绪状态；
u sleep 可以模拟网络延时，倒计时等。
u 每一个对象都有一个锁，sleep 不会释放锁；
演示：计时
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834252718-ffa19589-0255-414c-9f2c-f47fed33833f.jpeg#)

线程礼让
u 礼让线程，让当前正在执行的线程暂停，但不阻塞
u 将线程从运行状态转为就绪状态
u 让 cpu 重新调度，礼让不一定成功！看 CPU 心情
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834253391-11cfad70-a7c6-4a9c-a72e-485e4e8ff22f.jpeg#)

Join
u Join 合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞
u 可以想象成插队
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834254034-0e90e64c-cff7-4d24-b006-4357e56ba5c7.jpeg#)

线程状态观测
u Thread.State
查看 JDK 帮助文档
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834254634-34dfd33b-2485-406c-8bde-7604fa417694.jpeg#)

线程优先级
u Java 提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度
器按照优先级决定应该调度哪个线程来执行。
u 线程的优先级用数字表示，范围从 1~10.
u Thread.MIN_PRIORITY = 1;
u Thread.MAX_PRIORITY = 10;
u Thread.NORM_PRIORITY = 5;
u 使用以下方式改变或获取优先级
u getPriority() . setPriority(int xxx)
优先级低只是意味着获得调度的
概率低.并不是优先级低就不会
被调用了.这都是看 CPU 的调度
优先级的设定建议在 start()调度前
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834255101-5562e197-5d7b-4f4a-9d1b-740c0c4a66c2.jpeg#)

守护(daemon)线程
u 线程分为用户线程和守护线程
u 虚拟机必须确保用户线程执行完毕
u 虚拟机不用等待守护线程执行完毕
u 如,后台记录操作日志,监控内存,垃圾回收等待..
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834255642-fb20daac-ef87-430b-beb4-434722536dd5.jpeg#)

线程同步
多个线程操作同一个资源
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834256128-a56fbe46-78f1-4db5-b61b-e10c1c328690.jpeg#)

并发
u 并发 : 同一个对象被多个线程同时操作
上万人同时抢 100 张票
两个银行同时取钱
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834256712-1df97f8a-ff44-4521-89e1-1d18f73e506d.jpeg#)

线程同步
u 现实生活中,我们会遇到 ” 同一个资源 , 多个人都想使用 ” 的问题 , 比如,食堂排队
打饭 , 每个人都想吃饭 , 最天然的解决办法就是 , 排队 . 一个个来.
u 处理多线程问题时 , 多个线程访问同一个对象 , 并且某些线程还想修改这个对象 .
这时候我们就需要线程同步 . 线程同步其实就是一种等待机制 , 多个需要同时访问
此对象的线程进入这个对象的等待池 形成队列, 等待前面线程使用完毕 , 下一个线
程再使用
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834257229-44a4c052-b91b-4c68-a8c2-3abeca4f95a4.jpeg#)

队列 和 锁
食堂大妈
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834257787-486debc9-9184-4dfd-95b6-e388183375fe.jpeg#)

线程同步
u 由于同一进程的多个线程共享同一块存储空间 , 在带来方便的同时,也带来了访问
冲突问题 , 为了保证数据在方法中被访问时的正确性 , 在访问时加入 锁机制
synchronized , 当一个线程获得对象的排它锁 , 独占资源 , 其他线程必须等待 ,
使用后释放锁即可 . 存在以下问题 :
u 一个线程持有锁会导致其他所有需要此锁的线程挂起 ;
u 在多线程竞争下 , 加锁 , 释放锁会导致比较多的上下文切换 和 调度延时,引
起性能问题 ;
u 如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致优先级倒
置 , 引起性能问题 .
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834258231-b94b9b5f-4146-4402-a3c6-793784c060c0.jpeg#)

同步方法
u 由于我们可以通过 private 关键字来保证数据对象只能被方法访问 , 所以我们只需
要针对方法提出一套机制 , 这套机制就是 synchronized 关键字 , 它包括两种用法 :
synchronized 方法 和 synchronized 块 .
同步方法 : public synchronized void method(int args) {}
u synchronized 方法控制对 “对象” 的访问 , 每个对象对应一把锁 , 每个
synchronized 方法都必须获得调用该方法的对象的锁才能执行 , 否则线程会阻塞 ,
方法一旦执行 , 就独占该锁 , 直到该方法返回才释放锁 , 后面被阻塞的线程才能获
得这个锁 , 继续执行
缺陷 : 若将一个大的方法申明为 synchronized 将会影响效率
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834258668-1c5ada24-58e6-4e73-b51a-780eb0fb8441.jpeg#)

同步方法弊端
u 方法里面需要修改的内容才需要锁,
锁的太多 , 浪费资源
只读
A 代码
修改
B 代码
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834259200-6f371f59-98fa-4806-a3b0-b0a70c1a87f5.jpeg#)

同步块
u 同步块 : synchronized (Obj ) { }
u Obj 称之为 同步监视器
u Obj 可以是任何对象 , 但是推荐使用共享资源作为同步监视器
u 同步方法中无需指定同步监视器 , 因为同步方法的同步监视器就是 this , 就是
这个对象本身 , 或者是 class [ 反射中讲解 ]
u 同步监视器的执行过程

1. 第一个线程访问 , 锁定同步监视器 , 执行其中代码 .
2. 第二个线程访问 , 发现同步监视器被锁定 , 无法访问 .
3. 第一个线程访问完毕 , 解锁同步监视器 .
4. 第二个线程访问, 发现同步监视器没有锁 , 然后锁定并访问
   版权：西部开源-秦疆 禁止售卖，盗版必究
   ![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834259692-179f5862-1edc-4af0-b07f-c89745b37dc5.jpeg#)

死锁
u 多个线程各自占有一些共享资源 , 并且互相等待其他线程占有的资源才能运行 , 而
导致两个或者多个线程都在等待对方释放资源 , 都停止执行的情形 . 某一个同步块
同时拥有 “ 两个以上对象的锁 ” 时 , 就可能会发生 “ 死锁 ” 的问题 .
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834260276-db97a1d5-7a06-4895-96d2-68fee9442c7c.jpeg#)

死锁避免方法
u 产生死锁的四个必要条件：

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件 : 进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件 : 若干进程之间形成一种头尾相接的循环等待资源关系。
   上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件
   就可以避免死锁发生
   版权：西部开源-秦疆 禁止售卖，盗版必究
   ![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834260782-09ce45f7-ffa2-4e9a-9fdb-54aeff06ff99.jpeg#)

Lock(锁)
u 从 JDK 5.0 开始，Java 提供了更强大的线程同步机制——通过显式定义同步锁对
象来实现同步。同步锁使用 Lock 对象充当
u java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。
锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开
始访问共享资源之前应先获得 Lock 对象
u ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语
义，在实现线程安全的控制中，比较常用的是 ReentrantLock，可以显式加锁、释
放锁。
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834261302-fc7f2fb1-d182-42f5-9082-2d4d8cd06121.jpeg#)

Lock(锁)
class A{
private final ReentrantLock lock = new ReenTrantLock();
public void m(){
lock.lock();
try{
//保证线程安全的代码;
}
finally{
lock.unlock();
//如果同步代码有异常，要将 unlock()写入 finally 语句块
}
}
}
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834261812-36c7534b-bee6-448d-9648-93ca1fdaf0fa.jpeg#)

synchronized 与 Lock 的对比
u Lock 是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized 是隐式锁，出了
作用域自动释放
u Lock 只有代码块锁，synchronized 有代码块锁和方法锁
u 使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展
性（提供更多的子类）
u 优先使用顺序：
u Lock > 同步代码块（已经进入了方法体，分配了相应资源）> 同步方法（在方
法体之外）
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834262344-df75b7dc-b93a-405a-a14c-45e01437364a.jpeg#)

线程协作
生产者消费者模式
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834262930-21f55697-5d67-4d4a-ba95-3c4de143e5b6.jpeg#)

线程通信
u 应用场景 : 生产者和消费者问题
u 假设仓库中只能存放一件产品 , 生产者将生产出来的产品放入仓库 , 消费者将
仓库中产品取走消费 .
u 如果仓库中没有产品 , 则生产者将产品放入仓库 , 否则停止生产并等待 , 直到
仓库中的产品被消费者取走为止 .
u 如果仓库中放有产品 , 则消费者可以将产品取走消费 , 否则停止消费并等待 ,
直到仓库中再次放入产品为止 .
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834263465-36a9a35e-191f-4b89-8925-59367611a929.jpeg#)

线程通信-分析
这是一个线程同步问题 , 生产者和消费者共享同一个资源 , 并且生产者和消费者之
间相互依赖 , 互为条件 .
u 对于生产者 , 没有生产产品之前 , 要通知消费者等待 . 而生产了产品之后 , 又
需要马上通知消费者消费
u 对于消费者 , 在消费之后 , 要通知生产者已经结束消费 , 需要生产新的产品
以供消费.
u 在生产者消费者问题中 , 仅有 synchronized 是不够的
u synchronized 可阻止并发更新同一个共享资源 , 实现了同步
u synchronized 不能用来实现不同线程之间的消息传递 (通信)
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834263977-f9696691-33cf-4788-9ea9-f110d52749e8.jpeg#)

线程通信
u Java 提供了几个方法解决线程之间的通信问题
方法名
作用
表示线程一直等待 , 直到其他线程通知 , 与 sleep 不同 ,
会释放锁
wait()
指定等待的毫秒数
wait(long timeout)
notify()
唤醒一个处于等待状态的线程
唤醒同一个对象上所有调用 wait()方法的线程 , 优先级
别高的线程优先调度
notifyAll()
注意 : 均是 Object 类的方法 , 都只能在同步方法或者同步代码块中
使用,否则会抛出异常 IllegalMonitorStateException
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834264488-47fd127d-df56-4146-889c-960ac4031252.jpeg#)

解决方式 1
并发协作模型 “ 生产者 / 消费者模式 ” --->管程法
u 生产者 : 负责生产数据的模块 (可能是方法 , 对象 , 线程 , 进程) ;
u 消费者 : 负责处理数据的模块 (可能是方法 , 对象 , 线程 , 进程) ;
u 缓冲区 : 消费者不能直接使用生产者的数据 , 他们之间有个 “ 缓冲区
生产者将生产好的数据放入缓冲区 , 消费者从缓冲区拿出数据
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834265035-d24bec9e-4c10-4cf9-8f15-ec4243f4907b.jpeg#)

解决方式 2
u 并发协作模型 “ 生产者 / 消费者模式 ” --->信号灯法
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834265512-a611e0fd-e4a1-48d7-98e0-93a15fbd43b0.jpeg#)

使用线程池
u 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影
响很大。
u 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。
可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。
u 好处：
u 提高响应速度（减少了创建新线程的时间）
u 降低资源消耗（重复利用线程池中线程，不需要每次都创建）
u 便于线程管理(....)
u corePoolSize：核心池的大小
u maximumPoolSize：最大线程数
u keepAliveTime：线程没有任务时最多保持多长时间后会终止
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834265992-c29de3ca-edf4-41fe-9c89-87e78382609c.jpeg#)

使用线程池
u JDK 5.0 起提供了线程池相关 API：ExecutorService 和 Executors
u ExecutorService：真正的线程池接口。常见子类 ThreadPoolExecutor
u void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执
行 Runnable
u <T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般又来执行
Callable
u void shutdown() ：关闭连接池
u Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池
版权：西部开源-秦疆 禁止售卖，盗版必究
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834266502-1a14a2a7-6e78-4546-9958-9af0af04deeb.jpeg#)
