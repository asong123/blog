---
title: 38、ElasticSearch
urlname: fpc997
date: '2021-07-09 20:48:45 +0800'
tags: []
categories: []
---

# 狂神聊 ElasticSearch

## 聊聊 Doug Cutting

1998 年 9 月 4 日，Google 公司在美国硅谷成立。正如大家所知，它是一家做搜索引擎起家的公司。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834929538-6524b072-1421-42d1-b736-23c2a22803e9.jpeg#)
无独有偶，一位名叫**Doug Cutting**的美国工程师，也迷上了搜索引擎。他做了一个用于文本搜索的函数库（姑且理解为软件的功能组件），命名为**Lucene**。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834930045-e4622bc3-8149-4e59-867e-024664c7438c.jpeg#)

Lucene 是用 JAVA 写成的，目标是为各种中小型应用软件加入全文检索功能。因为好用而且开源（代码公 开），非常受程序员们的欢迎。
早期的时候，这个项目被发布在 Doug Cutting 的个人网站和 SourceForge（一个开源软件网站）。后来，2001 年底，Lucene 成为**Apache 软件基金会**jakarta 项目的一个子项目。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834930576-76851487-61ad-4228-887c-5599a7c8daf2.jpeg#)

2004 年，Doug Cutting 再接再励，在 Lucene 的基础上，和 Apache 开源伙伴 Mike Cafarella 合作，开发了一款可以代替当时的主流搜索的开源搜索引擎，命名为**Nutch**。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834931089-2591f0a1-ed89-4b59-b14b-73483211bd7a.jpeg#)

Nutch 是一个建立在 Lucene 核心之上的网页搜索应用程序，可以下载下来直接使用。它在 Lucene 的基础 上加了网络爬虫和一些网页相关的功能，目的就是从一个简单的站内检索推广到全球网络的搜索上，就 像 Google 一样。
Nutch 在业界的影响力比 Lucene 更大。
大批网站采用了 Nutch 平台，大大降低了技术门槛，使低成本的普通计算机取代高价的 Web 服务器成为可能。甚至有一段时间，在硅谷有了一股用 Nutch 低成本创业的潮流。
随着时间的推移，无论是 Google 还是 Nutch，都面临搜索对象“体积”不断增大的问题。
尤其是 Google，作为互联网搜索引擎，需要存储大量的网页，并不断优化自己的搜索算法，提升搜索效率。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834931607-11a55f9c-c67c-4e68-a02e-b401a8fcc63b.jpeg#)

在这个过程中，Google 确实找到了不少好办法，并且无私地分享了出来。
2003 年，Google 发表了一篇技术学术论文，公开介绍了自己的谷歌文件系统**GFS（Google File**
**System）**。这是 Google 公司为了存储海量搜索数据而设计的专用文件系统。
第二年，也就是 2004 年，Doug Cutting 基于 Google 的 GFS 论文，实现了**分布式文件存储系统**，并将它命名为**NDFS（Nutch Distributed File System）**。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834932144-9eed9179-fe98-43b0-b939-48fc5d6144e0.jpeg#)

还是 2004 年，Google 又发表了一篇技术学术论文，介绍自己的**MapReduce 编程模型**。这个编程模型， 用于大规模数据集（大于 1TB）的并行分析运算。
第二年（2005 年），Doug Cutting 又基于 MapReduce，在 Nutch 搜索引擎实现了该功能。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834932524-cb1ba453-155d-4c7b-878c-f90934482a1b.jpeg#)

2006 年，当时依然很厉害的**Yahoo（雅虎）公司**，招安了 Doug Cutting。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834932803-628a22c3-4773-4bb4-b5e3-47fd323a9bcc.jpeg#)

加盟 Yahoo 之后，Doug Cutting 将 NDFS 和 MapReduce 进行了升级改造，并重新命名为
**Hadoop**（NDFS 也改名为 HDFS，Hadoop Distributed File System）。
这个，就是后来大名鼎鼎的大数据框架系统——Hadoop 的由来。而 Doug Cutting，则被人们称为

### Hadoop 之父。

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834933257-2615b986-8934-4c78-9fa0-adca2bc67c3f.jpeg#)
Hadoop 这个名字，实际上是 Doug Cutting 他儿子的黄色玩具大象的名字。所以，Hadoop 的 Logo，就是一只奔跑的黄色大象。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834933760-e6df7265-e629-44ef-803f-9d6b5914d446.jpeg#)

我们继续往下说。
还是 2006 年，Google 又发论文了。
这次，它们介绍了自己的**BigTable**。这是一种分布式数据存储系统，一种用来处理海量数据的非关系型 数据库。
Doug Cutting 当然没有放过，在自己的 hadoop 系统里面，引入了 BigTable，并命名为**HBase**。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834934418-8acde5aa-6718-43e1-8935-733e563c7238.jpeg#)

好吧，反正就是紧跟 Google 时代步伐，你出什么，我学什么。所以，Hadoop 的核心部分，基本上都有 Google 的影子。

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834934822-44f7791f-748e-411d-aadc-12602f3debde.jpeg#)

2008 年 1 月，Hadoop 成功上位，正式成为 Apache 基金会的顶级项目。
同年 2 月，Yahoo 宣布建成了一个拥有 1 万个内核的 Hadoop 集群，并将自己的搜索引擎产品部署在上面。
7 月，Hadoop 打破世界纪录，成为最快排序 1TB 数据的系统，用时 209 秒。

回到主题
Lucene 是一套信息检索工具包，并不包含搜索引擎系统，它包含了索引结构、读写索引工具、相关性工具、排序等功能，因此在使用 Lucene 时仍需要关注搜索引擎系统，例如数据获取、解析、分词等方面的东西。
为什么要给大家介绍下 Lucene 呢，因为我们学过的 solr 和 即将要学习的 elasticsearch 都是基于该工具包做的一些封装和增强罢了~
按照我的风格，一般在开始都会给大家聊聊历史！学习更重要的是培养编程的兴趣，而不是只会使用一 些基本的 API！
狂神的教学风格，免费，授人以渔，还有我那句每个课程都会说的至理名言：只要学不死，就往死里 学！

## ElasticSearch 概述

Elaticsearch，简称为 es， es 是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理 PB 级别的数据。es 也使用 Java 开发并使用
Lucene 作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的 RESTful API 来隐藏
Lucene 的复杂性，从而让全文搜索变得简单。
据国际权威的数据库产品评测机构 DB Engines 的统计，在 2016 年 1 月，ElasticSearch 已超过 Solr 等，成为排名第一的搜索引擎类应用。

历史
多年前，一个叫做 Shay Banon 的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，他便跟着也去了。在他找工作的过程中，为了给妻子构建一个食谱的搜索引擎，他开始构建一个早期版本的 Lucene。
直接基于 Lucene 工作会比较困难，所以 Shay 开始抽象 Lucene 代码以便 Java 程序员可以在应用中添加搜 索功能。他发布了他的第一个开源项目，叫做“Compass”。

后来 Shay 找到一份工作，这份工作处在高性能和内存数据网格的分布式环境中，因此高性能的、实时 的、分布式的搜索引擎也是理所当然需要的。然后他决定重写 Compass 库使其成为一个独立的服务叫做
Elasticsearch。
第一个公开版本出现在 2010 年 2 月，在那之后 Elasticsearch 已经成为 Github 上最受欢迎的项目之一，代 码贡献者超过 300 人。一家主营 Elasticsearch 的公司就此成立，他们一边提供商业支持一边开发新功
能，不过 Elasticsearch 将永远开源且对所有人可用。
Shay 的妻子依旧等待着她的食谱搜索……

### 谁在使用：

1、维基百科，类似百度百科，全文检索，高亮，搜索推荐/2
2、The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众 反馈（好，坏，热门，垃圾，鄙视，崇拜）
3、Stack Overﬂow（国外的程序异常讨论论坛），IT 问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应 的答案
4、GitHub（开源代码管理），搜索上千亿行代码
5、电商网站，检索商品
6、日志数据分析，logstash 采集日志，ES 进行复杂的数据分析，ELK 技术， elasticsearch+logstash+kibana
7、商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如 说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于 50 块钱，就通知我，我就去买
8、BI 系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近
3 年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，\*\*区，最近 3 年，每年消费 金额呈现 100%的增长，而且用户群体 85%是高级白领，开一个新商场。ES 执行数据分析和挖掘，
Kibana 进行数据可视化
9、国内：站内搜索（电商，招聘，门户，等等），IT 系统搜索（OA，CRM，ERP，等等），数据分析
（ES 热门
的一个使用场景）

## ES 和 solr 的差别

**Elasticsearch 简介**
Elasticsearch 是一个实时分布式搜索和分析引擎。它让你以前所未有的速度处理大数据成为可能。 它用于全文搜索、结构化搜索、分析以及将这三者混合使用：
维基百科使用 Elasticsearch 提供全文搜索并高亮关键字，以及输入实时搜索(search-asyou-type)和搜索纠错(did-you-mean)等搜索建议功能。
英国卫报使用 Elasticsearch 结合用户日志和社交网络数据提供给他们的编辑以实时的反馈，以便及时了 解公众对新发表的文章的回应。
StackOverﬂow 结合全文搜索与地理位置查询，以及 more-like-this 功能来找到相关的问题和答案。
Github 使用 Elasticsearch 检索 1300 亿行的代码。
但是 Elasticsearch 不仅用于大型企业，它还让像 DataDog 以及 Klout 这样的创业公司将最初的想法变成可

扩展的解决方案。Elasticsearch 可以在你的笔记本上运行，也可以在数以百计的服务器上处理 PB 级别的 数据 。
Elasticsearch 是一个基于 Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene 可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。
但是，Lucene 只是一个库。想要使用它，你必须使用 Java 来作为开发语言并将其直接集成到你的应用 中，更糟糕的是，Lucene 非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。
Elasticsearch 也使用 Java 开发并使用 Lucene 作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的 RESTful API 来隐藏 Lucene 的复杂性，从而让全文搜索变得简单。
**Solr 简介**
Solr 是 Apache 下的一个顶级开源项目，采用 Java 开发，它是基于 Lucene 的全文搜索服务器。Solr 提供了比 Lucene 更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化
Solr 可以独立运行，运行在 Jetty、Tomcat 等这些 Servlet 容器中，Solr 索引的实现方法很简单，用 POST
方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr 根据 xml 文档添加、删除、更新索引
。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回 Xml、json 等格式的查询结果进行解析，组织页面布局。Solr 不提供构建 UI 的功能，Solr 提供了一个管理界面，通过管理界面可以查询 Solr 的配置和运行情况。
solr 是基于 lucene 开发企业级搜索服务器，实际上就是封装了 lucene。
Solr 是一个独立的企业级搜索应用服务器，它对外提供类似于 Web-service 的 API 接口。用户可以通过
http 请求，向搜索引擎服务器提交一定格式的文件，生成索引；也可以通过提出查找请求，并得到返回 结果。
**Lucene 简介**
Lucene 是 apache 软件基金会 4 jakarta 项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引
引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene 的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索 引擎。Lucene 是一套用于全文检索和搜寻的开源程式库，由 Apache 软件基金会支持和提供。Lucene 提 供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的 免费开源工具。就其本身而言，Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。人们 经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。
Lucene 是一个全文检索引擎的架构。那什么是全文搜索引擎？
全文搜索引擎是名副其实的搜索引擎，国外具代表性的有 Google、Fast/AllTheWeb、AltaVista、
Inktomi、Teoma、WiseNut 等，国内著名的有百度（Baidu）。它们都是通过从互联网上提取的各个网 站的信息（以网页文字为主）而建立的数据库中，检索与用户查询条件匹配的相关记录，然后按一定的 排列顺序将结果返回给用户，因此他们是真正的搜索引擎。
从搜索结果来源的角度，全文搜索引擎又可细分为两种，一种是拥有自己的检索程序（Indexer），俗称
“蜘蛛”（Spider）程序或“机器人”（Robot）程序，并自建网页数据库，搜索结果直接从自身的数据库中 调用，如上面提到的 7 家引擎；另一种则是租用其他引擎的数据库，并按自定的格式排列搜索结果，如
Lycos 引擎。
**Elasticsearch 和 Solr 比较**
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834935279-fb52c172-8368-4a2e-96bf-10aed7c02876.png#)
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834935763-02337dbb-c2a7-4e22-ba2e-f390d557c3ef.png#)![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834936048-03801cde-ffda-4685-b459-d15dd3e54f46.jpeg#)

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834936395-d002fc8b-9530-4257-9bdb-50d3e3cb199a.jpeg#)

### ElasticSearch vs Solr 总结

1、es 基本是开箱即用，非常简单。Solr 安装略微复杂一丢丢！
2、Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能。
（3）Solr 支持更多格式的数据，比如 JSON、XML、CSV，而 Elasticsearch 仅支持 json 文件格式。
4、Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要 kibana 友好支撑
5、Solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用；
ES 建立索引快（即查询慢），即实时性查询快，用于 facebook 新浪等搜索。
Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。
6、Solr 比较成熟，有一个更大，更成熟的用户、开发和贡献者社区，而 Elasticsearch 相对开发维护者较少，更新太快，学习使用成本较高。

## ElasticSearch 安装

说明
我们需要下载和安装 ElasticSearch 的服务端和客户端！

### 注意：

ElasticSearch 是使用 java 开发的，且本版本的 es 需要的 jdk 版本要是 1.8 以上，所以安装 ElasticSearch 之前保证 JDK1.8+安装完毕，并正确的配置好 JDK 环境变量，否则启动 ElasticSearch 失败。

下载
ElasticSearch 的官方地址： [https://www.elastic.co/products/elasticsearch](https://www.elastic.co/products/elasticsearch)

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834937026-89e85d21-10ab-4557-ae26-feafc776fb0c.jpeg#)

官方下载地址：[https://www.elastic.co/cn/downloads/elasticsearch ](https://www.elastic.co/cn/downloads/elasticsearch)（很慢，可以翻墙下载！）
win 下载：[https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.1.zip](https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.1.zip)
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834937450-b7502f55-9c2f-49cb-94c1-a189620d35c0.jpeg#)

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834937906-22df0e57-3f25-4afb-aec2-26370cba7627.jpeg#)我这里已经帮大家下载好了，Linux 和 window 版的！
我们学习的话使用 window 或者 linux 都是可以的，对于我们 java 开发来说没有区别，只是连接的问题！
Windows 更加方便一点！所以我们前期都是用 Window 安装使用！后面我们再真正的安装到 Linux 服务器 上跑项目！

window 下安装使用
1、解压 window 的压缩包！

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834938447-b9896af2-90ed-458a-ab46-b1dca3a4ea44.jpeg#)

1. bin：启动文件
1. config：配置文件
1. log4j2.properties：日志配置文件
1. jvm.options：java 虚拟机的配置
1. elasticsearch.yml：es 的配置文件
1. data：索引数据目录
1. lib：相关类库 Jar 包
1. logs：日志目录
1. modules：功能模块
1. plugins：插件

2、双击 ElasticSearch 下的 bin 目录中的 elasticsearch.bat 启动，控制台显示的日志（等待启动完 毕！）：
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834939174-788c15fb-63d3-426f-904d-eeb644441ea2.png#)
3、然后在浏览器访问：http://localhost:9200 得到如下信息，说明安装成功了:

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834939518-f1ff1f45-4fde-45c2-b5e9-b19e38c344b9.png#)

安装 ES 的图形化界面插件客户端
注意：需要 NodeJS 的环境，我们讲解大前端进阶已经安装过了，没安装的需要安装！
Head 是 elasticsearch 的集群管理工具，可以用于数据的浏览查询！被托管在 github 上面！ 地址： [https://github.com/mobz/elasticsearch-head/](https://github.com/mobz/elasticsearch-head/)
1、下载 elasticsearch-head-master.zip
2、解压之后安装依赖！

1. cnpm install
1. npm run start

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834940066-259d9c15-6889-4a3d-a48e-6a150fdffbad.jpeg#)这将启动在端口 9100 上运行的本地 web 服务器，为 elasticsearch-head 服务！访问测试：

3、由于 ES 进程和客户端进程端口号不同，存在跨域问题，所以我们要在 ES 的配置文件中配置下跨域问题：
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834940534-96104a0a-6567-4134-b4b0-e4308057cb0b.png#)

1. # 跨域配置：
1. http.cors.enabled: true
1. http.cors.allow-origin: "\*"

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834940928-f288b32d-4ee7-4583-91be-8aa8200e10d5.png#)

4、启动 ElasticSearch，使用 head 工具进行连接测试！
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834941318-682de3eb-6a93-411d-8935-dcece7051e78.jpeg#)

了解 ELK
ELK 是 Elasticsearch、Logstash、Kibana 三大开源框架首字母大写简称。市面上也被成为 Elastic
Stack。其中 Elasticsearch 是一个基于 Lucene、分布式、通过 Restful 方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用 Elasticsearch 作为底层支持框架，可见 Elasticsearch 提供的搜索能力确实强大,市面上很多时候我们简称 Elasticsearch 为 es。Logstash 是 ELK 的中央数据流引擎，用于从不同目标（文件/数据存储/MQ）收集的不同格式数据，经过过滤后支持输出 到不同目的地（文件/MQ/redis/elasticsearch/kafka 等）。Kibana 可以将 elasticsearch 的数据通过友好 的页面展示出来，提供实时分析的功能。
市面上很多开发只要提到 ELK 能够一致说出它是一个日志分析架构技术栈总称，但实际上 ELK 不仅仅适用于日志分析，它还可以支持其它任何数据分析和收集的场景，日志分析和收集只是更具有代表性。并非 唯一性。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834941684-0f7a0e42-fb3b-468e-8afe-651be2a59855.jpeg#)

安装 Kibana
Kibana 是一个针对 Elasticsearch 的开源分析及可视化平台，用来搜索、查看交互存储在 Elasticsearch 索引中的数据。使用 Kibana，可以通过各种图表进行高级数据分析及展示。Kibana 让海量数据更容易理 解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示 Elasticsearch 查 询动态。设置 Kibana 非常简单。无需编码或者额外的基础架构，几分钟内就可以完成 Kibana 安装并启动
Elasticsearch 索引监测。
官网：[https://www.elastic.co/cn/kibana](https://www.elastic.co/cn/kibana)
1、下载 Kibana [https://www.elastic.co/cn/downloads/kibana ](https://www.elastic.co/cn/downloads/kibana)（注意版本对应关系）
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834942023-94f55213-c354-4264-be60-3f71cd15022b.jpeg#)

2、将压缩包解压即可（需要一些时间）！
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834942710-c6b611c7-1e84-4fad-b1ed-2bfe6bf3e220.png#)3、然后进入到 bin 目录下，启动服务就可以了（需要等待启动完成），ELK 基本上都是拆箱即用的
4、然后访问 IP:5601，kibana 会自动去访问 9200，也就是 elasticsearch 的端口号（当然 elasticsearch 这 个时候必须启动着），然后就可以使用 kibana 了！

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834943306-5b91b51a-f684-45a8-8b33-8a0300ba83fb.jpeg#)

5、现在是英文的，看着有些吃力，我们配置为中文的！ 中文包在
kibana\x-pack\plugins\translations\translations\zh-CN.json
只需要在配置文件 kibana.yml 中加入
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834943789-44a6deaa-802e-4eb1-a801-d4aa9686cc68.png#)
1 i18n.locale: "zh-CN"

6、重启查看效果！成功切换为中文的了！

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834944389-a27047f6-5391-4452-9213-6f5bf28b5703.jpeg#)

## ES 核心概念

概述
在前面的学习中，我们已经掌握了 es 是什么，同时也把 es 的服务已经安装启动，那么 es 是如何去存储数据，数据结构是什么，又是如何实现搜索的呢？我们先来聊聊 ElasticSearch 的相关概念吧！
集群，节点，索引，类型，文档，分片，映射是什么？

elasticsearch 是面向文档，关系行数据库 和 elasticsearch 客观的对比！

| **Relational DB** | **Elasticsearch** |
| ----------------- | ----------------- |
| 数据库(database)  | 索引(indices)     |
| 表(tables)        | types             |
| 行(rows)          | documents         |
| 字段(columns)     | ﬁelds             |

elasticsearch(集群)中可以包含多个索引(数据库)，每个索引中可以包含多个类型(表)，每个类型下又包 含多 个文档(行)，每个文档中又包含多个字段(列)。

### 物理设计：

elasticsearch 在后台把每个**索引划分成多个分片**，每分分片可以在集群中的不同服务器间迁移

### 逻辑设计：

一个索引类型中，包含多个文档，比如说文档 1，文档 2。 当我们索引一篇文档时，可以通过这样的一各顺序找到 它: 索引 ▷ 类型 ▷ 文档 ID ，通过这个组合我们就能索引到某个具体的文档。 注意:ID 不必是整数，实际上它是个字 符串。

文档

之前说 elasticsearch 是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch 中，文档有几个 重要属性 :
自我包含，一篇文档同时包含字段和对应的值，也就是同时包含 key:value！ 可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的！
灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用， 在 elasticsearch 中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个 新的字段。
尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类 型，可以是字符 串也可以是整形。因为 elasticsearch 会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在 elasticsearch 中，类型有时候也称为映射类型。

类型
类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。 类型中对于字段的定义称为映射， 比如 name 映 射为字符串类型。 我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段， 比如新增一个字段，那么 elasticsearch 是怎么做的呢?elasticsearch 会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch 就开始猜，如果这个值是 18，那么 elasticsearch 会认为它是整形。 但是 elasticsearch 也可能猜不对， 所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别 整什么幺蛾子。

索引
索引是映射类型的容器，elasticsearch 中的索引是一个非常大的文档集合。索引存储了映射类型的字段 和其他设置。 然后它们被存储到了各个分片上了。 我们来研究下分片是如何工作的。

### 物理设计 ：节点和分片 如何工作

一个集群至少有一个节点，而一个节点就是一个 elasricsearch 进程，节点可以有多个索引默认的，如果 你创建索引，那么索引将会有个 5 个分片 ( primary shard ,又称主分片 ) 构成的，每一个主分片会有一个副本 ( replica shard ,又称复制分片 )
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834944763-8c29e31d-639b-46f6-a19f-8f58eca809e5.png#)
上图是一个有 3 个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内，这样有利于某 个节点挂掉 了，数据也不至于丢失。 实际上，一个分片是一个 Lucene 索引，一个包含倒排索引的文件目录，倒排索引的结构使 得 elasticsearch 在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。 不过，等等，倒排索引是什 么鬼?

倒排索引

elasticsearch 使用的是一种称为倒排索引的结构，采用 Lucene 倒排索作为底层。这种结构适用于快速的 全文搜索， 一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。 例如，现在有两个文档， 每个文档包含如下内容：

| 1   | Study every | day, good good up | to forever   | #   | 文档 1 包含的内容 |
| --- | ----------- | ----------------- | ------------ | --- | ----------------- |
| 2   | To forever, | study every day,  | good good up | #   | 文档 2 包含的内容 |

为了创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者 tokens)，然后创建一个包含所有不重 复的词条的排序列表，然后列出每个词条出现在哪个文档 :

| **term** | **doc_1** | **doc_2** |
| -------- | --------- | --------- |
| Study    | √         | ×         |
| To       | x         | ×         |
| every    | √         | √         |
| forever  | √         | √         |
| day      | √         | √         |
| study    | ×         | √         |
| good     | √         | √         |
| every    | √         | √         |
| to       | √         | ×         |
| up       | √         | √         |

现在，我们试图搜索 to forever，只需要查看包含每个词条的文档

| **term** | **doc_1** | **doc_2** |
| -------- | --------- | --------- |
| to       | √         | ×         |
| forever  | √         | √         |
| total    | 2         | 1         |

两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，现在，这两个包含关键 字的文档都将返回。
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834945316-22b591c7-7c57-442a-a891-1ab534de017e.png#)再来看一个示例，比如我们通过博客标签来搜索博客文章。那么倒排索引列表就是这样的一个结构 :
如果要搜索含有 python 标签的文章，那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要 查看标签这一栏，然后获取相关的文章 ID 即可。

elasticsearch 的索引和 Lucene 的索引对比
在 elasticsearch 中， 索引 这个词被频繁使用，这就是术语的使用。 在 elasticsearch 中，索引被分为多个分片，每份 分片是一个 Lucene 的索引。所以一个 elasticsearch 索引是由多个 Lucene 索引组成的。别问为什么，谁让 elasticsearch 使用 Lucene 作为底层呢! 如无特指，说起索引都是指 elasticsearch 的索引。
接下来的一切操作都在 kibana 中 Dev Tools 下的 Console 里完成。基础操作！

# ES 基础操作

## IK 分词器插件

什么是 IK 分词器？
分词：即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把 数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个 词，比如 “我爱狂神” 会被分为"我","爱","狂","神"，这显然是不符合要求的，所以我们需要安装中文分词器 ik 来解决这个问题。
IK 提供了两个分词算法：ik_smart 和 ik_max_word，其中 ik_smart 为最少切分，ik_max_word 为最细粒度划分！一会我们测试！

安装步骤
1、下载 ik 分词器的包，Github 地址：[https://github.com/medcl/elasticsearch-analysis-ik/ ](https://github.com/medcl/elasticsearch-analysis-ik/)（版本要对应）
2、下载后解压，并将目录拷贝到 ElasticSearch 根目录下的 plugins 目录中。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834945810-24afde17-7e12-4391-a127-4748891aa3fc.jpeg#)
3、重新启动 ElasticSearch 服务，在启动过程中，你可以看到正在加载**"analysis-ik"**插件的提示信息， 服务启动后，在命令行运行 **elasticsearch-plugin list **命令，确认 ik 插件安装成功。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834946931-6b2a4642-d6bf-42b4-9d7e-bc0d5754a849.jpeg#)

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834947381-9c8d3e8a-6864-4eec-a22b-a18cb88b6200.jpeg#)
4、在 kibana 中测试 ik 分词器，并就相关分词结果和 icu 分词器进行对比。
**ik_max_word **: 细粒度分词，会穷尽一个语句中所有分词可能，测试！
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834947989-b734f8d6-c345-40f0-be29-3623afc3f8e0.jpeg#)
**ik_smart **: 粗粒度分词，优先匹配最长词，只有 1 个词！
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834948548-bacfd5ca-1b2f-4d59-b6da-934407741cab.jpeg#)

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834949023-9b843151-84cf-4673-b807-6eabfafd41a4.jpeg#)5、我们输入超级喜欢狂神说！发现狂神说被切分了
如果我们想让系统识别“狂神说”是一个词，需要编辑自定义词库。步骤：

1. 进入 elasticsearch/plugins/ik/conﬁg 目录
1. 新建一个 my.dic 文件，编辑内容：

1 狂神说

1. 修改 IKAnalyzer.cfg.xml（在 ik/conﬁg 目录下）

1. <properties>
1. <comment>IK Analyzer 扩展配置</comment>
1. <!-- 用户可以在这里配置自己的扩展字典 -->
1. <entry key="ext_dict">my.dic</entry>
1. <!-- 用户可以在这里配置自己的扩展停止词字典 -->
1. <entry key="ext_stopwords"></entry>
1. </properties>

修改完配置重新启动 elasticsearch，再次测试！ 发现监视了我们自己写的规则文件：

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834949656-ba7b8e8a-7a21-488e-8c96-5bf6f5f88778.jpeg#)
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834950048-6517160d-069f-47cd-9ab8-ed8236b0836f.jpeg#)再次测试，发现狂神说变成了一个词：
到了这里，我们就明白了分词器的基本规则和使用了！

## Rest 风格说明

一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交 互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。
基本 Rest 命令说明：

| **method** | **url 地址**                                      | **描述**                |
| ---------- | ------------------------------------------------- | ----------------------- |
| PUT        | localhost:9200/索引名称/类型名称/文档 id          | 创建文档（指定文档 id） |
| POST       | localhost:9200/索引名称/类型名称                  | 创建文档（随机文档 id） |
| POST       | localhost:9200/索引名称/类型名称/文档 id/\_update | 修改文档                |
| DELETE     | localhost:9200/索引名称/类型名称/文档 id          | 删除文档                |
| GET        | localhost:9200/索引名称/类型名称/文档 id          | 查询文档通过文档 id     |
| POST       | localhost:9200/索引名称/类型名称/\_search         | 查询所有数据            |

基础测试
1、首先我们浏览器 http://localhost:5601/ 进入 kibana 里的 Console 2、首先让我们在 Console 中输入 :

| 1 | // 命令解释
// PUT 创建命令 test1 索引
PUT /test1/type1/1
{
"name":"狂神说", // 属性
"age":16 // 属性
} |
type1 类型 |
1 |
id |
| --- | --- | --- | --- | --- |
| 2 | | | | |
| 3 | | | | |
| 4 | | | | |
| 5 | | | | |
| 6 | | | | |
| 7 | | | | |

返回结果 （是以 REST ful 风格返回的 ）：

1
2

3
4
5
6
7
8
9
10
11
12
13
14
15
16
// 警告信息：不支持在文档索引请求中指定类型
// 而是使用无类型的端点(/{index}/\_doc/{id}， /{index}/\_doc，或
/{index}/\_create/{id})。
{
"\_index" : "test1", // 索引
"\_type" : "type1",
"\_id" : "1",
"\_version" : 1,
// 类型
// id
// 版本
"result" : "created", // 操作类型
"\_shards" : {
"total" : 2,
"successful" : 1,
"failed" : 0
},
"\_seq_no" : 0,
"\_primary_term" : 1
// 分片信息
}

3、那么 name 这个字段用不用指定类型呢。毕竟我们关系型数据库 是需要指定类型的啊 !
字符串类型
[text ](https://www.elastic.co/guide/en/elasticsearch/reference/current/text.html)、 [keyword](https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html)
数值类型
[long, integer, short, byte, double, ﬂoat, half*ﬂoat, scaled*ﬂoat](https://www.elastic.co/guide/en/elasticsearch/reference/current/number.html)
日期类型[date](https://www.elastic.co/guide/en/elasticsearch/reference/current/date.html) te 布尔值类型[boolean](https://www.elastic.co/guide/en/elasticsearch/reference/current/boolean.html)
二进制类型
[binary](https://www.elastic.co/guide/en/elasticsearch/reference/current/binary.html)
等等......
4、指定字段类型

1 PUT /test2 2 {

1. "mappings": {
1. "properties": { 5 "name":{

6 "type": "text" 7 },
8 "age":{
9 "type": "long" 10 },

1. "birthday":{
1. "type": "date" 13 }

14
15
16
}
}
}

输出：

1
2
3
4
5
{
"acknowledged" : true, "shards_acknowledged" : true,
"index" : "test2"
}

5、查看一下索引字段

1 GET test2

输出：

| 1 | {

} |
"test2" : { "aliases" : { }, "mappings" : {
"properties" : { "age" : {
"type" : "long"
},
"birthday" : {
"type" : "date"
},
"name" : {
"type" : "text"
}
}
},
"settings" : {
"index" : {
"creation_date" : "1585384302712",
"number_of_shards" : "1",
"number_of_replicas" : "1",
"uuid" : "71TUZ84wRTW5P8lKeN4I4Q",
"version" : { "created" : "7060199"
},
"provided_name" : "test2"
}
}
} |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |
| 14 | | |
| 15 | | |
| 16 | | |
| 17 | | |
| 18 | | |
| 19 | | |
| 20 | | |
| 21 | | |
| 22 | | |
| 23 | | |
| 24 | | |
| 25 | | |
| 26 | | |
| 27 | | |
| 28 | | |
| 29 | | |
| 30 | | |

6、我们看上列中 字段类型是我自己定义的 那么 我们不定义类型 会是什么情况呢？

| 1   | PUT /test3/\_doc/1   |
| --- | -------------------- |
| 2   | {                    |
| 3   | "name":"狂神说",     |
| 4   | "age":13,            |
| 5   | "birth":"1997-01-05" |
| 6   | }                    |
| 7   | # 输出               |

| 8 | {

} |
"\_index" : "test3",
"\_type" : "\_doc",
"\_id" : "1",
"\_version" : 1, "result" : "created", "\_shards" : {
"total" : 2,
"successful" : 1,
"failed" : 0
},
"\_seq_no" : 0,
"\_primary_term" : 1 |
| --- | --- | --- |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |
| 14 | | |
| 15 | | |
| 16 | | |
| 17 | | |
| 18 | | |
| 19 | | |
| 20 | | |
| 21 | | |
| 22 | | |

查看一下 test3 索引：

1 GET test3

返回结果：

| 1 | {

} |
"test3" : { "aliases" : { }, "mappings" : {
"properties" : { "age" : {
"type" : "long"
},
"birth" : {
"type" : "date"
},
"name" : {
"type" : "text", "fields" : {
"keyword" : {
"type" : "keyword", "ignore_above" : 256
}
}
}
}
},
"settings" : {
"index" : {
"creation_date" : "1585384497051",
"number_of_shards" : "1",
"number_of_replicas" : "1",
"uuid" : "xESBKF1XTpCAZOgMqBNUbA",
"version" : { "created" : "7060199"
},
"provided_name" : "test3"
}
}
} |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |
| 14 | | |
| 15 | | |
| 16 | | |
| 17 | | |
| 18 | | |
| 19 | | |
| 20 | | |
| 21 | | |
| 22 | | |
| 23 | | |
| 24 | | |
| 25 | | |
| 26 | | |
| 27 | | |
| 28 | | |
| 29 | | |
| 30 | | |
| 31 | | |
| 32 | | |
| 33 | | |
| 34 | | |
| 35 | | |
| 36 | | |

我们看上列没有给字段指定类型那么 es 就会默认给我配置字段类型！ 对比关系型数据库 ：
PUT test1/type1/1 ： 索引 test1 相当于关系型数据库的库，类型 type1 就相当于表 ，1 代表数据中的主键 id
这里需要补充的是 ，在 elastisearch5 版本前，一个索引下可以创建多个类型，但是在 elastisearch5 后， 一个索引只能对应一个类型，而 id 相当于关系型数据库的主键 id 若果不指定就会默认生成一个 20 位的
uuid，属性相当关系型数据库的 column(列)。
而结果中的 result 则是操作类型，现在是 created ，表示第一次创建。如果再次点击执行该命令那么
result 则会是 updated ，我们细心则会发现 \_version 开始是 1，现在你每点击一次就会增加一次。表示第几次更改。
7、我们在来学一条命令 (elasticsearch 中的索引的情况) ：

1 GET \_cat/indices?v

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834950603-9d155eb1-ca21-4eaf-98a0-89dd1e3b74af.jpeg#)返回结果：查看我们所有索引的状态健康情况 分片，数据储存大小等等。
8、那么怎么删除一条索引呢(库)呢?

1 DELETE /test1

返回：

1
2
3
{
"acknowledged" : true # 表示删除成功！
}

## 增删改查命令

创建数据 PUT
第一条数据：

1 PUT /kuangshen/user/1 2 {
3 "name":"狂神说",
4 "age":18,
5 "desc":"一顿操作猛如虎，一看工资 2500", 6 "tags":["直男","技术宅","温暖"]
7 }

第二条数据 :

1 PUT /kuangshen/user/2 2 {
3 "name":"张三",
4 "age":3,
5 "desc":"法外狂徒",
6 "tags":["渣男","旅游","交友"]
7 }

第三条数据：

1 PUT /kuangshen/user/3 2 {
3 "name":"李四",
4 "age":30,
5 "desc":"mmp，不知道怎么形容", 6 "tags":["靓女","旅游","唱歌"] 7 }

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834951143-afca81e7-2f85-43a1-8d6b-4ec3233dec0e.jpeg#)查看下数据：

### 注意 ⚠：当执行 命令时，如果数据不存在，则新增该条数据，如果数据存在则修改该条数据。

咱们通过 GET 命令查询一下 :

1 GET kuangshen/user/1

返回结果：

| 1 | {

} |
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "1",
"\_version" : 1,
"\_seq_no" : 0,
"\_primary_term" : 1, "found" : true,
"\_source" : { "name" : "狂神说", "age" : 18,
"desc" : "一顿操作猛如虎，一看工资 2500", "tags" : [
"直男",
"技术宅",
"温暖"
]
} |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |
| 14 | | |
| 15 | | |
| 16 | | |
| 17 | | |
| 18 | | |
| 19 | | |

如果你想更新数据 可以覆盖这条数据 :

1 PUT /kuangshen/user/1 2 {
3 "name":"狂神说 Java",
4 "age":18,
5 "desc":"一顿操作猛如虎，一看工资 2.5", 6 "tags":["直男","技术宅","温暖"]
7 }

返回结果：

| 1 | {

} |
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "1",
"\_version" : 2, "result" : "updated", "\_shards" : {
"total" : 2,
"successful" : 1,
"failed" : 0
},
"\_seq_no" : 3,
"\_primary_term" : 1 |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |
| 14 | | |

已经修改了 那么 **PUT **可以更新数据但是。**麻烦的是 原数据你还要重写一遍要 这不符合我们规矩**。

更新数据 POST
我们使用 POST 命令，在 id 后面跟 **\_update **，要修改的内容放到 **doc **文档(属性)中即可。

1 POST /kuangshen/user/1/\_update 2 {
3 "doc":{

1. "name":"狂神说 Java",
1. "desc":"关注狂神公众号每日更新文章哦" 6 }

7 }

返回结果：

| 1 | {

} |
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "1",
"\_version" : 3, "result" : "updated", "\_shards" : {
"total" : 2,
"successful" : 1,
"failed" : 0
},
"\_seq_no" : 4,
"\_primary_term" : 1 |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |
| 14 | | |

条件查询\_search?q=
简单的查询，我们上面已经不知不觉的使用熟悉了：

1 GET kuangshen/user/1

我们来学习下条件查询 \_search?q=

1 GET kuangshen/user/\_search?q=name:狂神说

通过 \_serarch?q=name:狂神说 查询条件是 name 属性有狂神说的那些数据。

### 别忘 了 \_search 和 from 属性中间的分隔符 ? 。

返回结果：

| 1 | {

} |
"took" : 16, "timed_out" : false, "\_shards" : {
"total" : 1,
"successful" : 1,
"skipped" : 0,
"failed" : 0
},
"hits" : {
"total" : {
"value" : 1, # 一共 1 条数据
"relation" : "eq"
},
"max_score" : 1.4229509, "hits" : [
{
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "1",
"\_score" : 1.4229509, "\_source" : {
"name" : "狂神说 Java",
"age" : 18,
"desc" : "关注狂神公众号每日更新文章哦", "tags" : [
"直男",
"技术宅",
"温暖"
]
}
}
]
} |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |
| 14 | | |
| 15 | | |
| 16 | | |
| 17 | | |
| 18 | | |
| 19 | | |
| 20 | | |
| 21 | | |
| 22 | | |
| 23 | | |
| 24 | | |
| 25 | | |
| 26 | | |
| 27 | | |
| 28 | | |
| 29 | | |
| 30 | | |
| 31 | | |
| 32 | | |
| 33 | | |
| 34 | | |
| 35 | | |

我们看一下结果 返回并不是 数据本身，是给我们了一个 **hits **，还有 \_score 得分，就是根据算法算出和查询条件匹配度高得分就搞。

构建查询

1 GET kuangshen/user/\_search 2 {

1. "query":{
1. "match":{
1. "name": "狂神" 6 }

7 }
8 }

上例，查询条件是一步步构建出来的，将查询条件添加到 match 中即可。返回结果还是一样的：

| 1 | {

} |
"took" : 0, "timed_out" : false, "\_shards" : {
"total" : 1,
"successful" : 1,
"skipped" : 0,
"failed" : 0
},
"hits" : {
"total" : {
"value" : 1,
"relation" : "eq"
},
"max_score" : 1.6285465, "hits" : [
{
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "1",
"\_score" : 1.6285465, "\_source" : {
"name" : "狂神说 Java",
"age" : 18,
"desc" : "关注狂神公众号每日更新文章哦", "tags" : [
"直男",
"技术宅",
"温暖"
]
}
}
]
} |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |
| 14 | | |
| 15 | | |
| 16 | | |
| 17 | | |
| 18 | | |
| 19 | | |
| 20 | | |
| 21 | | |
| 22 | | |
| 23 | | |
| 24 | | |
| 25 | | |
| 26 | | |
| 27 | | |
| 28 | | |
| 29 | | |
| 30 | | |
| 31 | | |
| 32 | | |
| 33 | | |
| 34 | | |
| 35 | | |

除此之外，我们还可以查询全部:

1 GET kuangshen/user/\_search #这是一个查询但是没有条件

1 GET kuangshen/user/\_search 2 {

1. "query":{
1. "match_all": {} 5 }

6 }

### match_all 的值为空，表示没有查询条件，就像 select \* from table_name 一样。

返回结果：全部查询出来了！
如果有个需求**，我们仅是需要查看 name 和 desc 两个属性**，其他的不要怎么办?

1 GET kuangshen/user/\_search 2 {

1. "query":{
1. "match_all": {} 5 },

6 "\_source": ["name","desc"]
7 }

如上例所示，在查询中，通过 \_source 来控制仅返回 name 和 age 属性。

| 1 | { |
"took" : 1, "timed_out" : false, "\_shards" : {
"total" : 1,
"successful" : 1,
"skipped" : 0,
"failed" : 0
},
"hits" : {
"total" : {
"value" : 3,
"relation" : "eq"
},
"max_score" : 1.0,
"hits" : [
{
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "2",
"\_score" : 1.0,
"\_source" : { "name" : "张三",
"desc" : "法外狂徒"
}
},
{
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "3",
"\_score" : 1.0,
"\_source" : { "name" : "李四",
"desc" : "mmp，不知道怎么形容"
} |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |
| 14 | | |
| 15 | | |
| 16 | | |
| 17 | | |
| 18 | | |
| 19 | | |
| 20 | | |
| 21 | | |
| 22 | | |
| 23 | | |
| 24 | | |
| 25 | | |
| 26 | | |
| 27 | | |
| 28 | | |
| 29 | | |
| 30 | | |
| 31 | | |
| 32 | | |
| 33 | | |
| 34 | | |
| 35 | | |

| 36 |

} |

} |

] | },
{
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "1",
"\_score" : 1.0,
"\_source" : {
"name" : "狂神说 Java",
"desc" : "关注狂神公众号每日更新文章哦"
}
} |
| --- | --- | --- | --- | --- |
| 37 | | | | |
| 38 | | | | |
| 39 | | | | |
| 40 | | | | |
| 41 | | | | |
| 42 | | | | |
| 43 | | | | |
| 44 | | | | |
| 45 | | | | |
| 46 | | | | |
| 47 | | | | |
| 48 | | | | |
| 49 | | | | |

一般的，我们推荐使用构建查询，以后在与程序交互时的查询等也是使用构建查询方式处理查询条件， 因为该方 式可以构建更加复杂的查询条件，也更加一目了然

排序查询
我们说到排序 有人就会想到：正序 或 倒序 那么我们先来倒序：

1 GET kuangshen/user/\_search 2 {

1. "query":{
1. "match_all": {} 5 },

6 "sort": [
7 {
8 "age": {
9 "order": "desc" 10 }
11 }
12 ]
13 }

上例，在条件查询的基础上，我们又通过 sort 来做排序，排序对象是 age ， order 是 desc 降序。

| 1 | { |
"took" : 0, "timed_out" : false, "\_shards" : {
"total" : 1,
"successful" : 1,
"skipped" : 0,
"failed" : 0
},
"hits" : {
"total" : {
"value" : 3,
"relation" : "eq"
},
"max_score" : null, "hits" : [
{
"\_index" : "kuangshen", "\_type" : "user", |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |
| 14 | | |
| 15 | | |
| 16 | | |
| 17 | | |
| 18 | | |
| 19 | | |

20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75 }
76 }
"\_id" : "3", "\_score" : null, "\_source" : {
"name" : "李四",
"age" : 30,
"desc" : "mmp，不知道怎么形容", "tags" : [
"靓女",
"旅游", "唱歌"
]
},
"sort" : [ 30
]
},
{
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "1", "\_score" : null, "\_source" : {
"name" : "狂神说 Java",
"age" : 18,
"desc" : "关注狂神公众号每日更新文章哦", "tags" : [
"直男",
"技术宅",
"温暖"
]
},
"sort" : [ 18
]
},
{
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "2", "\_score" : null, "\_source" : {
"name" : "张三",
"age" : 3,
"desc" : "法外狂徒", "tags" : [
"渣男",
"旅游", "交友"
]
},
"sort" : [ 3
]
}
]
**正序**，就是 desc 换成了 asc

1 GET kuangshen/user/\_search 2 {

1. "query":{
1. "match_all": {} 5 },

6 "sort": [
7 {
8 "age": {
9 "order": "asc" 10 }
11 }
12 ]
13 }

注意:在排序的过程中，只能使用可排序的属性进行排序。那么可以排序的属性有哪些呢?
数字日期 ID
其他都不行！

分页查询
1 GET kuangshen/user/\_search 2 {

1. "query":{
1. "match_all": {} 5 },

6 "sort": [
7 {
8 "age": {
9 "order": "asc" 10 }
11 }
12 ],

1. "from": 0, # 从第 n 条开始
1. "size": 1 # 返回 n 条数据

15 }

返回结果：

| 1 | { |
"took" : 0, "timed_out" : false, "\_shards" : {
"total" : 1,
"successful" : 1,
"skipped" : 0,
"failed" : 0
},
"hits" : {
"total" : {
"value" : 3,
"relation" : "eq" |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |

| 14 |

} |

} | },
"max_score" : null, "hits" : [
{
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "2", "\_score" : null, "\_source" : {
"name" : "张三",
"age" : 3,
"desc" : "法外狂徒", "tags" : [
"渣男",
"旅游",
"交友"
]
},
"sort" : [ 3
]
}
] |
| --- | --- | --- | --- |
| 15 | | | |
| 16 | | | |
| 17 | | | |
| 18 | | | |
| 19 | | | |
| 20 | | | |
| 21 | | | |
| 22 | | | |
| 23 | | | |
| 24 | | | |
| 25 | | | |
| 26 | | | |
| 27 | | | |
| 28 | | | |
| 29 | | | |
| 30 | | | |
| 31 | | | |
| 32 | | | |
| 33 | | | |
| 34 | | | |
| 35 | | | |
| 36 | | | |
| 37 | | | |
| 38 | | | |

就返回了一条数据 是从第 0 条开始的返回一条数据 。可以再测试！
学到这里，我们也可以看到，我们的查询条件越来越多，开始仅是简单查询，慢慢增加条件查询，增加 排序，对返回 结果进行限制。所以，我们可以说:**对 elasticsearch 于 来说，所有的查询条件都是可插拔的，彼此之间用 分 割。比如说，我们在查询中，仅对返回结果进行限制:**

1
2
3
4
5
6
7
8
9
GET kuangshen/user/\_search
{
"query":{
"match_all": {}
},
"from": 0, # 从第 n 条开始
"size": 1 # 返回 n 条数据
}

布尔查询
先增加一个数据：

1 PUT /kuangshen/user/4 2 {
3 "name":"狂神说",
4 "age":3,
5 "desc":"一顿操作猛如虎，一看工资 2500", 6 "tags":["直男","技术宅","温暖"]
7 }

### must (and)

我要查询所有 name 属性为“ 狂神 “的数据，并且年龄为 18 岁的！

1 GET kuangshen/user/\_search 2 {

1. "query": {
1. "bool": {
1. "must": [

6 {

1. "match": {
1. "name": "狂神说" 9 }

10 },
11 {
12 "match": {
13 "age": 3
14 }
15 }
16 ]
17 }
18 }
19 }

我们通过在 bool 属性内使用 must 来作为查询条件！看结果，是不是 有点像 **and **的感觉，里面的条件需要都满足！

### should (or)

那么我要查询 name 为狂神 或 age 为 18 的呢？

1 GET kuangshen/user/\_search 2 {

1. "query": {
1. "bool": {
1. "should": [ 6 {
1. "match": {
1. "name": "狂神说" 9 }

10 },
11 {
12 "match": {
13 "age": 18
14 }
15 }
16 ]
17 }
18 }
19 }

返回结果：

| 1 | { |
"took" : 0, "timed_out" : false, "\_shards" : {
"total" : 1,
"successful" : 1,
"skipped" : 0, |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |

| 8 |

} | "failed" : 0
},
"hits" : {
"total" : {
"value" : 2,
"relation" : "eq"
},
"max_score" : 3.1522982, "hits" : [
{
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "1",
"\_score" : 3.1522982, "\_source" : {
"name" : "狂神说 Java",
"age" : 18,
"desc" : "关注狂神公众号每日更新文章哦", "tags" : [
"直男",
"技术宅", "温暖"
]
}
},
{
"\_index" : "kuangshen", "\_type" : "user",
"\_id" : "4",
"\_score" : 2.4708953, "\_source" : {
"name" : "狂神说",
"age" : 3,
"desc" : "一顿操作猛如虎，一看工资 2500", "tags" : [
"直男",
"技术宅",
"温暖"
]
}
}
]
} |
| --- | --- | --- |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |
| 14 | | |
| 15 | | |
| 16 | | |
| 17 | | |
| 18 | | |
| 19 | | |
| 20 | | |
| 21 | | |
| 22 | | |
| 23 | | |
| 24 | | |
| 25 | | |
| 26 | | |
| 27 | | |
| 28 | | |
| 29 | | |
| 30 | | |
| 31 | | |
| 32 | | |
| 33 | | |
| 34 | | |
| 35 | | |
| 36 | | |
| 37 | | |
| 38 | | |
| 39 | | |
| 40 | | |
| 41 | | |
| 42 | | |
| 43 | | |
| 44 | | |
| 45 | | |
| 46 | | |
| 47 | | |
| 48 | | |
| 49 | | |
| 50 | | |
| 51 | | |
| 52 | | |

我们的返回结果 是不是 出现了一个 age : 3 的。是不是有点像 **or **呢

### must_not (not)

我想要查询 年龄不是 18 的 数据

1 GET kuangshen/user/\_search 2 {

1. "query": {
1. "bool": {
1. "must_not": [ 6 {

| 7   |     |     |     |     |     | "match": { |
| --- | --- | --- | --- | --- | --- | ---------- |
| 8   |     |     |     |     |     | "age": 18  |
| 9   |     |     |     |     |     | }          |
| 10  |     |     |     |     | }   |            |
| 11  |     |     |     | ]   |     |            |
| 12  |     |     | }   |     |     |            |
| 13  |     | }   |     |     |     |            |
| 14  | }   |     |     |     |     |            |

### Fitter

我要查询 name 为狂神 的，age 大于 10 的数据

1 GET kuangshen/user/\_search 2 {
3 "query":{ 4 "bool": {
5 "must": [
6 {

1. "match": {
1. "name": "狂神" 9 }

10 }
11 ],

1. "filter": {
1. "range": {

14 "age": {
15 "gt": 10
16 }
17 }
18 }
19 }
20 }
21 }

这里就用到了 ﬁlter 条件过滤查询，过滤条件的范围用 range 表示， gt 表示大于，大于多少呢?是 10。其余操作如下 :
gt 表示大于
gte 表示大于等于
lt 表示小于
lte 表示小于等于
要查询 name 是 狂神， age 在 25~30 之间的怎么查?

1 GET kuangshen/user/\_search 2 {
3 "query":{ 4 "bool": {
5 "must": [
6 {

1. "match": {
1. "name": "狂神" 9 }

10 }
11 ],

1. "filter": {
1. "range": {

| 14  |     |     |     |     |     | "age": {   |
| --- | --- | --- | --- | --- | --- | ---------- |
| 15  |     |     |     |     |     | "gte": 25, |
| 16  |     |     |     |     |     | "lte": 30  |
| 17  |     |     |     |     |     | }          |
| 18  |     |     |     |     | }   |            |
| 19  |     |     |     | }   |     |            |
| 20  |     |     | }   |     |     |            |
| 21  |     | }   |     |     |     |            |
| 22  | }   |     |     |     |     |            |

短语检索
我要查询 tags 为男的数据

1 GET kuangshen/user/\_search 2 {

1. "query":{
1. "match": {
1. "tags": "男"

6 }
7 }
8 }

返回了所有标签中带 男 的记录！
既然按照标签检索，那么，能不能写多个标签呢?又该怎么写呢?

1 GET kuangshen/user/\_search 2 {

1. "query":{
1. "match": {
1. "tags": "男 技术" 6 }

7 }
8 }

返回：只要含有这个标签满足一个就给我返回这个数据了。

term 查询精确查询
查询是直接通过倒排索引指定的 词条，也就是精确查找。
term 和 match 的区别:
term
match 是经过分析(analyer)的，也就是说，文档是先被分析器处理了，根据不同的分析器，分析出 的结果也会不同，在会根据分词 结果进行匹配。
term 是不经过分词的，直接去倒排索引查找精确的值。
注意 ⚠：我们现在 用的 es7 版本 所以我们用 mappings properties 去给多个字段(ﬁelds)指定类型的时候,不能给我们的 索引制定类型：

1 PUT testdb 2 {
3 "mappings": {

4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
"properties": { "name":{
"type":"text"
},
"desc":{
"type": "keyword"
}
}
}
}
// 插入数据
PUT testdb/\_doc/1
{
"name": "狂神说 Java name", "desc": "狂神说 Java desc"
}
PUT testdb/\_doc/2
{
"name": "狂神说 Java name", "desc": "狂神说 Java desc2"
}

上述中 testdb 索引中,字段 name 在被查询时会被分析器进行分析后匹配查询。而**属于 keyword 类型不会被分析器处理**。
我们来验证一下：

1 GET \_analyze 2 {

1. "analyzer": "keyword",
1. "text": "狂神说 Java name" 5 }

结果：

| 1 | {

} |
"tokens" : [
{
"token" : "狂神说 Java name", "start_offset" : 0,
"end_offset" : 12, "type" : "word", "position" : 0
}
] |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |

是不是没有被分析啊。**就是简单的一个字符串啊**。再测试

1 GET \_analyze 2 {

1. "analyzer": "standard",
1. "text": "狂神说 Java name" 5 }

结果：

1 {

| 2 |

} | "tokens" : [
{
"token" : " 狂 ", "start_offset" : 0,
"end_offset" : 1,
"type" : "<IDEOGRAPHIC>",
"position" : 0
},
{
"token" : " 神 ", "start_offset" : 1,
"end_offset" : 2,
"type" : "<IDEOGRAPHIC>",
"position" : 1
},
{
"token" : " 说 ", "start_offset" : 2,
"end_offset" : 3,
"type" : "<IDEOGRAPHIC>",
"position" : 2
},
{
"token" : "java", "start_offset" : 3,
"end_offset" : 7, "type" : "<ALPHANUM>",
"position" : 3
},
{
"token" : "name", "start_offset" : 8,
"end_offset" : 12, "type" : "<ALPHANUM>",
"position" : 4
}
] |
| --- | --- | --- |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |
| 12 | | |
| 13 | | |
| 14 | | |
| 15 | | |
| 16 | | |
| 17 | | |
| 18 | | |
| 19 | | |
| 20 | | |
| 21 | | |
| 22 | | |
| 23 | | |
| 24 | | |
| 25 | | |
| 26 | | |
| 27 | | |
| 28 | | |
| 29 | | |
| 30 | | |
| 31 | | |
| 32 | | |
| 33 | | |
| 34 | | |
| 35 | | |
| 36 | | |
| 37 | | |
| 38 | | |
| 39 | | |

那么我们看一下 们字符串是不是被分析了啊。**总结：keyword 字段类型不会被分析器分析！ **现在我们来查询一下：

| 1 | GET testdb/\_search
{
"query": {
"term": {
"name": "狂"
}
}
}

GET testdb/\_search
{
"query": {
"match": { | // text 会被分析器分析 查询

| // keyword 不会被分析所以直接查询 |
| --------------------------------- | --- | --- |
| 2                                 |     |     |
| 3                                 |     |     |
| 4                                 |     |     |
| 5                                 |     |     |
| 6                                 |     |     |
| 7                                 |     |     |
| 8                                 |     |     |
| 9                                 |     |     |
| 10                                |     |     |
| 11                                |     |     |
| 12                                |     |     |
| 13                                |     |     |

| 14 |

} |

} |
} | "desc":"狂神说 Java desc" |
| --- | --- | --- | --- | --- |
| 15 | | | | |
| 16 | | | | |
| 17 | | | | |

### 查找多个精确值(terms)

[官网地址：https://www.elastic.co/guide/cn/elasticsearch/guide/current/\_ﬁnding_multiple_exact_va lues.html](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_finding_multiple_exact_values.html)

| 1   | PUT testdb/\_doc/3    |
| --- | --------------------- |
| 2   | {                     |
| 3   | "t1": "22",           |
| 4   | "t2": "2020-4-16"     |
| 5   | }                     |
| 6   | PUT testdb/\_doc/4    |
| 7   | {                     |
| 8   | "t1": "33",           |
| 9   | "t2": "2020-4-17"     |
| 10  | }                     |
| 11  |                       |
| 12  | # 查询 精确查找多个值 |
| 13  | GET testdb/\_search   |
| 14  | {                     |
| 15  | "query": {            |
| 16  | "bool": {             |
| 17  | "should": [           |
| 18  | {                     |
| 19  | "term": {             |
| 20  | "t1": "22"            |
| 21  | }                     |
| 22  | },                    |
| 23  | {                     |
| 24  | "term": {             |
| 25  | "t1": "33"            |
| 26  | }                     |
| 27  | }                     |
| 28  | ]                     |
| 29  | }                     |
| 30  | }                     |
| 31  | }                     |

除了 bool 查询之外：

1 GET testdb/\_doc/\_search 2 {

1. "query": {
1. "terms": {

5 "t1": ["22", "33"]
6 }
7 }
8 }

高亮显示

1 GET kuangshen/user/\_search 2 {

1. "query":{
1. "match": {
1. "name": "狂神" 6 }

7 },

1. "highlight" :{
1. "fields": {

10 "name":{}
11 }
12 }
13 }

返回结果：

1 #! Deprecation: [types removal] Specifying types in search requests is deprecated.
2 {
3 "took" : 62,

1. "timed_out" : false,
1. "\_shards" : {
1. "total" : 1,
1. "successful" : 1,
1. "skipped" : 0,
1. "failed" : 0 10 },
1. "hits" : {
1. "total" : {
1. "value" : 2,
1. "relation" : "eq" 15 },

16 "max_score" : 1.6472635,
17 "hits" : [ 18 {

1. "\_index" : "kuangshen",
1. "\_type" : "user",

21 "\_id" : "4",
22 "\_score" : 1.6472635,

1. "\_source" : {
1. "name" : "狂神说",

25 "age" : 3,

1. "desc" : "一顿操作猛如虎，一看工资 2500",
1. "tags" : [

28 "直男",

1. "技术宅",
1. "温暖"

31 ]
32 },

1. "highlight" : {
1. "name" : [

35 "<em>狂</em><em>神</em>说"
36 ]
37 }
38 },
39 {
40 "\_index" : "kuangshen",

| 41 |

} |

} |

] |

} | "\_type" : "user",
"\_id" : "1",
"\_score" : 1.4348655, "\_source" : {
"name" : "狂神说 Java",
"age" : 18,
"desc" : "关注狂神公众号每日更新文章哦", "tags" : [
"直男",
"技术宅",
"温暖"
]
},
"highlight" : {
"name" : [
"<em>狂</em><em>神</em>说 Java"
]
} |
| --- | --- | --- | --- | --- | --- |
| 42 | | | | | |
| 43 | | | | | |
| 44 | | | | | |
| 45 | | | | | |
| 46 | | | | | |
| 47 | | | | | |
| 48 | | | | | |
| 49 | | | | | |
| 50 | | | | | |
| 51 | | | | | |
| 52 | | | | | |
| 53 | | | | | |
| 54 | | | | | |
| 55 | | | | | |
| 56 | | | | | |
| 57 | | | | | |
| 58 | | | | | |
| 59 | | | | | |
| 60 | | | | | |
| 61 | | | | | |
| 62 | | | | | |

我们可以看到 已 < em>狂神< /em>经帮我们加上了一个< em>标签这是 es 帮我们加的标签。那我·**也可以自己自定义样式**
1 GET kuangshen/user/\_search 2 {

1. "query":{
1. "match": {
1. "name": "狂神" 6 }

7 },

1. "highlight" :{
1. "pre_tags": "<b class='key' style='color:red'>", 10 "post_tags": "</b>",

11 "fields": {
12 "name":{}
13 }
14 }
15 }

结果：

1 #! Deprecation: [types removal] Specifying types in search requests is deprecated.
2 {
3 "took" : 1,

1. "timed_out" : false,
1. "\_shards" : {
1. "total" : 1,
1. "successful" : 1,
1. "skipped" : 0,
1. "failed" : 0 10 },
1. "hits" : {
1. "total" : {

1. "value" : 2,
1. "relation" : "eq" 15 },

16 "max_score" : 1.6472635,
17 "hits" : [ 18 {

1. "\_index" : "kuangshen",
1. "\_type" : "user",

21 "\_id" : "4",
22 "\_score" : 1.6472635,

1. "\_source" : {
1. "name" : "狂神说",

25 "age" : 3,

1. "desc" : "一顿操作猛如虎，一看工资 2500",
1. "tags" : [

28 "直男",

1. "技术宅",
1. "温暖"

31 ]
32 },

1. "highlight" : {
1. "name" : [
1. "<b class='key' style='color:red'>狂</b><b class='key'

style='color:red'>神</b>说" 36 ]
37 }
38 },
39 {

1. "\_index" : "kuangshen",
1. "\_type" : "user",

42 "\_id" : "1",
43 "\_score" : 1.4348655,

1. "\_source" : {
1. "name" : "狂神说 Java",

46 "age" : 18,

1. "desc" : "关注狂神公众号每日更新文章哦",
1. "tags" : [

49 "直男",

1. "技术宅",
1. "温暖"

52 ]
53 },

1. "highlight" : {
1. "name" : [
1. "<b class='key' style='color:red'>狂</b><b class='key'

style='color:red'>神</b>说 Java" 57 ]
58 }
59 }
60 ]
61 }
62 }

需要注意的是:自定义标签中属性或样式中的逗号一律用英文状态的单引号表示，应该与外部 es 语法 的双引号区分开。

说明：Deprecation
注意 elasticsearch 在第一个版本的开始 每个文档都储存在一个索引中，并分配一个 映射类型，映射类型用于表示被索引的文档或者实体的类型，这样带来了一些问题, 导致后来在 elasticsearch6.0.0 版本中一个文档只能包含一个映射类型，而在 7.0.0 中，映 射类型则将被弃用，到了 8.0.0 中则将完全被删
除。
只要记得，一个索引下面只能创建一个类型就行了，其中各字段都具有唯一性，如果在创建映射的时

候，如果没有指定文档类型，那么该索引的默认索引类型是
\_doc
成一个 id 字符串。
，不指定文档 id 则会内部帮我们生

## API 创建索引及文档

找文档
网上的 es 教程大都十分老旧，而且 es 的版本众多，个别版本的差异还较大，另外 es 本身提供多种 api，导致许多文章各种乱七八糟实例！所以后面直接放弃，从官网寻找方案，这里我使用 elasticsearch 最新的
7.6.1 版本来讲解：
1、进入 es 的官网指导文档 [https://www.elastic.co/guide/index.html](https://www.elastic.co/guide/index.html)
2、找到 Elasticsearch Clients（这个就是客户端 api 文档）
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834951640-1f6f57b8-1f1d-4277-99f1-7df4c9c0e17b.png#)

3、我们使用 java rest 风格 api，大家可以更加自己的版本选择特定的 other versions。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834952304-1fd14328-2ffc-4c89-be6e-4cf80861096d.jpeg#)

4、rest 又分为 high level 和 low level，我们直接选择 high level 下面的 Getting started

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834952728-44bcd683-352a-490c-8727-b07a24616e95.jpeg#)
![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834953327-8175b3d4-503b-42aa-8158-0987856f378e.jpeg#)5、向下阅读找到 Maven 依赖和基本配置！
Java REST Client 说明

Java REST Client 有两种风格：
**Java Low Level REST Client **：用于 Elasticsearch 的官方低级客户端。它允许通过 http 与 Elasticsearch 集群通信。将请求编排和响应反编排留给用户自己处理。它兼容所有的 Elasticsearch 版本。（PS：学过
WebService 的话，对编排与反编排这个概念应该不陌生。可以理解为对请求参数的封装，以及对响应结果的解析）
**Java High Level REST Client **：用于 Elasticsearch 的官方高级客户端。它是基于低级客户端的，它提供很多 API，并负责请求的编排与响应的反编排。（PS：就好比是，一个是传自己拼接好的字符串，并且 自己解析返回的结果；而另一个是传对象，返回的结果也已经封装好了，直接是对象，更加规范了参数 的名称以及格式，更加面对对象一点）
（PS：所谓低级与高级，我觉得一个很形象的比喻是，面向过程编程与面向对象编程）

网上很多教程比较老旧，都是使用 TransportClient 操作的，在 Elasticsearch 7.0 中不建议使用
TransportClient，并且在 8.0 中会完全删除 TransportClient。因此，官方更建议我们用 Java High Level REST Client，它执行 HTTP 请求，而不是序列号的 Java 请求。既然如此，这里我们就直接用高级了。

配置基本项目依赖

1、新建一个 springboot（2.2.5 版）项目
kuang-elasticsearch
2、配置 es 的依赖！
，导入 web 依赖即可！

1
2
3
4
5
6
7
8
9
10
<properties>
<java.version>1.8</java.version>

<!-- 这里SpringBoot默认配置的版本不匹配，我们需要自己配置版本！ -->

<elasticsearch.version>7.6.1</elasticsearch.version>
</properties>
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-data-elasticsearch</artifactId>
</dependency>

3、继续阅读文档到 Initialization ，我们看到需要构建 RestHighLevelClient 对象；

1. RestHighLevelClient client = new RestHighLevelClient(
1. RestClient.builder(
1. new HttpHost("localhost", 9200, "http"),
1. new HttpHost("localhost", 9201, "http"))); // 构建客户端对象

5
6
7
8
// 操作....
// 高级客户端内部会创建低级客户端用于基于提供的 builder 执行请求。低级客户端维护一个连接池， 并启动一些线程，因此当你用完以后应该关闭高级客户端，并且在内部它将会关闭低级客户端，以释放这 些资源。关闭客户端可以使用 close()方法：
client.close(); // 关闭

4、我们编写一个配置类，提供这个 bean 来进行操作

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
package com.kuang.config;
import org.apache.http.HttpHost;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient; import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ElasticsearchClientConfig {

@Bean
public RestHighLevelClient restHighLevelClient() { RestHighLevelClient client = new RestHighLevelClient(
RestClient.builder(
new HttpHost("127.0.0.1", 9200, "http")));
return client;
}

20 }

5、常用方法工具类封装

1 package com.kuang.utils; 2

1. import com.alibaba.fastjson.JSON;
1. import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;
1. import org.elasticsearch.action.bulk.BulkRequest;
1. import org.elasticsearch.action.bulk.BulkResponse;
1. import org.elasticsearch.action.delete.DeleteRequest;
1. import org.elasticsearch.action.delete.DeleteResponse;
1. import org.elasticsearch.action.get.GetRequest;
1. import org.elasticsearch.action.get.GetResponse;
1. import org.elasticsearch.action.index.IndexRequest;
1. import org.elasticsearch.action.index.IndexResponse;
1. import org.elasticsearch.action.search.SearchRequest;
1. import org.elasticsearch.action.search.SearchResponse;
1. import org.elasticsearch.action.support.master.AcknowledgedResponse;
1. import org.elasticsearch.action.update.UpdateRequest;
1. import org.elasticsearch.action.update.UpdateResponse;
1. import org.elasticsearch.client.RequestOptions;
1. import org.elasticsearch.client.RestHighLevelClient;
1. import org.elasticsearch.client.indices.CreateIndexRequest;
1. import org.elasticsearch.client.indices.CreateIndexResponse;
1. import org.elasticsearch.client.indices.GetIndexRequest;
1. import org.elasticsearch.common.unit.TimeValue;
1. import org.elasticsearch.common.xcontent.XContentType;
1. import org.elasticsearch.index.query.QueryBuilders;
1. import org.elasticsearch.rest.RestStatus;
1. import org.elasticsearch.search.builder.SearchSourceBuilder;
1. import org.elasticsearch.search.fetch.subphase.FetchSourceContext;
1. import org.springframework.beans.factory.annotation.Autowired;
1. import org.springframework.beans.factory.annotation.Qualifier;
1. import org.springframework.stereotype.Component; 32
1. import java.io.IOException;
1. import java.util.List;
1. import java.util.concurrent.TimeUnit; 36
1. @Component
1. public class EsUtils<T> { 39
1. @Autowired
1. @Qualifier("restHighLevelClient")
1. private RestHighLevelClient client; 43 /\*\*
1. - 判断索引是否存在
1. - @param index
1. - @return
1. - @throws IOException

48 \*/

1.  public boolean existsIndex(String index) throws IOException {
1.  GetIndexRequest request = new GetIndexRequest(index);
1.      boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);
1.  return exists; 53 }

54 /\*\*

1. - 创建索引
1. - @param index
1. - @throws IOException

58 \*/

1. public boolean createIndex(String index) throws IOException {
1. CreateIndexRequest request = new CreateIndexRequest(index);
1. CreateIndexResponse createIndexResponse

=client.indices().create(request,RequestOptions.DEFAULT);

1. return createIndexResponse.isAcknowledged(); 63 }

64
65 /\*\*

1. - 删除索引
1. - @param index
1. - @return
1. - @throws IOException

70 \*/

1.  public boolean deleteIndex(String index) throws IOException {
1.      DeleteIndexRequest deleteIndexRequest = new DeleteIndexRequest(index);
1.      AcknowledgedResponse response = client.indices().delete(deleteIndexRequest, RequestOptions.DEFAULT);
1.  return response.isAcknowledged(); 75

76 }
77
78 /\*\*

1. - 判断某索引下文档 id 是否存在
1. - @param index
1. - @param id
1. - @return
1. - @throws IOException

84 \*/

1. public boolean docExists(String index, String id) throws IOException {
1. GetRequest getRequest = new GetRequest(index,id);
1. //只判断索引是否存在不需要获取\_source
1. getRequest.fetchSourceContext(new FetchSourceContext(false));
1. getRequest.storedFields("_none_");
1. boolean exists = client.exists(getRequest, RequestOptions.DEFAULT);
1. return exists; 92 }

93
94 /\*\*

1. - 添加文档记录
1. - @param index
1. - @param id
1. - @param t 要添加的数据实体类
1. - @return
1. - @throws IOException

101 \*/
102 public boolean addDoc(String index,String id,T t) throws IOException { 103

1.  IndexRequest request = new IndexRequest(index);
1.  request.id(id);
1.  //timeout
1.  request.timeout(TimeValue.timeValueSeconds(1));
1.  request.timeout("1s");
1.  request.source(JSON.toJSONString(t), XContentType.JSON);
1.      IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT);
1.  RestStatus Status = indexResponse.status();
1.  return Status==RestStatus.OK||Status== RestStatus.CREATED;

113 }
114
115 /\*\*

1. - 根据 id 来获取记录
1. - @param index
1. - @param id
1. - @return
1. - @throws IOException

121 \*/

1.  public GetResponse getDoc(String index, String id) throws IOException {
1.  GetRequest request = new GetRequest(index,id);
1.      GetResponse getResponse = client.get(request, RequestOptions.DEFAULT);
1.  return getResponse;

126 }
127
128 /\*\*

1. - 批量添加文档记录
1. - 没有设置 id ES 会自动生成一个，如果要设置 IndexRequest 的对象.id()即可
1. - @param index
1. - @param list
1. - @return
1. - @throws IOException

135 \*/

1. public boolean bulkAdd(String index, List<T> list) throws IOException {
1. BulkRequest bulkRequest = new BulkRequest();
1. //timeout
1. bulkRequest.timeout(TimeValue.timeValueMinutes(2));
1. bulkRequest.timeout("2m"); 141
1. for (int i =0;i<list.size();i++){
1. bulkRequest.add(new IndexRequest(index)
1. .source(JSON.toJSONString(list.get(i))));

145 }
146 BulkResponse bulkResponse = client.bulk(bulkRequest, RequestOptions.DEFAULT);
147
148 return !bulkResponse.hasFailures(); 149
150 }
151
152 /**
153 _ 批量删除和更新就不写了可根据上面几个方法来写
154 _/
155
156 /**

1. - 更新文档记录
1. - @param index
1. - @param id
1. - @param t
1. - @return
1. - @throws IOException

163 \*/

| 164 |     | public boolean updateDoc(String index,String id,T t) throws IOException |     |
| --- | --- | ----------------------------------------------------------------------- | --- |
|     | {   |                                                                         |     |
| 165 |     | UpdateRequest request = new UpdateRequest(index,id);                    |     |
| 166 |     | request.doc(JSON.toJSONString(t));                                      |     |
| 167 |     | request.timeout(TimeValue.timeValueSeconds(1));                         |     |
| 168 |     | request.timeout("1s");                                                  |     |
| 169 |     | UpdateResponse updateResponse = client.update(                          |     |
| 170 |     | request, RequestOptions.DEFAULT);                                       |     |
| 171 |     | return updateResponse.status()==RestStatus.OK;                          |     |
| 172 |     | }                                                                       |     |
| 173 |     |                                                                         |     |
| 174 |     |                                                                         |     |
| 175 |     | /\*\*                                                                   |     |
| 176 |     | \* 删除文档记录                                                         |     |
| 177 |     | \* @param index                                                         |     |
| 178 |     | \* @param id                                                            |     |
| 179 |     | \* @return                                                              |     |
| 180 |     | \* @throws IOException                                                  |     |
| 181 |     | \*/                                                                     |     |
| 182 |     | public boolean deleteDoc(String index,String id) throws IOException {   |     |
| 183 |     | DeleteRequest request = new DeleteRequest(index,id);                    |     |
| 184 |     | //timeout                                                               |     |
| 185 |     | request.timeout(TimeValue.timeValueSeconds(1));                         |     |
| 186 |     | request.timeout("1s");                                                  |     |
| 187 |     | DeleteResponse deleteResponse = client.delete(                          |     |
| 188 |     | request, RequestOptions.DEFAULT);                                       |     |
| 189 |     |                                                                         |     |
| 190 |     | return deleteResponse.status()== RestStatus.OK;                         |     |
| 191 |     | }                                                                       |     |
| 192 |     |                                                                         |     |
| 193 |     | /\*\*                                                                   |     |
| 194 |     | \* 根据某字段来搜索                                                     |     |
| 195 |     | \* @param index                                                         |     |
| 196 |     | \* @param field                                                         |     |
| 197 |     | \* @param key 要收搜的关键字                                            |     |
| 198 |     | \* @throws IOException                                                  |     |
| 199 |     | \*/                                                                     |     |
| 200 |     | public void search(String index,String field ,String key,Integer        |     |

|

201
202
203
204
205
206
207
208
209
210 | from,Integer size) throws IOException {
SearchRequest searchRequest = new SearchRequest(index); SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); sourceBuilder.query(QueryBuilders.termQuery(field, key));
//控制搜素
sourceBuilder.from(from); sourceBuilder.size(size);
//最大搜索时间。
sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); searchRequest.source(sourceBuilder);
SearchResponse searchResponse = client.search(searchRequest,
RequestOptions.DEFAULT); | | |
| 211 | | | System.out.println(JSON.toJSONString(searchResponse.getHits())); |
| 212 | | | |
| 213 | | } | |
| 214 | | | |
| 215 | } | | |

APIs 测试
测试创建索引：

1. @Test
1. void testCreateIndex() throws IOException {
1. CreateIndexRequest request = new CreateIndexRequest("kuang_index");
1. CreateIndexResponse createIndexResponse 5

=restHighLevelClient.indices().create(request,RequestOptions.DEFAULT);
6 System.out.println(createIndexResponse); 7 }

测试获取索引：

1.  @Test
1.  void testExistsIndex() throws IOException {
1.  GetIndexRequest request = new GetIndexRequest("kuang_index");
1.      boolean exists = restHighLevelClient.indices().exists(request, RequestOptions.DEFAULT);
1.  System.out.println(exists);

6 }

测试删除索引：

1.  @Test
1.  void testDeleteIndexRequest() throws IOException {
1.      DeleteIndexRequest deleteIndexRequest = new DeleteIndexRequest("kuang_index");
1.  AcknowledgedResponse response

5 = restHighLevelClient.indices().delete(deleteIndexRequest, RequestOptions.DEFAULT);
6 System.out.println(response.isAcknowledged());
7 }

测试添加文档记录： 创建一个实体类 User

1. @Data
1. @AllArgsConstructor
1. @NoArgsConstructor
1. @Component
1. public class User {
1. private String name;
1. private int age; 8 }

测试添加文档记录

1. @Test
1. void testAddDocument() throws IOException {
1. // 创建对象
1. User user = new User("狂神说", 3);
1. // 创建请求
1. IndexRequest request = new IndexRequest("kuang_index"); 7 // 规则

8 request.id("1");

1.  request.timeout(TimeValue.timeValueSeconds(1));
1.  request.timeout("1s");
1.  request.source(JSON.toJSONString(user), XContentType.JSON);
1.  // 发送请求
1.      IndexResponse indexResponse = restHighLevelClient.index(request, RequestOptions.DEFAULT);
1.  System.out.println(indexResponse.toString());
1.  RestStatus Status = indexResponse.status();
1.      System.out.println(Status == RestStatus.OK || Status == RestStatus.CREATED);

17 }

测试：判断某索引下文档 id 是否存在

1.  // 判断此 id 是否存在这个索引库中
1.  @Test
1.  void testIsExists() throws IOException {
1.  GetRequest getRequest = new GetRequest("kuang_index","1");
1.  // 不获取\_source 上下文 storedFields
1.  getRequest.fetchSourceContext(new FetchSourceContext(false));
1.  getRequest.storedFields("_none_");
1.  // 判断此 id 是否存在！
1.      boolean exists = restHighLevelClient.exists(getRequest, RequestOptions.DEFAULT);
1.  System.out.println(exists);

11 }

测试：根据 id 获取记录

1.  // 获得文档记录
1.  @Test
1.  void testGetDocument() throws IOException {
1.  GetRequest getRequest = new GetRequest("kuang_index","3");
1.      GetResponse getResponse = restHighLevelClient.get(getRequest, RequestOptions.DEFAULT);
1.  System.out.println(getResponse.getSourceAsString()); // 打印文档内容
1.  System.out.println(getResponse); 8 }

测试：更新文档记录

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
// 更新文档记录
@Test
void testUpdateDocument() throws IOException {
UpdateRequest request = new UpdateRequest("kuang_index","1"); request.timeout(TimeValue.timeValueSeconds(1)); request.timeout("1s");
User user = new User("狂神说", 18);
request.doc(JSON.toJSONString(user), XContentType.JSON);

UpdateResponse updateResponse = restHighLevelClient.update( request, RequestOptions.DEFAULT);

System.out.println(updateResponse.status() == RestStatus.OK);
}

测试：删除文档记录

1
2
3
4
5
6
7
8
9
10
11
12
// 删除文档测试
@Test
void testDelete() throws IOException {
DeleteRequest request = new DeleteRequest("kuang_index","3");
//timeout request.timeout(TimeValue.timeValueSeconds(1)); request.timeout("1s");
DeleteResponse deleteResponse = restHighLevelClient.delete( request, RequestOptions.DEFAULT);
System.out.println(deleteResponse.status() == RestStatus.OK);
}

测试：批量添加文档

1. // 批量添加数据
1. @Test
1. void testBulkRequest() throws IOException {
1. BulkRequest bulkRequest = new BulkRequest();
1. //timeout
1. bulkRequest.timeout(TimeValue.timeValueMinutes(2));
1. bulkRequest.timeout("2m"); 8
1. ArrayList<User> userList = new ArrayList<>();
1. userList.add(new User("kuangshen1",3));
1. userList.add(new User("kuangshen2",3));
1. userList.add(new User("kuangshen3",3));
1. userList.add(new User("qinjiang1",3));
1. userList.add(new User("qinjiang2",3));
1. userList.add(new User("qinjiang3",3)); 16
1. for (int i =0;i<userList.size();i++){
1. bulkRequest
1. .add(new IndexRequest("kuang_index") 20 .id(""+(i+1))

21
.source(JSON.toJSONString(userList.get(i)),XContentType.JSON)); 22 }

1.  // bulk
1.      BulkResponse bulkResponse = restHighLevelClient.bulk(bulkRequest,RequestOptions.DEFAULT);

25
26 System.out.println(!bulkResponse.hasFailures()); 27 }

查询测试：

1
2
3
4
5
6
7
// 查询测试
/\*\*

- 使用 QueryBuilder
- termQuery("key", obj) 完全匹配
- termsQuery("key", obj1, obj2..)

一次匹配多个值

- matchQuery("key", Obj) 单个匹配, field 不支持通配符, 前缀具高级特性
- multiMatchQuery("text", "field1", "field2"..); 匹配多个字段, field 有通配符忒行

8
9

- matchAllQuery();
  \*/
  匹配所有文件

1. @Test
1. void testSearch() throws IOException {
1. SearchRequest searchRequest = new SearchRequest("kuang_index");
1. SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); 14

15

16
17
18
19
20
21
22
// TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery("name", "qinjiang1");
MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery();
sourceBuilder.query(matchAllQueryBuilder);

sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); searchRequest.source(sourceBuilder);
23
24
25
26
27
28
SearchResponse response = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);
System.out.println(JSON.toJSONString(response.getHits())); System.out.println("================SearchHit=================="); for (SearchHit documentFields : response.getHits().getHits()) {
System.out.println(documentFields.getSourceAsMap());
}
}

# 实战测试

## 初始化项目

1、启动 es 服务和客户端
2、使用 springboot 快速构建服务
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834953720-937decc3-6aca-4b46-a03a-259a86ff6cf2.png#)
3、修改版本依赖！

1. <properties>
1. <java.version>1.8</java.version>
1. <!-- 这里SpringBoot默认配置的版本不匹配，我们需要自己配置版本！ -->
1. <elasticsearch.version>7.6.1</elasticsearch.version>
1. </properties>

4、配置 文件
application.properties

1. server.port=9090
1. # 关闭 thymeleaf 缓存
1. spring.thymeleaf.cache=false

5、导入前端的素材！修改为 Thymeleaf 支持的格式！

1 <html xmlns:th=["http://www.thymeleaf.org](http://www.thymeleaf.org/)">

6、编写 IndexController 进行跳转测试！
![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834954262-6f501817-d5de-4196-a254-471812da7594.png#)

## jsoup 讲解

1、导入 jsoup 的依赖

1. <!-- [https://mvnrepository.com/artifact/org.jsoup/jsoup](https://mvnrepository.com/artifact/org.jsoup/jsoup) -->
1. <dependency>
1. <groupId>org.jsoup</groupId>
1. <artifactId>jsoup</artifactId>
1. <version>1.13.1</version>
1. </dependency>

2、编写一个工具类 HtmlParseUtil

1.  public class HtmlParseUtil {
1.  public static void main(String[] args) throws IOException {
1.  // jsoup 不能抓取 ajax 的请求，除非自己模拟浏览器进行请求！ 4
1.  // 1、[https://search.jd.com/Search?keyword=java](https://search.jd.com/Search?keyword=java)
1.  String url = "https://search.jd.com/Search?keyword=java";
1.  // 2、解析网页（需要联网）
1.  Document document = Jsoup.parse(new URL(url), 30000); 9
1.  // 3、抓取搜索到的数据！
1.  // Document 就是我们 JS 的 Document 对象，你可以看到很多 JS 语法
1.  Element element = document.getElementById("J_goodsList"); 13
1.  // 4、找到所有的 li 元素
1.  Elements elements = element.getElementsByTag("li"); 16
1.  // 获取京东的商品信息
1.  for (Element el : elements) {
1.  // 这种网站，一般为了保证效率，一般会延时加载图片
1.  // String img = el.getElementsByTag("img").eq(0).attr("src");
1.      String img = el.getElementsByTag("img").eq(0).attr("source-data- lazy-img");
1.  String price = el.getElementsByClass("p-price").eq(0).text();
1.  String title = el.getElementsByClass("p-name").eq(0).text(); 24
1.  System.out.println(img);
1.  System.out.println(price);
1.  System.out.println(title);

28 System.out.println("================================");
29 }
30 }
31 }

3、封装一个实体类保存爬取下来的数据

1. @Data
1. @NoArgsConstructor
1. @AllArgsConstructor
1. public class Content {
1. private String title; // 商品名称
1. private String price; // 商品价格
1. private String img; // 商品封面
1. // 大家可以自行扩展使用

9 }

4、封装为工具使用！

1 /\*\*

1.  - @author 狂神说 Java 公众号：狂神说
1.  - @param keywords 要搜索的关键字！
1.  - @return 抓取的商品集合

5 \*/

1. public List<Content> parseJD(String keywords) throws Exception {
1. String url = "https://search.jd.com/Search?keyword="+keywords;
1. Document document = Jsoup.parse(new URL(url), 30000);
1. Element element = document.getElementById("J_goodsList");
1. Elements elements = element.getElementsByTag("li"); 11

12 ArrayList<Content> goodsList = new ArrayList<>(); 13

1.  // 获取京东的商品信息
1.  for (Element el : elements) {
1.      String img = el.getElementsByTag("img").eq(0).attr("source-data- lazy-img");
1.  String price = el.getElementsByClass("p-price").eq(0).text();
1.  String title = el.getElementsByClass("p-name").eq(0).text();
1.  // 封装获取的数据
1.  Content content = new Content();
1.  content.setImg(img);
1.  content.setPrice(price);
1.  content.setTitle(title);
1.  goodsList.add(content); 25 }

26 return goodsList; 27 }

5、测试工具类的使用！

1. public static void main(String[] args) throws Exception {
1. new HtmlParseUtil().parseJD("vue").forEach(System.out::println); 3 }

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834955315-5f5ccda0-edb7-4279-a8f4-32c05ada65aa.jpeg#)搞定收工！简单爬虫编写完毕！我们这里的数据就使用爬取的即可，平时开发 es 的数据可能来自多个地 方，你们可以从数据库查询获取也是一样的，后面我们来测试下效果！

## 业务编写

1、导入 ElasticsearchClientConﬁg 配置类

1
2
3
4
5
6
7
8
9
10
11
12
@Configuration
public class ElasticsearchClientConfig {
@Bean
public RestHighLevelClient restHighLevelClient() { RestHighLevelClient client = new RestHighLevelClient(
RestClient.builder(
new HttpHost("127.0.0.1", 9200, "http")));
return client;
}
}

2、编写业务！

1. @Service
1. public class ContentService { 3
1. @Autowired
1. private RestHighLevelClient restHighLevelClient; 6
1. // 1、解析数据存入 es
1. public Boolean parseContent(String keywords) throws Exception {
1. // 解析查询出来的数据
1. List<Content> contents = new HtmlParseUtil().parseJD(keywords);
1. // 封装数据到索引库中！
1. BulkRequest bulkRequest = new BulkRequest();
1. bulkRequest.timeout(TimeValue.timeValueMinutes(2));
1. bulkRequest.timeout("2m");
1. for(int i =0;i<contents.size();i++){
1. bulkRequest
1. .add(new IndexRequest("jd_goods") 18

.source(JSON.toJSONString(contents.get(i)),XContentType.JSON)); 19 }
20

1.      BulkResponse bulkResponse = restHighLevelClient.bulk(bulkRequest,RequestOptions.DEFAULT);
1.  return !bulkResponse.hasFailures(); 23 }

24

1.  // 2、实现搜索功能，带分页处理
1.      public List<Map<String, Object>> searchContentPage(String keyword, int pageNo, int pageSize) throws IOException {

27

1. // 基本的参数判断！
1. if(pageNo <= 1){
1. pageNo = 1;

31 }

1.  // 基本的条件搜索
1.  SearchRequest searchRequest = new SearchRequest("jd_goods");
1.  SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
1.  // 分页
1.  sourceBuilder.from(pageNo);
1.  sourceBuilder.size(pageSize);
1.  // 精准匹配 QueryBuilders 根据自己要求配置查询条件即可！

1.      TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery("title", keyword);
1.  sourceBuilder.query(termQueryBuilder);
1.  sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); 42

43
44
45
46
47
48
49
50
51
52
53
54
// 搜索
searchRequest.source(sourceBuilder);
SearchResponse response = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);
// 解析结果！
List<Map<String, Object>> list = new ArrayList<>();
for (SearchHit documentFields : response.getHits().getHits()) { list.add(documentFields.getSourceAsMap());
}
return list;
}
}

3、controller

1
2
3
4
5
6
7
8
@RestController
public class ContentController {
@Autowired
private ContentService contentService;
9
10
11
12
13
14
@GetMapping("/parse/{keyword}")
public Boolean parse(@PathVariable("keyword") String keyword) throws Exception {
return contentService.parseContent(keyword);
}
15
16
//http://localhost:9090/search/java/1/10 @GetMapping("/search/{keyword}/{pageNo}/{pageSize}")
public List<Map<String, Object>> search(@PathVariable("keyword") String keyword,
@PathVariable("pageNo") int pageNo, @PathVariable("pageSize") int pageSize) throws
Exception {
17
18
19
20
21
return contentService.searchContentPage(keyword,pageNo,pageSize);
}
}

## 前端逻辑

1、定义导入 vue 和 axios 的依赖！

1. <script th:src="@{/js/axios.js}"></script>
1. <script th:src="@{/js/vue.min.js}"></script>

2、初始化 Vue 对象，给外层 div 绑定 app 对象！

| 1 | <script>

new Vue({
el: '#app', data: {
keyword: '', results: []
}
})

</script> |

// 搜索关键字
// 搜索的结果 |
| --- | --- | --- |
| 2 | | |
| 3 | | |
| 4 | | |
| 5 | | |
| 6 | | |
| 7 | | |
| 8 | | |
| 9 | | |
| 10 | | |
| 11 | | |

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834955786-64109615-f6d1-4e86-ab26-7ab67586dec7.png#)3、绑定搜索框及相关事件！
4、编写方法，获取后端传递的数据！

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21

<script>
new Vue({
el: '#app', data: {
keyword: '', results: []
},
methods: {
searchKey(){
var keyword = this.keyword; console.log(keyword);
axios.get('search/'+keyword+"/1/10").then(response=>{ console.log(response);
this.results = response.data;
});
}
}
})

</script>

5、渲染解析回来的数据！

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834956297-142fe9a8-5ef1-4a55-9ff8-0ec473f6d7f4.png#)

## 搜索高亮

1、编写业务类，处理高亮字段

1.  // 3、实现搜索功能，带高亮
1.  public List<Map<String, Object>> searchContentHighlighter(String keyword, int pageNo, int pageSize) throws IOException {

3

1.  // 基本的参数判断！
1.  if(pageNo <= 1){
1.  pageNo = 1; 7 }
1.  // 基本的条件搜索
1.  SearchRequest searchRequest = new SearchRequest("jd_goods");
1.  SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
1.  // 分页
1.  sourceBuilder.from(pageNo);
1.  sourceBuilder.size(pageSize);
1.  // 精准匹配 QueryBuilders 根据自己要求配置查询条件即可！
1.      TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery("title", keyword);
1.  sourceBuilder.query(termQueryBuilder); 17
1.  // 高亮构建！
1.      HighlightBuilder highlightBuilder = new HighlightBuilder(); //生成高亮查询器
1.  highlightBuilder.field("title"); //高亮查询字段
1.      highlightBuilder.requireFieldMatch(false);	//如果要多个字段高亮,这项要为false
1.  highlightBuilder.preTags("<span style=\"color:red\">"); //高亮设置
1.  highlightBuilder.postTags("</span>"); 24
1.  sourceBuilder.highlighter(highlightBuilder);
1.  sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); 27
1.  // 搜索
1.  searchRequest.source(sourceBuilder);
1.      SearchResponse response = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);

1.  // 解析结果！
1.  List<Map<String, Object>> list = new ArrayList<>();
1.  for (SearchHit hit : response.getHits()) {
1.  //获取高亮字段
1.      Map<String, HighlightField> highlightFields = hit.getHighlightFields();
1.  HighlightField titleField = highlightFields.get("title"); 37

38
39
40
41
42
43
44
45
46
47
48
49
50
51
Map<String, Object> source = hit.getSourceAsMap();
//千万记得要记得判断是不是为空,不然你匹配的第一个结果没有高亮内容,那么就会报空指 针异常,这个错误一开始真的搞了很久
if(titleField!=null){
Text[] fragments = titleField.fragments(); String name = "";
for (Text text : fragments) { name += text;
}
source.put("title", name); //高亮字段替换掉原本的内容
}
list.add(source);
}
return list;
}

2、controller 层调用新的高亮业务！

1. //http://localhost:9090/search/java/1/10
1. @GetMapping("/search/{keyword}/{pageNo}/{pageSize}")
1. public List<Map<String, Object>> search(@PathVariable("keyword") String keyword,
1. @PathVariable("pageNo") int pageNo,
1. @PathVariable("pageSize") int

pageSize) throws Exception {
6
7 return contentService.searchContentHighlighter(keyword,pageNo,pageSize); 8
}

3、前端 vue 指令解析 html！

1 <!--标题-->

1. <p class="productTitle">
1. <a v-html="result.title"> </a> 4 </p>

4、最终效果！

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834957081-7dd4e7b4-f6ae-4c92-8d29-4e63fb1b626e.jpeg#)

# ES 集群

## 为什么要实现集群

ES 基本概念名词

### Cluster

代表一个集群，集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节 点是对于集群内部来说的。es 的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外 部来说的，因为从外部来看 es 集群，在逻辑上是个整体，你与任何一个节点的通信和与整个 es 集群通信是等价的。

### Shards

代表索引分片，es 可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多 个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能 更改。

### Replicas

代表索引副本，es 可以设置多个索引的副本，副本的作用一是提高系统的容错性，当某个节点某个分片 损坏或丢失时可以从副本中恢复。二是提高 es 的查询效率，es 会自动对搜索请求进行负载均衡。

### Recovery

代表数据恢复或叫数据重新分布，es 在有节点加入或退出时会根据机器的负载对索引分片进行重新分 配，挂掉的节点重新启动时也会进行数据恢复。

ES 为什么要实现集群

在单台 ES 服务器节点上，随着业务量的发展索引文件慢慢增多，会影响到效率和内存存储问题等。
我们可以采用 ES 集群，将单个索引的分片到多个不同分布式物理机器上存储，从而可以实现高可用、容错性等。
ES 集群中索引可能由多个分片构成，并且每个分片可以拥有多个副本。通过将一个单独的索引分为多个分片，我们可以处理不能在一个单一的服务器上面运行的大型索引，简单的说就是索引的大小过大，导 致效率问题。不能运行的原因可能是内存也可能是存储。由于每个分片可以有多个副本，通过将副本分 配到多个服务器，可以提高查询的负载能力。

ES 是如何解决高并发
ES 是一个分布式全文检索框架，隐藏了复杂的处理机制，内部使用 分片机制、集群发现、分片负载均衡请求路由。
Shards 分片:代表索引分片，es 可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引 创建后不能更改。
Replicas 分片:代表索引副本，es 可以设置多个索引的副本，副本的作用一是提高系统的容错性，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高 es 的查询效率，es 会自动对搜索请求进行负载均衡。

## 集群规划

搭建一个集群我们需要考虑如下几个问题：
1、我们需要多大规模的集群？
2、集群中的节点角色如何分配？
3、如何避免脑裂问题？
4、索引应该设置多少个分片？
5、分片应该设置几个副本？
下面我们就来分析和回答这几个问题：

我们需要多大规模的集群？

### 需要从以下两个方面考虑：

1、当前的数据量有多大？数据增长情况如何？
2、你的机器配置如何？cpu、多大内存、多大硬盘容量？

### 推算的依据：

ES JVM heap 最大可以设置 32G 。
30G heap 大概能处理的数据量 10 T。如果内存很大如 128G，可在一台机器上运行多个 ES 节点实例。备注：集群规划满足当前数据规模+适量增长规模即可，后续可按需扩展。

### 两类应用场景：

A、用于构建业务搜索功能模块，且多是垂直领域的搜索。数据量级几千万到数十亿级别。一般 2-4 台机器的规模。
B、用于大规模数据的实时 OLAP（联机处理分析），经典的如 ELK Stack，数据规模可能达到千亿或更多。几十到上百节点的规模。

集群中的节点角色如何分配？

### 节点角色：

**Master**
node.master: true 节点可以作为主节点

### DataNode

node.data: true 默认是数据节点。

### Coordinate node 协调节点

如果仅担任协调节点，将上两个配置设为 false。

### 说明：

一个节点可以充当一个或多个角色，默认三个角色都有
协调节点：一个节点只作为接收请求、转发请求到其他节点、汇总各个节点返回数据等功能的节点。就 叫协调节点

### 如何分配：

A、小规模集群，不需严格区分。
B、中大规模集群（十个以上节点），应考虑单独的角色充当。特别并发查询量大，查询的合并量大， 可以增加独立的协调节点。角色分开的好处是分工分开，不互影响。如不会因协调角色负载过高而影响 数据节点的能力。

如何避免脑裂问题？

### 脑裂问题：

一个集群中只有一个 A 主节点，A 主节点因为需要处理的东西太多或者网络过于繁忙，从而导致其他从节 点 ping 不通 A 主节点，这样其他从节点就会认为 A 主节点不可用了，就会重新选出一个新的主节点 B。过了一会 A 主节点恢复正常了，这样就出现了两个主节点，导致一部分数据来源于 A 主节点，另外一部分数 据来源于 B 主节点，出现数据不一致问题，这就是**脑裂**。

### 尽量避免脑裂，需要添加最小数量的主节点配置：

**discovery.zen.minimum_master_nodes: **(有 master 资格节点数/2) + 1
这个参数控制的是，选举主节点时需要看到最少多少个具有 master 资格的活节点，才能进行选举。官方的推荐值是(N/2)+1，其中 N 是具有 master 资格的节点的数量。

### 常用做法（中大规模集群）：

1、Master 和 dataNode 角色分开，配置奇数个 master，如 3
2、单播发现机制，配置 master 资格节点：

discovery.zen.ping.multicast.enabled: false —— 关闭多播发现机制，默认是关闭的
discovery.zen.ping.unicast.hosts: ["master1", "master2", "master3"] —— 配置单播发现的主节点 ip 地址，其他从节点要加入进来，就得去询问单播发现机制里面配置的主节点我要加入到集群里面了，主节 点同意以后才能加入，然后主节点再通知集群中的其他节点有新节点加入
3、配置选举发现数，及延长 ping master 的等待时长
discovery.zen.ping_timeout: 30（默认值是 3 秒）——其他节点 ping 主节点多久时间没有响应就认为主节点不可用了
discovery.zen.minimum_master_nodes: 2 —— 选举主节点时需要看到最少多少个具有 master 资格的活节点，才能进行选举

索引应该设置多少个分片？
说明：分片数指定后不可变，除非重索引。

### 思考：

分片对应的存储实体是什么？存储的实体是索引分片是不是越多越好？不是
分片多有什么影响？分片多浪费存储空间、占用资源、影响性能

### 分片过多的影响：

每个分片本质上就是一个 Lucene 索引, 因此会消耗相应的文件句柄, 内存和 CPU 资源。
每个搜索请求会调度到索引的每个分片中. 如果分片分散在不同的节点倒是问题不太. 但当分片开始竞争相同的硬件资源时, 性能便会逐步下降。
ES 使用词频统计来计算相关性. 当然这些统计也会分配到各个分片上. 如果在大量分片上只维护了很少的数据, 则将导致最终的文档相关性较差。

### 分片设置的可参考原则：

ElasticSearch 推荐的最大 JVM 堆空间是 30~32G, 所以把你的分片最大容量限制为 30GB, 然后再对分片数量做合理估算. 例如, 你认为你的数据能达到 200GB, 推荐你最多分配 7 到 8 个分片。
在开始阶段, 一个好的方案是根据你的节点数量按照 1.5~3 倍的原则来创建分片. 例如,如果你有 3 个节点, 则推荐你创建的分片数最多不超过 9(3x3)个。当性能下降时，增加节点，ES 会平衡分片的放置。
对于基于日期的索引需求, 并且对索引数据的搜索场景非常少. 也许这些索引量将达到成百上千, 但每个索引的数据量只有 1GB 甚至更小. 对于这种类似场景, 建议只需要为索引分配 1 个分片。如日志管理就是一个日期的索引需求，日期索引会很多，但每个索引存放的日志数据量就很少。

分片应该设置几个副本？
说明：副本数是可以随时调整的！

### 思考：

副本的用途是什么？备份数据保证高可用数据不丢失，高并发的时候参与数据查询
针对它的用途，我们该如何设置它的副本数？一般一个分片有 1-2 个副本即可保证高可用
集群规模没变的情况下副本过多会有什么影响？副本多浪费存储空间、占用资源、影响性能

### 副本设置基本原则：

为保证高可用，副本数设置为 2 即可。要求集群至少要有 3 个节点，来分开存放主分片、副本。如发现并发量大时，查询性能会下降，可增加副本数，来提升并发查询能力。
注意：新增副本时主节点会自动协调，然后拷贝数据到新增的副本节点

## 集群核心原理分析

1、每个索引会被分成多个分片 shards 进行存储，默认创建索引是分配 5 个分片进行存储。每个分片都会分布式部署在多个不同的节点上进行部署，该分片成为 primary shards。
注意：索引的主分片 primary shards 定义好后，后面不能做修改。
2、为了实现高可用数据的高可用，主分片可以有对应的备分片 replics shards，replic shards 分片承载了负责容错、以及请求的负载均衡。
注意: 每一个主分片为了实现高可用，都会有自己对应的备分片，主分片对应的备分片不能存放同一台服务器上。主分片 primary shards 可以和其他 replics shards 存放在同一个 node 节点上。
3、documnet routing（数据路由）
当客户端发起创建 document 的时候，es 需要确定这个 document 放在该 index 哪个 shard 上。这个过程 就是数据路由。
路由算法：shard = hash(routing) % number_of_primary_shards
如果 number_of_primary_shards 在查询的时候取余发生的变化，无法获取到该数据 注意：索引的主分片数量定义好后，不能被修改

![](https://cdn.nlark.com/yuque/0/2021/png/21990331/1625834957794-b8bebdd5-ed51-40b6-acd9-32e5dbced544.png#)

高可用视图分析
下图所示：上面的图，如果节点 1 与节点 2 宕机了，es 集群数据就不完整了。

![](https://cdn.nlark.com/yuque/0/2021/jpeg/21990331/1625834958054-3a6d838c-d564-4b33-bffd-402a5c296ac4.jpeg#)下图，如果节点 1 与节点 2 宕机了，es 集群数据还是完整的

## 集群搭建

1、复制三个 es 的文件
2、进入 elasticsearch 的 conﬁg 目录，修改 elasticsearch.yml 的配置

| 1   | # ================= Elasticsearch Configuration ===================                          |
| --- | -------------------------------------------------------------------------------------------- |
| 2   | # 配置 es 的集群名称, es 会自动发现在同一网段下的 es,如果在同一网段下有多个集群,就可以用这个 |
|     | 属性来区分不同的集群｡                                                                        |
| 3   | cluster.name: elasticsearch                                                                  |
| 4   | # 节点名称（要修改）                                                                         |
| 5   | node.name: node-001                                                                          |
| 6   | # 指定该节点是否有资格被选举成为 node                                                        |
| 7   | node.master: true                                                                            |
| 8   | # 指定该节点是否存储索引数据,默认为 true｡                                                    |
| 9   | node.data: true                                                                              |
| 10  | # 设置绑定的 ip 地址还有其它节点和该节点交互的 ip 地址,本机 ip                               |
| 11  | network.host: 127.0.0.1                                                                      |
| 12  | # 指定 http 端口,你使用 head､kopf 等相关插件使用的端口 （要修改）                            |
| 13  | http.port: 9200                                                                              |
| 14  | # 设置节点间交互的 tcp 端口,默认是 9300｡ （要修改）                                          |
| 15  | transport.tcp.port: 9300                                                                     |
| 16  | #设置集群中 master 节点的初始列表,可以通过这些节点来自动发现新加入集群的节点｡                |
| 17  | #因为下两台 elasticsearch 的 port 端口会设置成 9301 和 9302 所以写入两台#elasticsearch 地    |
|     | 址的完整路径                                                                                 |
| 18  | discovery.zen.ping.unicast.hosts:                                                            |
|     | ["127.0.0.1:9300","127.0.0.1:9301","127.0.0.1:9302"]                                         |
| 19  | #如果要使用 head,那么需要解决跨域问题,使 head 插件可以访问 es                                |
| 20  | http.cors.enabled: true                                                                      |
| 21  | http.cors.allow-origin: "\*"                                                                 |

配置解析

### IP 访问限制、默认端口修改 9200

这里有两个需要提醒下，第一个就是 IP 访问限制，第二个就是 es 实例的默认端口号 9200。IP 访问限制可以限定具体的 IP 访问服务器，这有一定的安全过滤作用。

1 # Set the bind address to a specific IP (IPv4 or IPv6): 2 #
3 network.host: 192.168.152.128

如果设置成 0.0.0.0 则是不限制任何 IP 访问。一般在生产的服务器可能会限定几台 IP，通常用于管理使用。
默认的端口 9200 在一般情况下也有点风险，可以将默认的端口修改成另外一个，这还有一个原因就是怕开发人员误操作，连接上集群。当然，如果你的公司网络隔离做的很好也无所谓。

| 1   | #                             |
| --- | ----------------------------- |
| 2   | # Set a custom port for HTTP: |
| 3   | #                             |
| 4   | http.port: 9200               |
| 5   | transport.tcp.port: 9300      |

这里的 9300 是集群内部通讯使用的端口，这个也可以修改掉。因为连接集群的方式有两种，通过扮演集群 node 也是可以进入集群的，所以还是安全起见，修改掉默认的端口。
说明：记得修改安装了 ES 的 3 台虚拟机（三个节点）的相同配置，要不然节点之间无法建立连接工作， 也会报错。

### 集群发现 IP 列表、node、cluster 名称

紧接着修改集群节点 IP 地址，这样可以让集群在规定的几个节点之间工作。elasticsearch，默认是使用 自动发现 IP 机制。就是在当前网段内，只要能被自动感知到的 IP 就能自动加入到集群中。这有好处也有 坏处。好处就是自动化了，当你的 es 集群需要云化的时候就会非常方便。但是也会带来一些不稳定的情 况，如，master 的选举问题、数据复制问题。
导致 master 选举的因素之一就是集群有节点进入。当数据复制发生的时候也会影响集群，因为要做数据平衡复制和冗余。这里面可以独立 master 集群，剔除 master 集群的数据节点能力。
固定列表的 IP 发现有两种配置方式，一种是互相依赖发现，一种是全量发现。各有优势吧，我是使用的 依赖发现来做的。这有个很重要的参考标准，就是你的集群扩展速度有多快。因为这有个问题就是，当 全量发现的时候，如果是初始化集群会有很大的问题，就是 master 全局会很长，然后节点之间的启动速度各不一样。所以我采用了靠谱点的依赖发现。
你需要在 192.168.152.128 的 elasticsearch 中配置成：

## 1 # --------------------------------- Discovery -------------------------------

2 #

1. # Pass an initial list of hosts to perform discovery when new node is started:
1. # The default list of hosts is ["127.0.0.1", "[::1]"] 5

6 discovery.zen.ping.unicast.hosts: [
"192.168.152.129:9300","192.168.152.130:9300" ]

让他去发现 129，130 的机器，以此内推，完成剩下的 129 和 130 机器的配置。
然后你需要配置下集群名称，就是你当前节点所在集群的名称，这有助于你规划你的集群。集群中的所 有节点的集群名称必须一样，只有集群名称一样才能组成一个逻辑集群。

| 1   | # ---------------------------------- Cluster -------------------------------- |
| --- | ----------------------------------------------------------------------------- |
|     | ---                                                                           |
| 2   | #                                                                             |
| 3   | # Use a descriptive name for your cluster:                                    |
| 4   | #                                                                             |
| 5   | cluster.name: mycluster                                                       |

配置你当前节点的名称

| 1   | # ------------------------------------ Node --------------------------------- |
| --- | ----------------------------------------------------------------------------- |
|     | ---                                                                           |
| 2   | #                                                                             |
| 3   | # Use a descriptive name for the node:                                        |
| 4   | #                                                                             |
| 5   | node.name: node-1                                                             |

以此类推，完成另外两个节点的配置。cluster.name 的名称必须保持一样。然后分别设置 node.name。

### 说明：

这里搭建的是一个简单的集群，没有做集群节点角色的区分，所以 3 个节点默认的角色有主节点、数据节 点、协调节点

### 选举 ES 主节点的逻辑：

选举的大概逻辑，它会根据分片的数据的前后新鲜程度来作为选举的一个重要逻辑。（日志、数据、时 间都会作为集群 master 全局的重要指标）
因为考虑到数据一致性问题，当然是用最新的数据节点作为 master，然后进行新数据的复制和刷新其他
node。
